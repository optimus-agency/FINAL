#if defined(_WIN32)
#if defined(_MSC_VER)
        #pragma warning (disable:4018) // 'expression' : signed/unsigned mismatch
        #pragma warning (disable:4065) // switch statement contains 'default' but no 'case' labels
        #pragma warning (disable:4146) // unary minus operator applied to unsigned type, result still unsigned
        #pragma warning (disable:4244) // 'conversion' conversion from 'type1' to 'type2', possible loss of data
        #pragma warning (disable:4251) // 'identifier' : class 'type' needs to have dll-interface to be used by clients of class 'type2'
        #pragma warning (disable:4637) // 'var' : conversion from 'size_t' to 'type', possible loss of data
        #pragma warning (disable:4305) // 'identifier' : truncation from 'type1' to 'type2'
        #pragma warning (disable:4307) // 'operator' : integral constant overflow
        #pragma warning (disable:4309) // 'conversion' : truncation of constant value
        #pragma warning (disable:4334) // 'operator' : result of 32-bit shift implicitly converted to 64 bits (was 64-bit shift intended?)
        #pragma warning (disable:4355) // 'this' : used in base member initializer list
        #pragma warning (disable:4506) // no definition for inline function 'function'
        #pragma warning (disable:4996) // The compiler encountered a deprecated declaration.
        #pragma warning (disable:4125) // decimal digit terminates octal escape sequence
        #pragma warning (disable:4800) // decimal digit terminates octal escape sequence
        #pragma warning (disable:4668) // decimal digit terminates octal escape sequence
        #endif

        // Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service.proto
// Protobuf C++ Version: 5.26.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_service_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_service_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION != 5026001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "arkit_blend_shapes.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_service_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_service_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_service_2eproto;
namespace service {
class ActionConfig;
struct ActionConfigDefaultTypeInternal;
extern ActionConfigDefaultTypeInternal _ActionConfig_default_instance_;
class ActionConfig_Character;
struct ActionConfig_CharacterDefaultTypeInternal;
extern ActionConfig_CharacterDefaultTypeInternal _ActionConfig_Character_default_instance_;
class ActionConfig_Object;
struct ActionConfig_ObjectDefaultTypeInternal;
extern ActionConfig_ObjectDefaultTypeInternal _ActionConfig_Object_default_instance_;
class AudioConfig;
struct AudioConfigDefaultTypeInternal;
extern AudioConfigDefaultTypeInternal _AudioConfig_default_instance_;
class BlendShapesData;
struct BlendShapesDataDefaultTypeInternal;
extern BlendShapesDataDefaultTypeInternal _BlendShapesData_default_instance_;
class DynamicInfoConfig;
struct DynamicInfoConfigDefaultTypeInternal;
extern DynamicInfoConfigDefaultTypeInternal _DynamicInfoConfig_default_instance_;
class EmotionResponse;
struct EmotionResponseDefaultTypeInternal;
extern EmotionResponseDefaultTypeInternal _EmotionResponse_default_instance_;
class FeedbackRequest;
struct FeedbackRequestDefaultTypeInternal;
extern FeedbackRequestDefaultTypeInternal _FeedbackRequest_default_instance_;
class FeedbackRequest_Feedback;
struct FeedbackRequest_FeedbackDefaultTypeInternal;
extern FeedbackRequest_FeedbackDefaultTypeInternal _FeedbackRequest_Feedback_default_instance_;
class FeedbackResponse;
struct FeedbackResponseDefaultTypeInternal;
extern FeedbackResponseDefaultTypeInternal _FeedbackResponse_default_instance_;
class GetResponseRequest;
struct GetResponseRequestDefaultTypeInternal;
extern GetResponseRequestDefaultTypeInternal _GetResponseRequest_default_instance_;
class GetResponseRequestSingle;
struct GetResponseRequestSingleDefaultTypeInternal;
extern GetResponseRequestSingleDefaultTypeInternal _GetResponseRequestSingle_default_instance_;
class GetResponseRequest_GetResponseConfig;
struct GetResponseRequest_GetResponseConfigDefaultTypeInternal;
extern GetResponseRequest_GetResponseConfigDefaultTypeInternal _GetResponseRequest_GetResponseConfig_default_instance_;
class GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUse;
struct GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUseDefaultTypeInternal;
extern GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUseDefaultTypeInternal _GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUse_default_instance_;
class GetResponseRequest_GetResponseData;
struct GetResponseRequest_GetResponseDataDefaultTypeInternal;
extern GetResponseRequest_GetResponseDataDefaultTypeInternal _GetResponseRequest_GetResponseData_default_instance_;
class GetResponseResponse;
struct GetResponseResponseDefaultTypeInternal;
extern GetResponseResponseDefaultTypeInternal _GetResponseResponse_default_instance_;
class GetResponseResponse_ActionResponse;
struct GetResponseResponse_ActionResponseDefaultTypeInternal;
extern GetResponseResponse_ActionResponseDefaultTypeInternal _GetResponseResponse_ActionResponse_default_instance_;
class GetResponseResponse_AudioResponse;
struct GetResponseResponse_AudioResponseDefaultTypeInternal;
extern GetResponseResponse_AudioResponseDefaultTypeInternal _GetResponseResponse_AudioResponse_default_instance_;
class GetResponseResponse_BehaviorTreeResponse;
struct GetResponseResponse_BehaviorTreeResponseDefaultTypeInternal;
extern GetResponseResponse_BehaviorTreeResponseDefaultTypeInternal _GetResponseResponse_BehaviorTreeResponse_default_instance_;
class GetResponseResponse_UserTranscript;
struct GetResponseResponse_UserTranscriptDefaultTypeInternal;
extern GetResponseResponse_UserTranscriptDefaultTypeInternal _GetResponseResponse_UserTranscript_default_instance_;
class HelloRequest;
struct HelloRequestDefaultTypeInternal;
extern HelloRequestDefaultTypeInternal _HelloRequest_default_instance_;
class HelloResponse;
struct HelloResponseDefaultTypeInternal;
extern HelloResponseDefaultTypeInternal _HelloResponse_default_instance_;
class STTRequest;
struct STTRequestDefaultTypeInternal;
extern STTRequestDefaultTypeInternal _STTRequest_default_instance_;
class STTResponse;
struct STTResponseDefaultTypeInternal;
extern STTResponseDefaultTypeInternal _STTResponse_default_instance_;
class TriggerConfig;
struct TriggerConfigDefaultTypeInternal;
extern TriggerConfigDefaultTypeInternal _TriggerConfig_default_instance_;
class Viseme;
struct VisemeDefaultTypeInternal;
extern VisemeDefaultTypeInternal _Viseme_default_instance_;
class VisemesData;
struct VisemesDataDefaultTypeInternal;
extern VisemesDataDefaultTypeInternal _VisemesData_default_instance_;
class VisionInput;
struct VisionInputDefaultTypeInternal;
extern VisionInputDefaultTypeInternal _VisionInput_default_instance_;
class VisionInput_ImageData;
struct VisionInput_ImageDataDefaultTypeInternal;
extern VisionInput_ImageDataDefaultTypeInternal _VisionInput_ImageData_default_instance_;
class VisionInput_VideoData;
struct VisionInput_VideoDataDefaultTypeInternal;
extern VisionInput_VideoDataDefaultTypeInternal _VisionInput_VideoData_default_instance_;
}  // namespace service
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace service {
enum FaceModel : int {
  FACE_MODEL_UNSPECIFIED = 0,
  FACE_MODEL_A_2F_MODEL_NAME = 1,
  FACE_MODEL_PHONEMES_MODEL_NAME = 2,
  FACE_MODEL_OVR_MODEL_NAME = 3,
  FaceModel_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  FaceModel_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool FaceModel_IsValid(int value);
extern const uint32_t FaceModel_internal_data_[];
constexpr FaceModel FaceModel_MIN = static_cast<FaceModel>(0);
constexpr FaceModel FaceModel_MAX = static_cast<FaceModel>(3);
constexpr int FaceModel_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
FaceModel_descriptor();
template <typename T>
const std::string& FaceModel_Name(T value) {
  static_assert(std::is_same<T, FaceModel>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FaceModel_Name().");
  return FaceModel_Name(static_cast<FaceModel>(value));
}
template <>
inline const std::string& FaceModel_Name(FaceModel value) {
  return ::google::protobuf::internal::NameOfDenseEnum<FaceModel_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool FaceModel_Parse(absl::string_view name, FaceModel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FaceModel>(
      FaceModel_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class VisionInput_VideoData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:service.VisionInput.VideoData) */ {
 public:
  inline VisionInput_VideoData() : VisionInput_VideoData(nullptr) {}
  ~VisionInput_VideoData() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VisionInput_VideoData(
      ::google::protobuf::internal::ConstantInitialized);

  inline VisionInput_VideoData(const VisionInput_VideoData& from) : VisionInput_VideoData(nullptr, from) {}
  inline VisionInput_VideoData(VisionInput_VideoData&& from) noexcept
      : VisionInput_VideoData(nullptr, std::move(from)) {}
  inline VisionInput_VideoData& operator=(const VisionInput_VideoData& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisionInput_VideoData& operator=(VisionInput_VideoData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisionInput_VideoData& default_instance() {
    return *internal_default_instance();
  }
  static inline const VisionInput_VideoData* internal_default_instance() {
    return reinterpret_cast<const VisionInput_VideoData*>(
        &_VisionInput_VideoData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(VisionInput_VideoData& a, VisionInput_VideoData& b) { a.Swap(&b); }
  inline void Swap(VisionInput_VideoData* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisionInput_VideoData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisionInput_VideoData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<VisionInput_VideoData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VisionInput_VideoData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VisionInput_VideoData& from) { VisionInput_VideoData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VisionInput_VideoData* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "service.VisionInput.VideoData"; }

 protected:
  explicit VisionInput_VideoData(::google::protobuf::Arena* arena);
  VisionInput_VideoData(::google::protobuf::Arena* arena, const VisionInput_VideoData& from);
  VisionInput_VideoData(::google::protobuf::Arena* arena, VisionInput_VideoData&& from) noexcept
      : VisionInput_VideoData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 4,
    kFpsFieldNumber = 1,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
  };
  // bytes data = 4;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // int32 fps = 1;
  void clear_fps() ;
  ::int32_t fps() const;
  void set_fps(::int32_t value);

  private:
  ::int32_t _internal_fps() const;
  void _internal_set_fps(::int32_t value);

  public:
  // int32 width = 2;
  void clear_width() ;
  ::int32_t width() const;
  void set_width(::int32_t value);

  private:
  ::int32_t _internal_width() const;
  void _internal_set_width(::int32_t value);

  public:
  // int32 height = 3;
  void clear_height() ;
  ::int32_t height() const;
  void set_height(::int32_t value);

  private:
  ::int32_t _internal_height() const;
  void _internal_set_height(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:service.VisionInput.VideoData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::int32_t fps_;
    ::int32_t width_;
    ::int32_t height_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class VisionInput_ImageData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:service.VisionInput.ImageData) */ {
 public:
  inline VisionInput_ImageData() : VisionInput_ImageData(nullptr) {}
  ~VisionInput_ImageData() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VisionInput_ImageData(
      ::google::protobuf::internal::ConstantInitialized);

  inline VisionInput_ImageData(const VisionInput_ImageData& from) : VisionInput_ImageData(nullptr, from) {}
  inline VisionInput_ImageData(VisionInput_ImageData&& from) noexcept
      : VisionInput_ImageData(nullptr, std::move(from)) {}
  inline VisionInput_ImageData& operator=(const VisionInput_ImageData& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisionInput_ImageData& operator=(VisionInput_ImageData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisionInput_ImageData& default_instance() {
    return *internal_default_instance();
  }
  static inline const VisionInput_ImageData* internal_default_instance() {
    return reinterpret_cast<const VisionInput_ImageData*>(
        &_VisionInput_ImageData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(VisionInput_ImageData& a, VisionInput_ImageData& b) { a.Swap(&b); }
  inline void Swap(VisionInput_ImageData* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisionInput_ImageData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisionInput_ImageData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<VisionInput_ImageData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VisionInput_ImageData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VisionInput_ImageData& from) { VisionInput_ImageData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VisionInput_ImageData* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "service.VisionInput.ImageData"; }

 protected:
  explicit VisionInput_ImageData(::google::protobuf::Arena* arena);
  VisionInput_ImageData(::google::protobuf::Arena* arena, const VisionInput_ImageData& from);
  VisionInput_ImageData(::google::protobuf::Arena* arena, VisionInput_ImageData&& from) noexcept
      : VisionInput_ImageData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 3,
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // bytes data = 3;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // int32 width = 1;
  void clear_width() ;
  ::int32_t width() const;
  void set_width(::int32_t value);

  private:
  ::int32_t _internal_width() const;
  void _internal_set_width(::int32_t value);

  public:
  // int32 height = 2;
  void clear_height() ;
  ::int32_t height() const;
  void set_height(::int32_t value);

  private:
  ::int32_t _internal_height() const;
  void _internal_set_height(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:service.VisionInput.ImageData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::int32_t width_;
    ::int32_t height_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class Viseme final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:service.Viseme) */ {
 public:
  inline Viseme() : Viseme(nullptr) {}
  ~Viseme() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Viseme(
      ::google::protobuf::internal::ConstantInitialized);

  inline Viseme(const Viseme& from) : Viseme(nullptr, from) {}
  inline Viseme(Viseme&& from) noexcept
      : Viseme(nullptr, std::move(from)) {}
  inline Viseme& operator=(const Viseme& from) {
    CopyFrom(from);
    return *this;
  }
  inline Viseme& operator=(Viseme&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Viseme& default_instance() {
    return *internal_default_instance();
  }
  static inline const Viseme* internal_default_instance() {
    return reinterpret_cast<const Viseme*>(
        &_Viseme_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(Viseme& a, Viseme& b) { a.Swap(&b); }
  inline void Swap(Viseme* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Viseme* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Viseme* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Viseme>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Viseme& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Viseme& from) { Viseme::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Viseme* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "service.Viseme"; }

 protected:
  explicit Viseme(::google::protobuf::Arena* arena);
  Viseme(::google::protobuf::Arena* arena, const Viseme& from);
  Viseme(::google::protobuf::Arena* arena, Viseme&& from) noexcept
      : Viseme(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSilFieldNumber = 1,
    kPpFieldNumber = 2,
    kFfFieldNumber = 3,
    kThFieldNumber = 4,
    kDdFieldNumber = 5,
    kKkFieldNumber = 6,
    kChFieldNumber = 7,
    kSsFieldNumber = 8,
    kNnFieldNumber = 9,
    kRrFieldNumber = 10,
    kAaFieldNumber = 11,
    kEFieldNumber = 12,
    kIhFieldNumber = 13,
    kOhFieldNumber = 14,
    kOuFieldNumber = 15,
  };
  // float sil = 1;
  void clear_sil() ;
  float sil() const;
  void set_sil(float value);

  private:
  float _internal_sil() const;
  void _internal_set_sil(float value);

  public:
  // float pp = 2;
  void clear_pp() ;
  float pp() const;
  void set_pp(float value);

  private:
  float _internal_pp() const;
  void _internal_set_pp(float value);

  public:
  // float ff = 3;
  void clear_ff() ;
  float ff() const;
  void set_ff(float value);

  private:
  float _internal_ff() const;
  void _internal_set_ff(float value);

  public:
  // float th = 4;
  void clear_th() ;
  float th() const;
  void set_th(float value);

  private:
  float _internal_th() const;
  void _internal_set_th(float value);

  public:
  // float dd = 5;
  void clear_dd() ;
  float dd() const;
  void set_dd(float value);

  private:
  float _internal_dd() const;
  void _internal_set_dd(float value);

  public:
  // float kk = 6;
  void clear_kk() ;
  float kk() const;
  void set_kk(float value);

  private:
  float _internal_kk() const;
  void _internal_set_kk(float value);

  public:
  // float ch = 7;
  void clear_ch() ;
  float ch() const;
  void set_ch(float value);

  private:
  float _internal_ch() const;
  void _internal_set_ch(float value);

  public:
  // float ss = 8;
  void clear_ss() ;
  float ss() const;
  void set_ss(float value);

  private:
  float _internal_ss() const;
  void _internal_set_ss(float value);

  public:
  // float nn = 9;
  void clear_nn() ;
  float nn() const;
  void set_nn(float value);

  private:
  float _internal_nn() const;
  void _internal_set_nn(float value);

  public:
  // float rr = 10;
  void clear_rr() ;
  float rr() const;
  void set_rr(float value);

  private:
  float _internal_rr() const;
  void _internal_set_rr(float value);

  public:
  // float aa = 11;
  void clear_aa() ;
  float aa() const;
  void set_aa(float value);

  private:
  float _internal_aa() const;
  void _internal_set_aa(float value);

  public:
  // float e = 12;
  void clear_e() ;
  float e() const;
  void set_e(float value);

  private:
  float _internal_e() const;
  void _internal_set_e(float value);

  public:
  // float ih = 13;
  void clear_ih() ;
  float ih() const;
  void set_ih(float value);

  private:
  float _internal_ih() const;
  void _internal_set_ih(float value);

  public:
  // float oh = 14;
  void clear_oh() ;
  float oh() const;
  void set_oh(float value);

  private:
  float _internal_oh() const;
  void _internal_set_oh(float value);

  public:
  // float ou = 15;
  void clear_ou() ;
  float ou() const;
  void set_ou(float value);

  private:
  float _internal_ou() const;
  void _internal_set_ou(float value);

  public:
  // @@protoc_insertion_point(class_scope:service.Viseme)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 15, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    float sil_;
    float pp_;
    float ff_;
    float th_;
    float dd_;
    float kk_;
    float ch_;
    float ss_;
    float nn_;
    float rr_;
    float aa_;
    float e_;
    float ih_;
    float oh_;
    float ou_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class TriggerConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:service.TriggerConfig) */ {
 public:
  inline TriggerConfig() : TriggerConfig(nullptr) {}
  ~TriggerConfig() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TriggerConfig(
      ::google::protobuf::internal::ConstantInitialized);

  inline TriggerConfig(const TriggerConfig& from) : TriggerConfig(nullptr, from) {}
  inline TriggerConfig(TriggerConfig&& from) noexcept
      : TriggerConfig(nullptr, std::move(from)) {}
  inline TriggerConfig& operator=(const TriggerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline TriggerConfig& operator=(TriggerConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TriggerConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const TriggerConfig* internal_default_instance() {
    return reinterpret_cast<const TriggerConfig*>(
        &_TriggerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(TriggerConfig& a, TriggerConfig& b) { a.Swap(&b); }
  inline void Swap(TriggerConfig* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TriggerConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TriggerConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TriggerConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TriggerConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TriggerConfig& from) { TriggerConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TriggerConfig* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "service.TriggerConfig"; }

 protected:
  explicit TriggerConfig(::google::protobuf::Arena* arena);
  TriggerConfig(::google::protobuf::Arena* arena, const TriggerConfig& from);
  TriggerConfig(::google::protobuf::Arena* arena, TriggerConfig&& from) noexcept
      : TriggerConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTriggerNameFieldNumber = 1,
    kTriggerMessageFieldNumber = 2,
  };
  // string trigger_name = 1;
  void clear_trigger_name() ;
  const std::string& trigger_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_trigger_name(Arg_&& arg, Args_... args);
  std::string* mutable_trigger_name();
  PROTOBUF_NODISCARD std::string* release_trigger_name();
  void set_allocated_trigger_name(std::string* value);

  private:
  const std::string& _internal_trigger_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trigger_name(
      const std::string& value);
  std::string* _internal_mutable_trigger_name();

  public:
  // string trigger_message = 2;
  void clear_trigger_message() ;
  const std::string& trigger_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_trigger_message(Arg_&& arg, Args_... args);
  std::string* mutable_trigger_message();
  PROTOBUF_NODISCARD std::string* release_trigger_message();
  void set_allocated_trigger_message(std::string* value);

  private:
  const std::string& _internal_trigger_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trigger_message(
      const std::string& value);
  std::string* _internal_mutable_trigger_message();

  public:
  // @@protoc_insertion_point(class_scope:service.TriggerConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      57, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr trigger_name_;
    ::google::protobuf::internal::ArenaStringPtr trigger_message_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class STTResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:service.STTResponse) */ {
 public:
  inline STTResponse() : STTResponse(nullptr) {}
  ~STTResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR STTResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline STTResponse(const STTResponse& from) : STTResponse(nullptr, from) {}
  inline STTResponse(STTResponse&& from) noexcept
      : STTResponse(nullptr, std::move(from)) {}
  inline STTResponse& operator=(const STTResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline STTResponse& operator=(STTResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const STTResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const STTResponse* internal_default_instance() {
    return reinterpret_cast<const STTResponse*>(
        &_STTResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(STTResponse& a, STTResponse& b) { a.Swap(&b); }
  inline void Swap(STTResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(STTResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  STTResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<STTResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const STTResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const STTResponse& from) { STTResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(STTResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "service.STTResponse"; }

 protected:
  explicit STTResponse(::google::protobuf::Arena* arena);
  STTResponse(::google::protobuf::Arena* arena, const STTResponse& from);
  STTResponse(::google::protobuf::Arena* arena, STTResponse&& from) noexcept
      : STTResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTextFieldNumber = 1,
  };
  // string text = 1;
  void clear_text() ;
  const std::string& text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* value);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // @@protoc_insertion_point(class_scope:service.STTResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      32, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr text_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class HelloResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:service.HelloResponse) */ {
 public:
  inline HelloResponse() : HelloResponse(nullptr) {}
  ~HelloResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HelloResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline HelloResponse(const HelloResponse& from) : HelloResponse(nullptr, from) {}
  inline HelloResponse(HelloResponse&& from) noexcept
      : HelloResponse(nullptr, std::move(from)) {}
  inline HelloResponse& operator=(const HelloResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloResponse& operator=(HelloResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HelloResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HelloResponse* internal_default_instance() {
    return reinterpret_cast<const HelloResponse*>(
        &_HelloResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(HelloResponse& a, HelloResponse& b) { a.Swap(&b); }
  inline void Swap(HelloResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HelloResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<HelloResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HelloResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HelloResponse& from) { HelloResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HelloResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "service.HelloResponse"; }

 protected:
  explicit HelloResponse(::google::protobuf::Arena* arena);
  HelloResponse(::google::protobuf::Arena* arena, const HelloResponse& from);
  HelloResponse(::google::protobuf::Arena* arena, HelloResponse&& from) noexcept
      : HelloResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // @@protoc_insertion_point(class_scope:service.HelloResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      37, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class HelloRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:service.HelloRequest) */ {
 public:
  inline HelloRequest() : HelloRequest(nullptr) {}
  ~HelloRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HelloRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline HelloRequest(const HelloRequest& from) : HelloRequest(nullptr, from) {}
  inline HelloRequest(HelloRequest&& from) noexcept
      : HelloRequest(nullptr, std::move(from)) {}
  inline HelloRequest& operator=(const HelloRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloRequest& operator=(HelloRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HelloRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HelloRequest* internal_default_instance() {
    return reinterpret_cast<const HelloRequest*>(
        &_HelloRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(HelloRequest& a, HelloRequest& b) { a.Swap(&b); }
  inline void Swap(HelloRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HelloRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<HelloRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HelloRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HelloRequest& from) { HelloRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HelloRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "service.HelloRequest"; }

 protected:
  explicit HelloRequest(::google::protobuf::Arena* arena);
  HelloRequest(::google::protobuf::Arena* arena, const HelloRequest& from);
  HelloRequest(::google::protobuf::Arena* arena, HelloRequest&& from) noexcept
      : HelloRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:service.HelloRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      33, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseResponse_UserTranscript final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:service.GetResponseResponse.UserTranscript) */ {
 public:
  inline GetResponseResponse_UserTranscript() : GetResponseResponse_UserTranscript(nullptr) {}
  ~GetResponseResponse_UserTranscript() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetResponseResponse_UserTranscript(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetResponseResponse_UserTranscript(const GetResponseResponse_UserTranscript& from) : GetResponseResponse_UserTranscript(nullptr, from) {}
  inline GetResponseResponse_UserTranscript(GetResponseResponse_UserTranscript&& from) noexcept
      : GetResponseResponse_UserTranscript(nullptr, std::move(from)) {}
  inline GetResponseResponse_UserTranscript& operator=(const GetResponseResponse_UserTranscript& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseResponse_UserTranscript& operator=(GetResponseResponse_UserTranscript&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponseResponse_UserTranscript& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetResponseResponse_UserTranscript* internal_default_instance() {
    return reinterpret_cast<const GetResponseResponse_UserTranscript*>(
        &_GetResponseResponse_UserTranscript_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(GetResponseResponse_UserTranscript& a, GetResponseResponse_UserTranscript& b) { a.Swap(&b); }
  inline void Swap(GetResponseResponse_UserTranscript* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseResponse_UserTranscript* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponseResponse_UserTranscript* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetResponseResponse_UserTranscript>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetResponseResponse_UserTranscript& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetResponseResponse_UserTranscript& from) { GetResponseResponse_UserTranscript::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetResponseResponse_UserTranscript* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "service.GetResponseResponse.UserTranscript"; }

 protected:
  explicit GetResponseResponse_UserTranscript(::google::protobuf::Arena* arena);
  GetResponseResponse_UserTranscript(::google::protobuf::Arena* arena, const GetResponseResponse_UserTranscript& from);
  GetResponseResponse_UserTranscript(::google::protobuf::Arena* arena, GetResponseResponse_UserTranscript&& from) noexcept
      : GetResponseResponse_UserTranscript(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTextDataFieldNumber = 1,
    kIsFinalFieldNumber = 2,
    kEndOfResponseFieldNumber = 3,
  };
  // string text_data = 1;
  void clear_text_data() ;
  const std::string& text_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text_data(Arg_&& arg, Args_... args);
  std::string* mutable_text_data();
  PROTOBUF_NODISCARD std::string* release_text_data();
  void set_allocated_text_data(std::string* value);

  private:
  const std::string& _internal_text_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text_data(
      const std::string& value);
  std::string* _internal_mutable_text_data();

  public:
  // bool is_final = 2;
  void clear_is_final() ;
  bool is_final() const;
  void set_is_final(bool value);

  private:
  bool _internal_is_final() const;
  void _internal_set_is_final(bool value);

  public:
  // bool end_of_response = 3;
  void clear_end_of_response() ;
  bool end_of_response() const;
  void set_end_of_response(bool value);

  private:
  bool _internal_end_of_response() const;
  void _internal_set_end_of_response(bool value);

  public:
  // @@protoc_insertion_point(class_scope:service.GetResponseResponse.UserTranscript)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      60, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr text_data_;
    bool is_final_;
    bool end_of_response_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseResponse_BehaviorTreeResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:service.GetResponseResponse.BehaviorTreeResponse) */ {
 public:
  inline GetResponseResponse_BehaviorTreeResponse() : GetResponseResponse_BehaviorTreeResponse(nullptr) {}
  ~GetResponseResponse_BehaviorTreeResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetResponseResponse_BehaviorTreeResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetResponseResponse_BehaviorTreeResponse(const GetResponseResponse_BehaviorTreeResponse& from) : GetResponseResponse_BehaviorTreeResponse(nullptr, from) {}
  inline GetResponseResponse_BehaviorTreeResponse(GetResponseResponse_BehaviorTreeResponse&& from) noexcept
      : GetResponseResponse_BehaviorTreeResponse(nullptr, std::move(from)) {}
  inline GetResponseResponse_BehaviorTreeResponse& operator=(const GetResponseResponse_BehaviorTreeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseResponse_BehaviorTreeResponse& operator=(GetResponseResponse_BehaviorTreeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponseResponse_BehaviorTreeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetResponseResponse_BehaviorTreeResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponseResponse_BehaviorTreeResponse*>(
        &_GetResponseResponse_BehaviorTreeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(GetResponseResponse_BehaviorTreeResponse& a, GetResponseResponse_BehaviorTreeResponse& b) { a.Swap(&b); }
  inline void Swap(GetResponseResponse_BehaviorTreeResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseResponse_BehaviorTreeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponseResponse_BehaviorTreeResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetResponseResponse_BehaviorTreeResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetResponseResponse_BehaviorTreeResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetResponseResponse_BehaviorTreeResponse& from) { GetResponseResponse_BehaviorTreeResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetResponseResponse_BehaviorTreeResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "service.GetResponseResponse.BehaviorTreeResponse"; }

 protected:
  explicit GetResponseResponse_BehaviorTreeResponse(::google::protobuf::Arena* arena);
  GetResponseResponse_BehaviorTreeResponse(::google::protobuf::Arena* arena, const GetResponseResponse_BehaviorTreeResponse& from);
  GetResponseResponse_BehaviorTreeResponse(::google::protobuf::Arena* arena, GetResponseResponse_BehaviorTreeResponse&& from) noexcept
      : GetResponseResponse_BehaviorTreeResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBtCodeFieldNumber = 1,
    kBtConstantsFieldNumber = 2,
    kNarrativeSectionIdFieldNumber = 3,
  };
  // string bt_code = 1;
  void clear_bt_code() ;
  const std::string& bt_code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bt_code(Arg_&& arg, Args_... args);
  std::string* mutable_bt_code();
  PROTOBUF_NODISCARD std::string* release_bt_code();
  void set_allocated_bt_code(std::string* value);

  private:
  const std::string& _internal_bt_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bt_code(
      const std::string& value);
  std::string* _internal_mutable_bt_code();

  public:
  // string bt_constants = 2;
  void clear_bt_constants() ;
  const std::string& bt_constants() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bt_constants(Arg_&& arg, Args_... args);
  std::string* mutable_bt_constants();
  PROTOBUF_NODISCARD std::string* release_bt_constants();
  void set_allocated_bt_constants(std::string* value);

  private:
  const std::string& _internal_bt_constants() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bt_constants(
      const std::string& value);
  std::string* _internal_mutable_bt_constants();

  public:
  // string narrative_section_id = 3;
  void clear_narrative_section_id() ;
  const std::string& narrative_section_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_narrative_section_id(Arg_&& arg, Args_... args);
  std::string* mutable_narrative_section_id();
  PROTOBUF_NODISCARD std::string* release_narrative_section_id();
  void set_allocated_narrative_section_id(std::string* value);

  private:
  const std::string& _internal_narrative_section_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_narrative_section_id(
      const std::string& value);
  std::string* _internal_mutable_narrative_section_id();

  public:
  // @@protoc_insertion_point(class_scope:service.GetResponseResponse.BehaviorTreeResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      96, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr bt_code_;
    ::google::protobuf::internal::ArenaStringPtr bt_constants_;
    ::google::protobuf::internal::ArenaStringPtr narrative_section_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseResponse_ActionResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:service.GetResponseResponse.ActionResponse) */ {
 public:
  inline GetResponseResponse_ActionResponse() : GetResponseResponse_ActionResponse(nullptr) {}
  ~GetResponseResponse_ActionResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetResponseResponse_ActionResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetResponseResponse_ActionResponse(const GetResponseResponse_ActionResponse& from) : GetResponseResponse_ActionResponse(nullptr, from) {}
  inline GetResponseResponse_ActionResponse(GetResponseResponse_ActionResponse&& from) noexcept
      : GetResponseResponse_ActionResponse(nullptr, std::move(from)) {}
  inline GetResponseResponse_ActionResponse& operator=(const GetResponseResponse_ActionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseResponse_ActionResponse& operator=(GetResponseResponse_ActionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponseResponse_ActionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetResponseResponse_ActionResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponseResponse_ActionResponse*>(
        &_GetResponseResponse_ActionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(GetResponseResponse_ActionResponse& a, GetResponseResponse_ActionResponse& b) { a.Swap(&b); }
  inline void Swap(GetResponseResponse_ActionResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseResponse_ActionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponseResponse_ActionResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetResponseResponse_ActionResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetResponseResponse_ActionResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetResponseResponse_ActionResponse& from) { GetResponseResponse_ActionResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetResponseResponse_ActionResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "service.GetResponseResponse.ActionResponse"; }

 protected:
  explicit GetResponseResponse_ActionResponse(::google::protobuf::Arena* arena);
  GetResponseResponse_ActionResponse(::google::protobuf::Arena* arena, const GetResponseResponse_ActionResponse& from);
  GetResponseResponse_ActionResponse(::google::protobuf::Arena* arena, GetResponseResponse_ActionResponse&& from) noexcept
      : GetResponseResponse_ActionResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kActionFieldNumber = 1,
  };
  // string action = 1;
  void clear_action() ;
  const std::string& action() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_action(Arg_&& arg, Args_... args);
  std::string* mutable_action();
  PROTOBUF_NODISCARD std::string* release_action();
  void set_allocated_action(std::string* value);

  private:
  const std::string& _internal_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action(
      const std::string& value);
  std::string* _internal_mutable_action();

  public:
  // @@protoc_insertion_point(class_scope:service.GetResponseResponse.ActionResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      57, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr action_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUse*>(
        &_GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "service.GetResponseRequest.GetResponseConfig.NarrativeTemplateKeysEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "service.GetResponseRequest.GetResponseConfig.NarrativeTemplateKeysEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class FeedbackResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:service.FeedbackResponse) */ {
 public:
  inline FeedbackResponse() : FeedbackResponse(nullptr) {}
  ~FeedbackResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FeedbackResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline FeedbackResponse(const FeedbackResponse& from) : FeedbackResponse(nullptr, from) {}
  inline FeedbackResponse(FeedbackResponse&& from) noexcept
      : FeedbackResponse(nullptr, std::move(from)) {}
  inline FeedbackResponse& operator=(const FeedbackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedbackResponse& operator=(FeedbackResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedbackResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedbackResponse* internal_default_instance() {
    return reinterpret_cast<const FeedbackResponse*>(
        &_FeedbackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(FeedbackResponse& a, FeedbackResponse& b) { a.Swap(&b); }
  inline void Swap(FeedbackResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedbackResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedbackResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<FeedbackResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FeedbackResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FeedbackResponse& from) { FeedbackResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FeedbackResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "service.FeedbackResponse"; }

 protected:
  explicit FeedbackResponse(::google::protobuf::Arena* arena);
  FeedbackResponse(::google::protobuf::Arena* arena, const FeedbackResponse& from);
  FeedbackResponse(::google::protobuf::Arena* arena, FeedbackResponse&& from) noexcept
      : FeedbackResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFeedbackResponseFieldNumber = 1,
  };
  // string feedback_response = 1;
  void clear_feedback_response() ;
  const std::string& feedback_response() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_feedback_response(Arg_&& arg, Args_... args);
  std::string* mutable_feedback_response();
  PROTOBUF_NODISCARD std::string* release_feedback_response();
  void set_allocated_feedback_response(std::string* value);

  private:
  const std::string& _internal_feedback_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feedback_response(
      const std::string& value);
  std::string* _internal_mutable_feedback_response();

  public:
  // @@protoc_insertion_point(class_scope:service.FeedbackResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      50, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr feedback_response_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class FeedbackRequest_Feedback final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:service.FeedbackRequest.Feedback) */ {
 public:
  inline FeedbackRequest_Feedback() : FeedbackRequest_Feedback(nullptr) {}
  ~FeedbackRequest_Feedback() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FeedbackRequest_Feedback(
      ::google::protobuf::internal::ConstantInitialized);

  inline FeedbackRequest_Feedback(const FeedbackRequest_Feedback& from) : FeedbackRequest_Feedback(nullptr, from) {}
  inline FeedbackRequest_Feedback(FeedbackRequest_Feedback&& from) noexcept
      : FeedbackRequest_Feedback(nullptr, std::move(from)) {}
  inline FeedbackRequest_Feedback& operator=(const FeedbackRequest_Feedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedbackRequest_Feedback& operator=(FeedbackRequest_Feedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedbackRequest_Feedback& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedbackRequest_Feedback* internal_default_instance() {
    return reinterpret_cast<const FeedbackRequest_Feedback*>(
        &_FeedbackRequest_Feedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(FeedbackRequest_Feedback& a, FeedbackRequest_Feedback& b) { a.Swap(&b); }
  inline void Swap(FeedbackRequest_Feedback* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedbackRequest_Feedback* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedbackRequest_Feedback* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<FeedbackRequest_Feedback>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FeedbackRequest_Feedback& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FeedbackRequest_Feedback& from) { FeedbackRequest_Feedback::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FeedbackRequest_Feedback* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "service.FeedbackRequest.Feedback"; }

 protected:
  explicit FeedbackRequest_Feedback(::google::protobuf::Arena* arena);
  FeedbackRequest_Feedback(::google::protobuf::Arena* arena, const FeedbackRequest_Feedback& from);
  FeedbackRequest_Feedback(::google::protobuf::Arena* arena, FeedbackRequest_Feedback&& from) noexcept
      : FeedbackRequest_Feedback(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTagsFieldNumber = 3,
    kFeedbackTextFieldNumber = 2,
    kThumbsUpFieldNumber = 1,
    kIsTestCaseFieldNumber = 4,
  };
  // repeated string tags = 3;
  int tags_size() const;
  private:
  int _internal_tags_size() const;

  public:
  void clear_tags() ;
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, std::size_t size);
  void set_tags(int index, absl::string_view value);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, std::size_t size);
  void add_tags(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& tags() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_tags();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_tags() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_tags();

  public:
  // string feedback_text = 2;
  void clear_feedback_text() ;
  const std::string& feedback_text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_feedback_text(Arg_&& arg, Args_... args);
  std::string* mutable_feedback_text();
  PROTOBUF_NODISCARD std::string* release_feedback_text();
  void set_allocated_feedback_text(std::string* value);

  private:
  const std::string& _internal_feedback_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feedback_text(
      const std::string& value);
  std::string* _internal_mutable_feedback_text();

  public:
  // bool thumbs_up = 1;
  void clear_thumbs_up() ;
  bool thumbs_up() const;
  void set_thumbs_up(bool value);

  private:
  bool _internal_thumbs_up() const;
  void _internal_set_thumbs_up(bool value);

  public:
  // bool is_test_case = 4;
  void clear_is_test_case() ;
  bool is_test_case() const;
  void set_is_test_case(bool value);

  private:
  bool _internal_is_test_case() const;
  void _internal_set_is_test_case(bool value);

  public:
  // @@protoc_insertion_point(class_scope:service.FeedbackRequest.Feedback)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      58, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> tags_;
    ::google::protobuf::internal::ArenaStringPtr feedback_text_;
    bool thumbs_up_;
    bool is_test_case_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class EmotionResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:service.EmotionResponse) */ {
 public:
  inline EmotionResponse() : EmotionResponse(nullptr) {}
  ~EmotionResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EmotionResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline EmotionResponse(const EmotionResponse& from) : EmotionResponse(nullptr, from) {}
  inline EmotionResponse(EmotionResponse&& from) noexcept
      : EmotionResponse(nullptr, std::move(from)) {}
  inline EmotionResponse& operator=(const EmotionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmotionResponse& operator=(EmotionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmotionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmotionResponse* internal_default_instance() {
    return reinterpret_cast<const EmotionResponse*>(
        &_EmotionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(EmotionResponse& a, EmotionResponse& b) { a.Swap(&b); }
  inline void Swap(EmotionResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmotionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmotionResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<EmotionResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EmotionResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EmotionResponse& from) { EmotionResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EmotionResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "service.EmotionResponse"; }

 protected:
  explicit EmotionResponse(::google::protobuf::Arena* arena);
  EmotionResponse(::google::protobuf::Arena* arena, const EmotionResponse& from);
  EmotionResponse(::google::protobuf::Arena* arena, EmotionResponse&& from) noexcept
      : EmotionResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEmotionFieldNumber = 1,
    kScaleFieldNumber = 2,
  };
  // string emotion = 1;
  void clear_emotion() ;
  const std::string& emotion() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_emotion(Arg_&& arg, Args_... args);
  std::string* mutable_emotion();
  PROTOBUF_NODISCARD std::string* release_emotion();
  void set_allocated_emotion(std::string* value);

  private:
  const std::string& _internal_emotion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_emotion(
      const std::string& value);
  std::string* _internal_mutable_emotion();

  public:
  // string scale = 2;
  void clear_scale() ;
  const std::string& scale() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_scale(Arg_&& arg, Args_... args);
  std::string* mutable_scale();
  PROTOBUF_NODISCARD std::string* release_scale();
  void set_allocated_scale(std::string* value);

  private:
  const std::string& _internal_scale() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_scale(
      const std::string& value);
  std::string* _internal_mutable_scale();

  public:
  // @@protoc_insertion_point(class_scope:service.EmotionResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      44, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr emotion_;
    ::google::protobuf::internal::ArenaStringPtr scale_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class DynamicInfoConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:service.DynamicInfoConfig) */ {
 public:
  inline DynamicInfoConfig() : DynamicInfoConfig(nullptr) {}
  ~DynamicInfoConfig() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DynamicInfoConfig(
      ::google::protobuf::internal::ConstantInitialized);

  inline DynamicInfoConfig(const DynamicInfoConfig& from) : DynamicInfoConfig(nullptr, from) {}
  inline DynamicInfoConfig(DynamicInfoConfig&& from) noexcept
      : DynamicInfoConfig(nullptr, std::move(from)) {}
  inline DynamicInfoConfig& operator=(const DynamicInfoConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline DynamicInfoConfig& operator=(DynamicInfoConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DynamicInfoConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const DynamicInfoConfig* internal_default_instance() {
    return reinterpret_cast<const DynamicInfoConfig*>(
        &_DynamicInfoConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(DynamicInfoConfig& a, DynamicInfoConfig& b) { a.Swap(&b); }
  inline void Swap(DynamicInfoConfig* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DynamicInfoConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DynamicInfoConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<DynamicInfoConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DynamicInfoConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DynamicInfoConfig& from) { DynamicInfoConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DynamicInfoConfig* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "service.DynamicInfoConfig"; }

 protected:
  explicit DynamicInfoConfig(::google::protobuf::Arena* arena);
  DynamicInfoConfig(::google::protobuf::Arena* arena, const DynamicInfoConfig& from);
  DynamicInfoConfig(::google::protobuf::Arena* arena, DynamicInfoConfig&& from) noexcept
      : DynamicInfoConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTextFieldNumber = 1,
  };
  // string text = 1;
  void clear_text() ;
  const std::string& text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* value);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // @@protoc_insertion_point(class_scope:service.DynamicInfoConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      38, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr text_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class BlendShapesData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:service.BlendShapesData) */ {
 public:
  inline BlendShapesData() : BlendShapesData(nullptr) {}
  ~BlendShapesData() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlendShapesData(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlendShapesData(const BlendShapesData& from) : BlendShapesData(nullptr, from) {}
  inline BlendShapesData(BlendShapesData&& from) noexcept
      : BlendShapesData(nullptr, std::move(from)) {}
  inline BlendShapesData& operator=(const BlendShapesData& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlendShapesData& operator=(BlendShapesData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlendShapesData& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlendShapesData* internal_default_instance() {
    return reinterpret_cast<const BlendShapesData*>(
        &_BlendShapesData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(BlendShapesData& a, BlendShapesData& b) { a.Swap(&b); }
  inline void Swap(BlendShapesData* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlendShapesData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlendShapesData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BlendShapesData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlendShapesData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlendShapesData& from) { BlendShapesData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BlendShapesData* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "service.BlendShapesData"; }

 protected:
  explicit BlendShapesData(::google::protobuf::Arena* arena);
  BlendShapesData(::google::protobuf::Arena* arena, const BlendShapesData& from);
  BlendShapesData(::google::protobuf::Arena* arena, BlendShapesData&& from) noexcept
      : BlendShapesData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBlendshapeDataFieldNumber = 1,
  };
  // string blendshape_data = 1;
  void clear_blendshape_data() ;
  const std::string& blendshape_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_blendshape_data(Arg_&& arg, Args_... args);
  std::string* mutable_blendshape_data();
  PROTOBUF_NODISCARD std::string* release_blendshape_data();
  void set_allocated_blendshape_data(std::string* value);

  private:
  const std::string& _internal_blendshape_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blendshape_data(
      const std::string& value);
  std::string* _internal_mutable_blendshape_data();

  public:
  // @@protoc_insertion_point(class_scope:service.BlendShapesData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      47, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr blendshape_data_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class AudioConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:service.AudioConfig) */ {
 public:
  inline AudioConfig() : AudioConfig(nullptr) {}
  ~AudioConfig() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AudioConfig(
      ::google::protobuf::internal::ConstantInitialized);

  inline AudioConfig(const AudioConfig& from) : AudioConfig(nullptr, from) {}
  inline AudioConfig(AudioConfig&& from) noexcept
      : AudioConfig(nullptr, std::move(from)) {}
  inline AudioConfig& operator=(const AudioConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioConfig& operator=(AudioConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioConfig* internal_default_instance() {
    return reinterpret_cast<const AudioConfig*>(
        &_AudioConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(AudioConfig& a, AudioConfig& b) { a.Swap(&b); }
  inline void Swap(AudioConfig* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AudioConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AudioConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AudioConfig& from) { AudioConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AudioConfig* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "service.AudioConfig"; }

 protected:
  explicit AudioConfig(::google::protobuf::Arena* arena);
  AudioConfig(::google::protobuf::Arena* arena, const AudioConfig& from);
  AudioConfig(::google::protobuf::Arena* arena, AudioConfig&& from) noexcept
      : AudioConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSampleRateHertzFieldNumber = 1,
    kDisableAudioFieldNumber = 2,
    kEnableFacialDataFieldNumber = 3,
    kEnableFacialEmotionDataFieldNumber = 5,
    kFaceModelFieldNumber = 4,
  };
  // int32 sample_rate_hertz = 1;
  void clear_sample_rate_hertz() ;
  ::int32_t sample_rate_hertz() const;
  void set_sample_rate_hertz(::int32_t value);

  private:
  ::int32_t _internal_sample_rate_hertz() const;
  void _internal_set_sample_rate_hertz(::int32_t value);

  public:
  // bool disable_audio = 2;
  void clear_disable_audio() ;
  bool disable_audio() const;
  void set_disable_audio(bool value);

  private:
  bool _internal_disable_audio() const;
  void _internal_set_disable_audio(bool value);

  public:
  // bool enable_facial_data = 3;
  void clear_enable_facial_data() ;
  bool enable_facial_data() const;
  void set_enable_facial_data(bool value);

  private:
  bool _internal_enable_facial_data() const;
  void _internal_set_enable_facial_data(bool value);

  public:
  // bool enable_facial_emotion_data = 5;
  void clear_enable_facial_emotion_data() ;
  bool enable_facial_emotion_data() const;
  void set_enable_facial_emotion_data(bool value);

  private:
  bool _internal_enable_facial_emotion_data() const;
  void _internal_set_enable_facial_emotion_data(bool value);

  public:
  // .service.FaceModel face_model = 4;
  void clear_face_model() ;
  ::service::FaceModel face_model() const;
  void set_face_model(::service::FaceModel value);

  private:
  ::service::FaceModel _internal_face_model() const;
  void _internal_set_face_model(::service::FaceModel value);

  public:
  // @@protoc_insertion_point(class_scope:service.AudioConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t sample_rate_hertz_;
    bool disable_audio_;
    bool enable_facial_data_;
    bool enable_facial_emotion_data_;
    int face_model_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class ActionConfig_Object final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:service.ActionConfig.Object) */ {
 public:
  inline ActionConfig_Object() : ActionConfig_Object(nullptr) {}
  ~ActionConfig_Object() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ActionConfig_Object(
      ::google::protobuf::internal::ConstantInitialized);

  inline ActionConfig_Object(const ActionConfig_Object& from) : ActionConfig_Object(nullptr, from) {}
  inline ActionConfig_Object(ActionConfig_Object&& from) noexcept
      : ActionConfig_Object(nullptr, std::move(from)) {}
  inline ActionConfig_Object& operator=(const ActionConfig_Object& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionConfig_Object& operator=(ActionConfig_Object&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionConfig_Object& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionConfig_Object* internal_default_instance() {
    return reinterpret_cast<const ActionConfig_Object*>(
        &_ActionConfig_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(ActionConfig_Object& a, ActionConfig_Object& b) { a.Swap(&b); }
  inline void Swap(ActionConfig_Object* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionConfig_Object* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionConfig_Object* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ActionConfig_Object>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ActionConfig_Object& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ActionConfig_Object& from) { ActionConfig_Object::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ActionConfig_Object* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "service.ActionConfig.Object"; }

 protected:
  explicit ActionConfig_Object(::google::protobuf::Arena* arena);
  ActionConfig_Object(::google::protobuf::Arena* arena, const ActionConfig_Object& from);
  ActionConfig_Object(::google::protobuf::Arena* arena, ActionConfig_Object&& from) noexcept
      : ActionConfig_Object(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string description = 2;
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // @@protoc_insertion_point(class_scope:service.ActionConfig.Object)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      51, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class ActionConfig_Character final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:service.ActionConfig.Character) */ {
 public:
  inline ActionConfig_Character() : ActionConfig_Character(nullptr) {}
  ~ActionConfig_Character() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ActionConfig_Character(
      ::google::protobuf::internal::ConstantInitialized);

  inline ActionConfig_Character(const ActionConfig_Character& from) : ActionConfig_Character(nullptr, from) {}
  inline ActionConfig_Character(ActionConfig_Character&& from) noexcept
      : ActionConfig_Character(nullptr, std::move(from)) {}
  inline ActionConfig_Character& operator=(const ActionConfig_Character& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionConfig_Character& operator=(ActionConfig_Character&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionConfig_Character& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionConfig_Character* internal_default_instance() {
    return reinterpret_cast<const ActionConfig_Character*>(
        &_ActionConfig_Character_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(ActionConfig_Character& a, ActionConfig_Character& b) { a.Swap(&b); }
  inline void Swap(ActionConfig_Character* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionConfig_Character* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionConfig_Character* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ActionConfig_Character>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ActionConfig_Character& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ActionConfig_Character& from) { ActionConfig_Character::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ActionConfig_Character* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "service.ActionConfig.Character"; }

 protected:
  explicit ActionConfig_Character(::google::protobuf::Arena* arena);
  ActionConfig_Character(::google::protobuf::Arena* arena, const ActionConfig_Character& from);
  ActionConfig_Character(::google::protobuf::Arena* arena, ActionConfig_Character&& from) noexcept
      : ActionConfig_Character(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kBioFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string bio = 2;
  void clear_bio() ;
  const std::string& bio() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bio(Arg_&& arg, Args_... args);
  std::string* mutable_bio();
  PROTOBUF_NODISCARD std::string* release_bio();
  void set_allocated_bio(std::string* value);

  private:
  const std::string& _internal_bio() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bio(
      const std::string& value);
  std::string* _internal_mutable_bio();

  public:
  // @@protoc_insertion_point(class_scope:service.ActionConfig.Character)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      46, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr bio_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class VisionInput final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:service.VisionInput) */ {
 public:
  inline VisionInput() : VisionInput(nullptr) {}
  ~VisionInput() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VisionInput(
      ::google::protobuf::internal::ConstantInitialized);

  inline VisionInput(const VisionInput& from) : VisionInput(nullptr, from) {}
  inline VisionInput(VisionInput&& from) noexcept
      : VisionInput(nullptr, std::move(from)) {}
  inline VisionInput& operator=(const VisionInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisionInput& operator=(VisionInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisionInput& default_instance() {
    return *internal_default_instance();
  }
  enum VisionDataCase {
    kImageData = 1,
    kVideoData = 2,
    VISION_DATA_NOT_SET = 0,
  };
  static inline const VisionInput* internal_default_instance() {
    return reinterpret_cast<const VisionInput*>(
        &_VisionInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(VisionInput& a, VisionInput& b) { a.Swap(&b); }
  inline void Swap(VisionInput* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisionInput* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisionInput* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<VisionInput>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VisionInput& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VisionInput& from) { VisionInput::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VisionInput* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "service.VisionInput"; }

 protected:
  explicit VisionInput(::google::protobuf::Arena* arena);
  VisionInput(::google::protobuf::Arena* arena, const VisionInput& from);
  VisionInput(::google::protobuf::Arena* arena, VisionInput&& from) noexcept
      : VisionInput(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using ImageData = VisionInput_ImageData;
  using VideoData = VisionInput_VideoData;

  // accessors -------------------------------------------------------
  enum : int {
    kImageDataFieldNumber = 1,
    kVideoDataFieldNumber = 2,
  };
  // .service.VisionInput.ImageData image_data = 1;
  bool has_image_data() const;
  private:
  bool _internal_has_image_data() const;

  public:
  void clear_image_data() ;
  const ::service::VisionInput_ImageData& image_data() const;
  PROTOBUF_NODISCARD ::service::VisionInput_ImageData* release_image_data();
  ::service::VisionInput_ImageData* mutable_image_data();
  void set_allocated_image_data(::service::VisionInput_ImageData* value);
  void unsafe_arena_set_allocated_image_data(::service::VisionInput_ImageData* value);
  ::service::VisionInput_ImageData* unsafe_arena_release_image_data();

  private:
  const ::service::VisionInput_ImageData& _internal_image_data() const;
  ::service::VisionInput_ImageData* _internal_mutable_image_data();

  public:
  // .service.VisionInput.VideoData video_data = 2;
  bool has_video_data() const;
  private:
  bool _internal_has_video_data() const;

  public:
  void clear_video_data() ;
  const ::service::VisionInput_VideoData& video_data() const;
  PROTOBUF_NODISCARD ::service::VisionInput_VideoData* release_video_data();
  ::service::VisionInput_VideoData* mutable_video_data();
  void set_allocated_video_data(::service::VisionInput_VideoData* value);
  void unsafe_arena_set_allocated_video_data(::service::VisionInput_VideoData* value);
  ::service::VisionInput_VideoData* unsafe_arena_release_video_data();

  private:
  const ::service::VisionInput_VideoData& _internal_video_data() const;
  ::service::VisionInput_VideoData* _internal_mutable_video_data();

  public:
  void clear_vision_data();
  VisionDataCase vision_data_case() const;
  // @@protoc_insertion_point(class_scope:service.VisionInput)
 private:
  class _Internal;
  void set_has_image_data();
  void set_has_video_data();
  inline bool has_vision_data() const;
  inline void clear_has_vision_data();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    union VisionDataUnion {
      constexpr VisionDataUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::service::VisionInput_ImageData* image_data_;
      ::service::VisionInput_VideoData* video_data_;
    } vision_data_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class VisemesData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:service.VisemesData) */ {
 public:
  inline VisemesData() : VisemesData(nullptr) {}
  ~VisemesData() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VisemesData(
      ::google::protobuf::internal::ConstantInitialized);

  inline VisemesData(const VisemesData& from) : VisemesData(nullptr, from) {}
  inline VisemesData(VisemesData&& from) noexcept
      : VisemesData(nullptr, std::move(from)) {}
  inline VisemesData& operator=(const VisemesData& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisemesData& operator=(VisemesData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisemesData& default_instance() {
    return *internal_default_instance();
  }
  static inline const VisemesData* internal_default_instance() {
    return reinterpret_cast<const VisemesData*>(
        &_VisemesData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(VisemesData& a, VisemesData& b) { a.Swap(&b); }
  inline void Swap(VisemesData* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisemesData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisemesData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<VisemesData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VisemesData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VisemesData& from) { VisemesData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VisemesData* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "service.VisemesData"; }

 protected:
  explicit VisemesData(::google::protobuf::Arena* arena);
  VisemesData(::google::protobuf::Arena* arena, const VisemesData& from);
  VisemesData(::google::protobuf::Arena* arena, VisemesData&& from) noexcept
      : VisemesData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVisemesFieldNumber = 1,
  };
  // .service.Viseme visemes = 1;
  bool has_visemes() const;
  void clear_visemes() ;
  const ::service::Viseme& visemes() const;
  PROTOBUF_NODISCARD ::service::Viseme* release_visemes();
  ::service::Viseme* mutable_visemes();
  void set_allocated_visemes(::service::Viseme* value);
  void unsafe_arena_set_allocated_visemes(::service::Viseme* value);
  ::service::Viseme* unsafe_arena_release_visemes();

  private:
  const ::service::Viseme& _internal_visemes() const;
  ::service::Viseme* _internal_mutable_visemes();

  public:
  // @@protoc_insertion_point(class_scope:service.VisemesData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::service::Viseme* visemes_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class STTRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:service.STTRequest) */ {
 public:
  inline STTRequest() : STTRequest(nullptr) {}
  ~STTRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR STTRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline STTRequest(const STTRequest& from) : STTRequest(nullptr, from) {}
  inline STTRequest(STTRequest&& from) noexcept
      : STTRequest(nullptr, std::move(from)) {}
  inline STTRequest& operator=(const STTRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline STTRequest& operator=(STTRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const STTRequest& default_instance() {
    return *internal_default_instance();
  }
  enum RequestTypeCase {
    kAudioConfig = 1,
    kAudioChunk = 2,
    REQUEST_TYPE_NOT_SET = 0,
  };
  static inline const STTRequest* internal_default_instance() {
    return reinterpret_cast<const STTRequest*>(
        &_STTRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(STTRequest& a, STTRequest& b) { a.Swap(&b); }
  inline void Swap(STTRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(STTRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  STTRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<STTRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const STTRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const STTRequest& from) { STTRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(STTRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "service.STTRequest"; }

 protected:
  explicit STTRequest(::google::protobuf::Arena* arena);
  STTRequest(::google::protobuf::Arena* arena, const STTRequest& from);
  STTRequest(::google::protobuf::Arena* arena, STTRequest&& from) noexcept
      : STTRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAudioConfigFieldNumber = 1,
    kAudioChunkFieldNumber = 2,
  };
  // .service.AudioConfig audio_config = 1;
  bool has_audio_config() const;
  private:
  bool _internal_has_audio_config() const;

  public:
  void clear_audio_config() ;
  const ::service::AudioConfig& audio_config() const;
  PROTOBUF_NODISCARD ::service::AudioConfig* release_audio_config();
  ::service::AudioConfig* mutable_audio_config();
  void set_allocated_audio_config(::service::AudioConfig* value);
  void unsafe_arena_set_allocated_audio_config(::service::AudioConfig* value);
  ::service::AudioConfig* unsafe_arena_release_audio_config();

  private:
  const ::service::AudioConfig& _internal_audio_config() const;
  ::service::AudioConfig* _internal_mutable_audio_config();

  public:
  // bytes audio_chunk = 2;
  bool has_audio_chunk() const;
  void clear_audio_chunk() ;
  const std::string& audio_chunk() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_audio_chunk(Arg_&& arg, Args_... args);
  std::string* mutable_audio_chunk();
  PROTOBUF_NODISCARD std::string* release_audio_chunk();
  void set_allocated_audio_chunk(std::string* value);

  private:
  const std::string& _internal_audio_chunk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_chunk(
      const std::string& value);
  std::string* _internal_mutable_audio_chunk();

  public:
  void clear_request_type();
  RequestTypeCase request_type_case() const;
  // @@protoc_insertion_point(class_scope:service.STTRequest)
 private:
  class _Internal;
  void set_has_audio_config();
  void set_has_audio_chunk();
  inline bool has_request_type() const;
  inline void clear_has_request_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    union RequestTypeUnion {
      constexpr RequestTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::service::AudioConfig* audio_config_;
      ::google::protobuf::internal::ArenaStringPtr audio_chunk_;
    } request_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseRequest_GetResponseData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:service.GetResponseRequest.GetResponseData) */ {
 public:
  inline GetResponseRequest_GetResponseData() : GetResponseRequest_GetResponseData(nullptr) {}
  ~GetResponseRequest_GetResponseData() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetResponseRequest_GetResponseData(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetResponseRequest_GetResponseData(const GetResponseRequest_GetResponseData& from) : GetResponseRequest_GetResponseData(nullptr, from) {}
  inline GetResponseRequest_GetResponseData(GetResponseRequest_GetResponseData&& from) noexcept
      : GetResponseRequest_GetResponseData(nullptr, std::move(from)) {}
  inline GetResponseRequest_GetResponseData& operator=(const GetResponseRequest_GetResponseData& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseRequest_GetResponseData& operator=(GetResponseRequest_GetResponseData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponseRequest_GetResponseData& default_instance() {
    return *internal_default_instance();
  }
  enum InputTypeCase {
    kAudioData = 1,
    kTextData = 2,
    kTriggerData = 3,
    INPUT_TYPE_NOT_SET = 0,
  };
  static inline const GetResponseRequest_GetResponseData* internal_default_instance() {
    return reinterpret_cast<const GetResponseRequest_GetResponseData*>(
        &_GetResponseRequest_GetResponseData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(GetResponseRequest_GetResponseData& a, GetResponseRequest_GetResponseData& b) { a.Swap(&b); }
  inline void Swap(GetResponseRequest_GetResponseData* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseRequest_GetResponseData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponseRequest_GetResponseData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetResponseRequest_GetResponseData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetResponseRequest_GetResponseData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetResponseRequest_GetResponseData& from) { GetResponseRequest_GetResponseData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetResponseRequest_GetResponseData* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "service.GetResponseRequest.GetResponseData"; }

 protected:
  explicit GetResponseRequest_GetResponseData(::google::protobuf::Arena* arena);
  GetResponseRequest_GetResponseData(::google::protobuf::Arena* arena, const GetResponseRequest_GetResponseData& from);
  GetResponseRequest_GetResponseData(::google::protobuf::Arena* arena, GetResponseRequest_GetResponseData&& from) noexcept
      : GetResponseRequest_GetResponseData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAudioDataFieldNumber = 1,
    kTextDataFieldNumber = 2,
    kTriggerDataFieldNumber = 3,
  };
  // bytes audio_data = 1;
  bool has_audio_data() const;
  void clear_audio_data() ;
  const std::string& audio_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_audio_data(Arg_&& arg, Args_... args);
  std::string* mutable_audio_data();
  PROTOBUF_NODISCARD std::string* release_audio_data();
  void set_allocated_audio_data(std::string* value);

  private:
  const std::string& _internal_audio_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_data(
      const std::string& value);
  std::string* _internal_mutable_audio_data();

  public:
  // string text_data = 2;
  bool has_text_data() const;
  void clear_text_data() ;
  const std::string& text_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text_data(Arg_&& arg, Args_... args);
  std::string* mutable_text_data();
  PROTOBUF_NODISCARD std::string* release_text_data();
  void set_allocated_text_data(std::string* value);

  private:
  const std::string& _internal_text_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text_data(
      const std::string& value);
  std::string* _internal_mutable_text_data();

  public:
  // .service.TriggerConfig trigger_data = 3;
  bool has_trigger_data() const;
  private:
  bool _internal_has_trigger_data() const;

  public:
  void clear_trigger_data() ;
  const ::service::TriggerConfig& trigger_data() const;
  PROTOBUF_NODISCARD ::service::TriggerConfig* release_trigger_data();
  ::service::TriggerConfig* mutable_trigger_data();
  void set_allocated_trigger_data(::service::TriggerConfig* value);
  void unsafe_arena_set_allocated_trigger_data(::service::TriggerConfig* value);
  ::service::TriggerConfig* unsafe_arena_release_trigger_data();

  private:
  const ::service::TriggerConfig& _internal_trigger_data() const;
  ::service::TriggerConfig* _internal_mutable_trigger_data();

  public:
  void clear_input_type();
  InputTypeCase input_type_case() const;
  // @@protoc_insertion_point(class_scope:service.GetResponseRequest.GetResponseData)
 private:
  class _Internal;
  void set_has_audio_data();
  void set_has_text_data();
  void set_has_trigger_data();
  inline bool has_input_type() const;
  inline void clear_has_input_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 1,
      60, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    union InputTypeUnion {
      constexpr InputTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr audio_data_;
      ::google::protobuf::internal::ArenaStringPtr text_data_;
      ::service::TriggerConfig* trigger_data_;
    } input_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class FeedbackRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:service.FeedbackRequest) */ {
 public:
  inline FeedbackRequest() : FeedbackRequest(nullptr) {}
  ~FeedbackRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FeedbackRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline FeedbackRequest(const FeedbackRequest& from) : FeedbackRequest(nullptr, from) {}
  inline FeedbackRequest(FeedbackRequest&& from) noexcept
      : FeedbackRequest(nullptr, std::move(from)) {}
  inline FeedbackRequest& operator=(const FeedbackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedbackRequest& operator=(FeedbackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedbackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedbackRequest* internal_default_instance() {
    return reinterpret_cast<const FeedbackRequest*>(
        &_FeedbackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(FeedbackRequest& a, FeedbackRequest& b) { a.Swap(&b); }
  inline void Swap(FeedbackRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedbackRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedbackRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<FeedbackRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FeedbackRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FeedbackRequest& from) { FeedbackRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FeedbackRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "service.FeedbackRequest"; }

 protected:
  explicit FeedbackRequest(::google::protobuf::Arena* arena);
  FeedbackRequest(::google::protobuf::Arena* arena, const FeedbackRequest& from);
  FeedbackRequest(::google::protobuf::Arena* arena, FeedbackRequest&& from) noexcept
      : FeedbackRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using Feedback = FeedbackRequest_Feedback;

  // accessors -------------------------------------------------------
  enum : int {
    kInteractionIdFieldNumber = 1,
    kCharacterIdFieldNumber = 2,
    kSessionIdFieldNumber = 3,
    kUserQueryFieldNumber = 6,
    kResponseFieldNumber = 7,
    kTextFeedbackFieldNumber = 5,
  };
  // string interaction_id = 1;
  void clear_interaction_id() ;
  const std::string& interaction_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_interaction_id(Arg_&& arg, Args_... args);
  std::string* mutable_interaction_id();
  PROTOBUF_NODISCARD std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* value);

  private:
  const std::string& _internal_interaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interaction_id(
      const std::string& value);
  std::string* _internal_mutable_interaction_id();

  public:
  // string character_id = 2;
  void clear_character_id() ;
  const std::string& character_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_character_id(Arg_&& arg, Args_... args);
  std::string* mutable_character_id();
  PROTOBUF_NODISCARD std::string* release_character_id();
  void set_allocated_character_id(std::string* value);

  private:
  const std::string& _internal_character_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_character_id(
      const std::string& value);
  std::string* _internal_mutable_character_id();

  public:
  // string session_id = 3;
  void clear_session_id() ;
  const std::string& session_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_id(Arg_&& arg, Args_... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* value);

  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(
      const std::string& value);
  std::string* _internal_mutable_session_id();

  public:
  // string user_query = 6;
  void clear_user_query() ;
  const std::string& user_query() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_query(Arg_&& arg, Args_... args);
  std::string* mutable_user_query();
  PROTOBUF_NODISCARD std::string* release_user_query();
  void set_allocated_user_query(std::string* value);

  private:
  const std::string& _internal_user_query() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_query(
      const std::string& value);
  std::string* _internal_mutable_user_query();

  public:
  // string response = 7;
  void clear_response() ;
  const std::string& response() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_response(Arg_&& arg, Args_... args);
  std::string* mutable_response();
  PROTOBUF_NODISCARD std::string* release_response();
  void set_allocated_response(std::string* value);

  private:
  const std::string& _internal_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response(
      const std::string& value);
  std::string* _internal_mutable_response();

  public:
  // .service.FeedbackRequest.Feedback text_feedback = 5;
  bool has_text_feedback() const;
  void clear_text_feedback() ;
  const ::service::FeedbackRequest_Feedback& text_feedback() const;
  PROTOBUF_NODISCARD ::service::FeedbackRequest_Feedback* release_text_feedback();
  ::service::FeedbackRequest_Feedback* mutable_text_feedback();
  void set_allocated_text_feedback(::service::FeedbackRequest_Feedback* value);
  void unsafe_arena_set_allocated_text_feedback(::service::FeedbackRequest_Feedback* value);
  ::service::FeedbackRequest_Feedback* unsafe_arena_release_text_feedback();

  private:
  const ::service::FeedbackRequest_Feedback& _internal_text_feedback() const;
  ::service::FeedbackRequest_Feedback* _internal_mutable_text_feedback();

  public:
  // @@protoc_insertion_point(class_scope:service.FeedbackRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      86, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr interaction_id_;
    ::google::protobuf::internal::ArenaStringPtr character_id_;
    ::google::protobuf::internal::ArenaStringPtr session_id_;
    ::google::protobuf::internal::ArenaStringPtr user_query_;
    ::google::protobuf::internal::ArenaStringPtr response_;
    ::service::FeedbackRequest_Feedback* text_feedback_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class ActionConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:service.ActionConfig) */ {
 public:
  inline ActionConfig() : ActionConfig(nullptr) {}
  ~ActionConfig() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ActionConfig(
      ::google::protobuf::internal::ConstantInitialized);

  inline ActionConfig(const ActionConfig& from) : ActionConfig(nullptr, from) {}
  inline ActionConfig(ActionConfig&& from) noexcept
      : ActionConfig(nullptr, std::move(from)) {}
  inline ActionConfig& operator=(const ActionConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionConfig& operator=(ActionConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionConfig* internal_default_instance() {
    return reinterpret_cast<const ActionConfig*>(
        &_ActionConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(ActionConfig& a, ActionConfig& b) { a.Swap(&b); }
  inline void Swap(ActionConfig* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ActionConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ActionConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ActionConfig& from) { ActionConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ActionConfig* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "service.ActionConfig"; }

 protected:
  explicit ActionConfig(::google::protobuf::Arena* arena);
  ActionConfig(::google::protobuf::Arena* arena, const ActionConfig& from);
  ActionConfig(::google::protobuf::Arena* arena, ActionConfig&& from) noexcept
      : ActionConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using Character = ActionConfig_Character;
  using Object = ActionConfig_Object;

  // accessors -------------------------------------------------------
  enum : int {
    kActionsFieldNumber = 1,
    kCharactersFieldNumber = 2,
    kObjectsFieldNumber = 3,
    kClassificationFieldNumber = 4,
    kCurrentAttentionObjectFieldNumber = 6,
    kContextLevelFieldNumber = 5,
  };
  // repeated string actions = 1;
  int actions_size() const;
  private:
  int _internal_actions_size() const;

  public:
  void clear_actions() ;
  const std::string& actions(int index) const;
  std::string* mutable_actions(int index);
  void set_actions(int index, const std::string& value);
  void set_actions(int index, std::string&& value);
  void set_actions(int index, const char* value);
  void set_actions(int index, const char* value, std::size_t size);
  void set_actions(int index, absl::string_view value);
  std::string* add_actions();
  void add_actions(const std::string& value);
  void add_actions(std::string&& value);
  void add_actions(const char* value);
  void add_actions(const char* value, std::size_t size);
  void add_actions(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& actions() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_actions();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_actions() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_actions();

  public:
  // repeated .service.ActionConfig.Character characters = 2;
  int characters_size() const;
  private:
  int _internal_characters_size() const;

  public:
  void clear_characters() ;
  ::service::ActionConfig_Character* mutable_characters(int index);
  ::google::protobuf::RepeatedPtrField<::service::ActionConfig_Character>* mutable_characters();

  private:
  const ::google::protobuf::RepeatedPtrField<::service::ActionConfig_Character>& _internal_characters() const;
  ::google::protobuf::RepeatedPtrField<::service::ActionConfig_Character>* _internal_mutable_characters();
  public:
  const ::service::ActionConfig_Character& characters(int index) const;
  ::service::ActionConfig_Character* add_characters();
  const ::google::protobuf::RepeatedPtrField<::service::ActionConfig_Character>& characters() const;
  // repeated .service.ActionConfig.Object objects = 3;
  int objects_size() const;
  private:
  int _internal_objects_size() const;

  public:
  void clear_objects() ;
  ::service::ActionConfig_Object* mutable_objects(int index);
  ::google::protobuf::RepeatedPtrField<::service::ActionConfig_Object>* mutable_objects();

  private:
  const ::google::protobuf::RepeatedPtrField<::service::ActionConfig_Object>& _internal_objects() const;
  ::google::protobuf::RepeatedPtrField<::service::ActionConfig_Object>* _internal_mutable_objects();
  public:
  const ::service::ActionConfig_Object& objects(int index) const;
  ::service::ActionConfig_Object* add_objects();
  const ::google::protobuf::RepeatedPtrField<::service::ActionConfig_Object>& objects() const;
  // string classification = 4;
  void clear_classification() ;
  const std::string& classification() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_classification(Arg_&& arg, Args_... args);
  std::string* mutable_classification();
  PROTOBUF_NODISCARD std::string* release_classification();
  void set_allocated_classification(std::string* value);

  private:
  const std::string& _internal_classification() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_classification(
      const std::string& value);
  std::string* _internal_mutable_classification();

  public:
  // string current_attention_object = 6;
  void clear_current_attention_object() ;
  const std::string& current_attention_object() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_current_attention_object(Arg_&& arg, Args_... args);
  std::string* mutable_current_attention_object();
  PROTOBUF_NODISCARD std::string* release_current_attention_object();
  void set_allocated_current_attention_object(std::string* value);

  private:
  const std::string& _internal_current_attention_object() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_attention_object(
      const std::string& value);
  std::string* _internal_mutable_current_attention_object();

  public:
  // int32 context_level = 5;
  void clear_context_level() ;
  ::int32_t context_level() const;
  void set_context_level(::int32_t value);

  private:
  ::int32_t _internal_context_level() const;
  void _internal_set_context_level(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:service.ActionConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 2,
      74, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> actions_;
    ::google::protobuf::RepeatedPtrField< ::service::ActionConfig_Character > characters_;
    ::google::protobuf::RepeatedPtrField< ::service::ActionConfig_Object > objects_;
    ::google::protobuf::internal::ArenaStringPtr classification_;
    ::google::protobuf::internal::ArenaStringPtr current_attention_object_;
    ::int32_t context_level_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseResponse_AudioResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:service.GetResponseResponse.AudioResponse) */ {
 public:
  inline GetResponseResponse_AudioResponse() : GetResponseResponse_AudioResponse(nullptr) {}
  ~GetResponseResponse_AudioResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetResponseResponse_AudioResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetResponseResponse_AudioResponse(const GetResponseResponse_AudioResponse& from) : GetResponseResponse_AudioResponse(nullptr, from) {}
  inline GetResponseResponse_AudioResponse(GetResponseResponse_AudioResponse&& from) noexcept
      : GetResponseResponse_AudioResponse(nullptr, std::move(from)) {}
  inline GetResponseResponse_AudioResponse& operator=(const GetResponseResponse_AudioResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseResponse_AudioResponse& operator=(GetResponseResponse_AudioResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponseResponse_AudioResponse& default_instance() {
    return *internal_default_instance();
  }
  enum FaceDataTypeCase {
    kVisemesData = 6,
    kBlendshapesData = 7,
    FACE_DATA_TYPE_NOT_SET = 0,
  };
  static inline const GetResponseResponse_AudioResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponseResponse_AudioResponse*>(
        &_GetResponseResponse_AudioResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(GetResponseResponse_AudioResponse& a, GetResponseResponse_AudioResponse& b) { a.Swap(&b); }
  inline void Swap(GetResponseResponse_AudioResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseResponse_AudioResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponseResponse_AudioResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetResponseResponse_AudioResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetResponseResponse_AudioResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetResponseResponse_AudioResponse& from) { GetResponseResponse_AudioResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetResponseResponse_AudioResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "service.GetResponseResponse.AudioResponse"; }

 protected:
  explicit GetResponseResponse_AudioResponse(::google::protobuf::Arena* arena);
  GetResponseResponse_AudioResponse(::google::protobuf::Arena* arena, const GetResponseResponse_AudioResponse& from);
  GetResponseResponse_AudioResponse(::google::protobuf::Arena* arena, GetResponseResponse_AudioResponse&& from) noexcept
      : GetResponseResponse_AudioResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAudioDataFieldNumber = 1,
    kTextDataFieldNumber = 3,
    kFaceDataFieldNumber = 5,
    kAudioConfigFieldNumber = 2,
    kFaceEmotionFieldNumber = 8,
    kEmotionResponseFieldNumber = 9,
    kEndOfResponseFieldNumber = 4,
    kVisemesDataFieldNumber = 6,
    kBlendshapesDataFieldNumber = 7,
  };
  // bytes audio_data = 1;
  void clear_audio_data() ;
  const std::string& audio_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_audio_data(Arg_&& arg, Args_... args);
  std::string* mutable_audio_data();
  PROTOBUF_NODISCARD std::string* release_audio_data();
  void set_allocated_audio_data(std::string* value);

  private:
  const std::string& _internal_audio_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_data(
      const std::string& value);
  std::string* _internal_mutable_audio_data();

  public:
  // string text_data = 3;
  void clear_text_data() ;
  const std::string& text_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text_data(Arg_&& arg, Args_... args);
  std::string* mutable_text_data();
  PROTOBUF_NODISCARD std::string* release_text_data();
  void set_allocated_text_data(std::string* value);

  private:
  const std::string& _internal_text_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text_data(
      const std::string& value);
  std::string* _internal_mutable_text_data();

  public:
  // string face_data = 5;
  void clear_face_data() ;
  const std::string& face_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_face_data(Arg_&& arg, Args_... args);
  std::string* mutable_face_data();
  PROTOBUF_NODISCARD std::string* release_face_data();
  void set_allocated_face_data(std::string* value);

  private:
  const std::string& _internal_face_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_face_data(
      const std::string& value);
  std::string* _internal_mutable_face_data();

  public:
  // .service.AudioConfig audio_config = 2;
  bool has_audio_config() const;
  void clear_audio_config() ;
  const ::service::AudioConfig& audio_config() const;
  PROTOBUF_NODISCARD ::service::AudioConfig* release_audio_config();
  ::service::AudioConfig* mutable_audio_config();
  void set_allocated_audio_config(::service::AudioConfig* value);
  void unsafe_arena_set_allocated_audio_config(::service::AudioConfig* value);
  ::service::AudioConfig* unsafe_arena_release_audio_config();

  private:
  const ::service::AudioConfig& _internal_audio_config() const;
  ::service::AudioConfig* _internal_mutable_audio_config();

  public:
  // .service.ARKitBlendShapesData face_emotion = 8;
  bool has_face_emotion() const;
  void clear_face_emotion() ;
  const ::service::ARKitBlendShapesData& face_emotion() const;
  PROTOBUF_NODISCARD ::service::ARKitBlendShapesData* release_face_emotion();
  ::service::ARKitBlendShapesData* mutable_face_emotion();
  void set_allocated_face_emotion(::service::ARKitBlendShapesData* value);
  void unsafe_arena_set_allocated_face_emotion(::service::ARKitBlendShapesData* value);
  ::service::ARKitBlendShapesData* unsafe_arena_release_face_emotion();

  private:
  const ::service::ARKitBlendShapesData& _internal_face_emotion() const;
  ::service::ARKitBlendShapesData* _internal_mutable_face_emotion();

  public:
  // .service.EmotionResponse emotion_response = 9;
  bool has_emotion_response() const;
  void clear_emotion_response() ;
  const ::service::EmotionResponse& emotion_response() const;
  PROTOBUF_NODISCARD ::service::EmotionResponse* release_emotion_response();
  ::service::EmotionResponse* mutable_emotion_response();
  void set_allocated_emotion_response(::service::EmotionResponse* value);
  void unsafe_arena_set_allocated_emotion_response(::service::EmotionResponse* value);
  ::service::EmotionResponse* unsafe_arena_release_emotion_response();

  private:
  const ::service::EmotionResponse& _internal_emotion_response() const;
  ::service::EmotionResponse* _internal_mutable_emotion_response();

  public:
  // bool end_of_response = 4;
  void clear_end_of_response() ;
  bool end_of_response() const;
  void set_end_of_response(bool value);

  private:
  bool _internal_end_of_response() const;
  void _internal_set_end_of_response(bool value);

  public:
  // .service.VisemesData visemes_data = 6;
  bool has_visemes_data() const;
  private:
  bool _internal_has_visemes_data() const;

  public:
  void clear_visemes_data() ;
  const ::service::VisemesData& visemes_data() const;
  PROTOBUF_NODISCARD ::service::VisemesData* release_visemes_data();
  ::service::VisemesData* mutable_visemes_data();
  void set_allocated_visemes_data(::service::VisemesData* value);
  void unsafe_arena_set_allocated_visemes_data(::service::VisemesData* value);
  ::service::VisemesData* unsafe_arena_release_visemes_data();

  private:
  const ::service::VisemesData& _internal_visemes_data() const;
  ::service::VisemesData* _internal_mutable_visemes_data();

  public:
  // .service.BlendShapesData blendshapes_data = 7;
  bool has_blendshapes_data() const;
  private:
  bool _internal_has_blendshapes_data() const;

  public:
  void clear_blendshapes_data() ;
  const ::service::BlendShapesData& blendshapes_data() const;
  PROTOBUF_NODISCARD ::service::BlendShapesData* release_blendshapes_data();
  ::service::BlendShapesData* mutable_blendshapes_data();
  void set_allocated_blendshapes_data(::service::BlendShapesData* value);
  void unsafe_arena_set_allocated_blendshapes_data(::service::BlendShapesData* value);
  ::service::BlendShapesData* unsafe_arena_release_blendshapes_data();

  private:
  const ::service::BlendShapesData& _internal_blendshapes_data() const;
  ::service::BlendShapesData* _internal_mutable_blendshapes_data();

  public:
  void clear_face_data_type();
  FaceDataTypeCase face_data_type_case() const;
  // @@protoc_insertion_point(class_scope:service.GetResponseResponse.AudioResponse)
 private:
  class _Internal;
  void set_has_visemes_data();
  void set_has_blendshapes_data();
  inline bool has_face_data_type() const;
  inline void clear_has_face_data_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 5,
      76, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr audio_data_;
    ::google::protobuf::internal::ArenaStringPtr text_data_;
    ::google::protobuf::internal::ArenaStringPtr face_data_;
    ::service::AudioConfig* audio_config_;
    ::service::ARKitBlendShapesData* face_emotion_;
    ::service::EmotionResponse* emotion_response_;
    bool end_of_response_;
    union FaceDataTypeUnion {
      constexpr FaceDataTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::service::VisemesData* visemes_data_;
      ::service::BlendShapesData* blendshapes_data_;
    } face_data_type_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseRequest_GetResponseConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:service.GetResponseRequest.GetResponseConfig) */ {
 public:
  inline GetResponseRequest_GetResponseConfig() : GetResponseRequest_GetResponseConfig(nullptr) {}
  ~GetResponseRequest_GetResponseConfig() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetResponseRequest_GetResponseConfig(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetResponseRequest_GetResponseConfig(const GetResponseRequest_GetResponseConfig& from) : GetResponseRequest_GetResponseConfig(nullptr, from) {}
  inline GetResponseRequest_GetResponseConfig(GetResponseRequest_GetResponseConfig&& from) noexcept
      : GetResponseRequest_GetResponseConfig(nullptr, std::move(from)) {}
  inline GetResponseRequest_GetResponseConfig& operator=(const GetResponseRequest_GetResponseConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseRequest_GetResponseConfig& operator=(GetResponseRequest_GetResponseConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponseRequest_GetResponseConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetResponseRequest_GetResponseConfig* internal_default_instance() {
    return reinterpret_cast<const GetResponseRequest_GetResponseConfig*>(
        &_GetResponseRequest_GetResponseConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(GetResponseRequest_GetResponseConfig& a, GetResponseRequest_GetResponseConfig& b) { a.Swap(&b); }
  inline void Swap(GetResponseRequest_GetResponseConfig* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseRequest_GetResponseConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponseRequest_GetResponseConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetResponseRequest_GetResponseConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetResponseRequest_GetResponseConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetResponseRequest_GetResponseConfig& from) { GetResponseRequest_GetResponseConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetResponseRequest_GetResponseConfig* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "service.GetResponseRequest.GetResponseConfig"; }

 protected:
  explicit GetResponseRequest_GetResponseConfig(::google::protobuf::Arena* arena);
  GetResponseRequest_GetResponseConfig(::google::protobuf::Arena* arena, const GetResponseRequest_GetResponseConfig& from);
  GetResponseRequest_GetResponseConfig(::google::protobuf::Arena* arena, GetResponseRequest_GetResponseConfig&& from) noexcept
      : GetResponseRequest_GetResponseConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNarrativeTemplateKeysFieldNumber = 11,
    kCharacterIdFieldNumber = 2,
    kApiKeyFieldNumber = 3,
    kSessionIdFieldNumber = 4,
    kSpeakerFieldNumber = 7,
    kLanguageCodeFieldNumber = 8,
    kSpeakerIdFieldNumber = 9,
    kApiAuthTokenFieldNumber = 10,
    kAudioConfigFieldNumber = 5,
    kActionConfigFieldNumber = 6,
    kDynamicInfoConfigFieldNumber = 12,
    kVisionInputFieldNumber = 13,
  };
  // map<string, string> narrative_template_keys = 11;
  int narrative_template_keys_size() const;
  private:
  int _internal_narrative_template_keys_size() const;

  public:
  void clear_narrative_template_keys() ;
  const ::google::protobuf::Map<std::string, std::string>& narrative_template_keys() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_narrative_template_keys();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_narrative_template_keys() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_narrative_template_keys();

  public:
  // string character_id = 2;
  void clear_character_id() ;
  const std::string& character_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_character_id(Arg_&& arg, Args_... args);
  std::string* mutable_character_id();
  PROTOBUF_NODISCARD std::string* release_character_id();
  void set_allocated_character_id(std::string* value);

  private:
  const std::string& _internal_character_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_character_id(
      const std::string& value);
  std::string* _internal_mutable_character_id();

  public:
  // string api_key = 3;
  void clear_api_key() ;
  const std::string& api_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_api_key(Arg_&& arg, Args_... args);
  std::string* mutable_api_key();
  PROTOBUF_NODISCARD std::string* release_api_key();
  void set_allocated_api_key(std::string* value);

  private:
  const std::string& _internal_api_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_api_key(
      const std::string& value);
  std::string* _internal_mutable_api_key();

  public:
  // string session_id = 4;
  void clear_session_id() ;
  const std::string& session_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_id(Arg_&& arg, Args_... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* value);

  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(
      const std::string& value);
  std::string* _internal_mutable_session_id();

  public:
  // string speaker = 7;
  void clear_speaker() ;
  const std::string& speaker() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_speaker(Arg_&& arg, Args_... args);
  std::string* mutable_speaker();
  PROTOBUF_NODISCARD std::string* release_speaker();
  void set_allocated_speaker(std::string* value);

  private:
  const std::string& _internal_speaker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_speaker(
      const std::string& value);
  std::string* _internal_mutable_speaker();

  public:
  // string language_code = 8;
  void clear_language_code() ;
  const std::string& language_code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_language_code(Arg_&& arg, Args_... args);
  std::string* mutable_language_code();
  PROTOBUF_NODISCARD std::string* release_language_code();
  void set_allocated_language_code(std::string* value);

  private:
  const std::string& _internal_language_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language_code(
      const std::string& value);
  std::string* _internal_mutable_language_code();

  public:
  // string speaker_id = 9;
  void clear_speaker_id() ;
  const std::string& speaker_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_speaker_id(Arg_&& arg, Args_... args);
  std::string* mutable_speaker_id();
  PROTOBUF_NODISCARD std::string* release_speaker_id();
  void set_allocated_speaker_id(std::string* value);

  private:
  const std::string& _internal_speaker_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_speaker_id(
      const std::string& value);
  std::string* _internal_mutable_speaker_id();

  public:
  // string api_auth_token = 10;
  void clear_api_auth_token() ;
  const std::string& api_auth_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_api_auth_token(Arg_&& arg, Args_... args);
  std::string* mutable_api_auth_token();
  PROTOBUF_NODISCARD std::string* release_api_auth_token();
  void set_allocated_api_auth_token(std::string* value);

  private:
  const std::string& _internal_api_auth_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_api_auth_token(
      const std::string& value);
  std::string* _internal_mutable_api_auth_token();

  public:
  // .service.AudioConfig audio_config = 5;
  bool has_audio_config() const;
  void clear_audio_config() ;
  const ::service::AudioConfig& audio_config() const;
  PROTOBUF_NODISCARD ::service::AudioConfig* release_audio_config();
  ::service::AudioConfig* mutable_audio_config();
  void set_allocated_audio_config(::service::AudioConfig* value);
  void unsafe_arena_set_allocated_audio_config(::service::AudioConfig* value);
  ::service::AudioConfig* unsafe_arena_release_audio_config();

  private:
  const ::service::AudioConfig& _internal_audio_config() const;
  ::service::AudioConfig* _internal_mutable_audio_config();

  public:
  // .service.ActionConfig action_config = 6;
  bool has_action_config() const;
  void clear_action_config() ;
  const ::service::ActionConfig& action_config() const;
  PROTOBUF_NODISCARD ::service::ActionConfig* release_action_config();
  ::service::ActionConfig* mutable_action_config();
  void set_allocated_action_config(::service::ActionConfig* value);
  void unsafe_arena_set_allocated_action_config(::service::ActionConfig* value);
  ::service::ActionConfig* unsafe_arena_release_action_config();

  private:
  const ::service::ActionConfig& _internal_action_config() const;
  ::service::ActionConfig* _internal_mutable_action_config();

  public:
  // .service.DynamicInfoConfig dynamic_info_config = 12;
  bool has_dynamic_info_config() const;
  void clear_dynamic_info_config() ;
  const ::service::DynamicInfoConfig& dynamic_info_config() const;
  PROTOBUF_NODISCARD ::service::DynamicInfoConfig* release_dynamic_info_config();
  ::service::DynamicInfoConfig* mutable_dynamic_info_config();
  void set_allocated_dynamic_info_config(::service::DynamicInfoConfig* value);
  void unsafe_arena_set_allocated_dynamic_info_config(::service::DynamicInfoConfig* value);
  ::service::DynamicInfoConfig* unsafe_arena_release_dynamic_info_config();

  private:
  const ::service::DynamicInfoConfig& _internal_dynamic_info_config() const;
  ::service::DynamicInfoConfig* _internal_mutable_dynamic_info_config();

  public:
  // .service.VisionInput vision_input = 13;
  bool has_vision_input() const;
  void clear_vision_input() ;
  const ::service::VisionInput& vision_input() const;
  PROTOBUF_NODISCARD ::service::VisionInput* release_vision_input();
  ::service::VisionInput* mutable_vision_input();
  void set_allocated_vision_input(::service::VisionInput* value);
  void unsafe_arena_set_allocated_vision_input(::service::VisionInput* value);
  ::service::VisionInput* unsafe_arena_release_vision_input();

  private:
  const ::service::VisionInput& _internal_vision_input() const;
  ::service::VisionInput* _internal_mutable_vision_input();

  public:
  // @@protoc_insertion_point(class_scope:service.GetResponseRequest.GetResponseConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 5,
      157, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        narrative_template_keys_;
    ::google::protobuf::internal::ArenaStringPtr character_id_;
    ::google::protobuf::internal::ArenaStringPtr api_key_;
    ::google::protobuf::internal::ArenaStringPtr session_id_;
    ::google::protobuf::internal::ArenaStringPtr speaker_;
    ::google::protobuf::internal::ArenaStringPtr language_code_;
    ::google::protobuf::internal::ArenaStringPtr speaker_id_;
    ::google::protobuf::internal::ArenaStringPtr api_auth_token_;
    ::service::AudioConfig* audio_config_;
    ::service::ActionConfig* action_config_;
    ::service::DynamicInfoConfig* dynamic_info_config_;
    ::service::VisionInput* vision_input_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:service.GetResponseResponse) */ {
 public:
  inline GetResponseResponse() : GetResponseResponse(nullptr) {}
  ~GetResponseResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetResponseResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetResponseResponse(const GetResponseResponse& from) : GetResponseResponse(nullptr, from) {}
  inline GetResponseResponse(GetResponseResponse&& from) noexcept
      : GetResponseResponse(nullptr, std::move(from)) {}
  inline GetResponseResponse& operator=(const GetResponseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseResponse& operator=(GetResponseResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponseResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseTypeCase {
    kActionResponse = 2,
    kAudioResponse = 3,
    kDebugLog = 4,
    kUserQuery = 5,
    kBtResponse = 6,
    kEmotionResponse = 7,
    kInteractionId = 8,
    RESPONSE_TYPE_NOT_SET = 0,
  };
  static inline const GetResponseResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponseResponse*>(
        &_GetResponseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(GetResponseResponse& a, GetResponseResponse& b) { a.Swap(&b); }
  inline void Swap(GetResponseResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponseResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetResponseResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetResponseResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetResponseResponse& from) { GetResponseResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetResponseResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "service.GetResponseResponse"; }

 protected:
  explicit GetResponseResponse(::google::protobuf::Arena* arena);
  GetResponseResponse(::google::protobuf::Arena* arena, const GetResponseResponse& from);
  GetResponseResponse(::google::protobuf::Arena* arena, GetResponseResponse&& from) noexcept
      : GetResponseResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using AudioResponse = GetResponseResponse_AudioResponse;
  using ActionResponse = GetResponseResponse_ActionResponse;
  using BehaviorTreeResponse = GetResponseResponse_BehaviorTreeResponse;
  using UserTranscript = GetResponseResponse_UserTranscript;

  // accessors -------------------------------------------------------
  enum : int {
    kSessionIdFieldNumber = 1,
    kActionResponseFieldNumber = 2,
    kAudioResponseFieldNumber = 3,
    kDebugLogFieldNumber = 4,
    kUserQueryFieldNumber = 5,
    kBtResponseFieldNumber = 6,
    kEmotionResponseFieldNumber = 7,
    kInteractionIdFieldNumber = 8,
  };
  // string session_id = 1;
  void clear_session_id() ;
  const std::string& session_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_id(Arg_&& arg, Args_... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* value);

  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(
      const std::string& value);
  std::string* _internal_mutable_session_id();

  public:
  // .service.GetResponseResponse.ActionResponse action_response = 2;
  bool has_action_response() const;
  private:
  bool _internal_has_action_response() const;

  public:
  void clear_action_response() ;
  const ::service::GetResponseResponse_ActionResponse& action_response() const;
  PROTOBUF_NODISCARD ::service::GetResponseResponse_ActionResponse* release_action_response();
  ::service::GetResponseResponse_ActionResponse* mutable_action_response();
  void set_allocated_action_response(::service::GetResponseResponse_ActionResponse* value);
  void unsafe_arena_set_allocated_action_response(::service::GetResponseResponse_ActionResponse* value);
  ::service::GetResponseResponse_ActionResponse* unsafe_arena_release_action_response();

  private:
  const ::service::GetResponseResponse_ActionResponse& _internal_action_response() const;
  ::service::GetResponseResponse_ActionResponse* _internal_mutable_action_response();

  public:
  // .service.GetResponseResponse.AudioResponse audio_response = 3;
  bool has_audio_response() const;
  private:
  bool _internal_has_audio_response() const;

  public:
  void clear_audio_response() ;
  const ::service::GetResponseResponse_AudioResponse& audio_response() const;
  PROTOBUF_NODISCARD ::service::GetResponseResponse_AudioResponse* release_audio_response();
  ::service::GetResponseResponse_AudioResponse* mutable_audio_response();
  void set_allocated_audio_response(::service::GetResponseResponse_AudioResponse* value);
  void unsafe_arena_set_allocated_audio_response(::service::GetResponseResponse_AudioResponse* value);
  ::service::GetResponseResponse_AudioResponse* unsafe_arena_release_audio_response();

  private:
  const ::service::GetResponseResponse_AudioResponse& _internal_audio_response() const;
  ::service::GetResponseResponse_AudioResponse* _internal_mutable_audio_response();

  public:
  // string debug_log = 4;
  bool has_debug_log() const;
  void clear_debug_log() ;
  const std::string& debug_log() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_debug_log(Arg_&& arg, Args_... args);
  std::string* mutable_debug_log();
  PROTOBUF_NODISCARD std::string* release_debug_log();
  void set_allocated_debug_log(std::string* value);

  private:
  const std::string& _internal_debug_log() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_debug_log(
      const std::string& value);
  std::string* _internal_mutable_debug_log();

  public:
  // .service.GetResponseResponse.UserTranscript user_query = 5;
  bool has_user_query() const;
  private:
  bool _internal_has_user_query() const;

  public:
  void clear_user_query() ;
  const ::service::GetResponseResponse_UserTranscript& user_query() const;
  PROTOBUF_NODISCARD ::service::GetResponseResponse_UserTranscript* release_user_query();
  ::service::GetResponseResponse_UserTranscript* mutable_user_query();
  void set_allocated_user_query(::service::GetResponseResponse_UserTranscript* value);
  void unsafe_arena_set_allocated_user_query(::service::GetResponseResponse_UserTranscript* value);
  ::service::GetResponseResponse_UserTranscript* unsafe_arena_release_user_query();

  private:
  const ::service::GetResponseResponse_UserTranscript& _internal_user_query() const;
  ::service::GetResponseResponse_UserTranscript* _internal_mutable_user_query();

  public:
  // .service.GetResponseResponse.BehaviorTreeResponse bt_response = 6;
  bool has_bt_response() const;
  private:
  bool _internal_has_bt_response() const;

  public:
  void clear_bt_response() ;
  const ::service::GetResponseResponse_BehaviorTreeResponse& bt_response() const;
  PROTOBUF_NODISCARD ::service::GetResponseResponse_BehaviorTreeResponse* release_bt_response();
  ::service::GetResponseResponse_BehaviorTreeResponse* mutable_bt_response();
  void set_allocated_bt_response(::service::GetResponseResponse_BehaviorTreeResponse* value);
  void unsafe_arena_set_allocated_bt_response(::service::GetResponseResponse_BehaviorTreeResponse* value);
  ::service::GetResponseResponse_BehaviorTreeResponse* unsafe_arena_release_bt_response();

  private:
  const ::service::GetResponseResponse_BehaviorTreeResponse& _internal_bt_response() const;
  ::service::GetResponseResponse_BehaviorTreeResponse* _internal_mutable_bt_response();

  public:
  // string emotion_response = 7;
  bool has_emotion_response() const;
  void clear_emotion_response() ;
  const std::string& emotion_response() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_emotion_response(Arg_&& arg, Args_... args);
  std::string* mutable_emotion_response();
  PROTOBUF_NODISCARD std::string* release_emotion_response();
  void set_allocated_emotion_response(std::string* value);

  private:
  const std::string& _internal_emotion_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_emotion_response(
      const std::string& value);
  std::string* _internal_mutable_emotion_response();

  public:
  // string interaction_id = 8;
  bool has_interaction_id() const;
  void clear_interaction_id() ;
  const std::string& interaction_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_interaction_id(Arg_&& arg, Args_... args);
  std::string* mutable_interaction_id();
  PROTOBUF_NODISCARD std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* value);

  private:
  const std::string& _internal_interaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interaction_id(
      const std::string& value);
  std::string* _internal_mutable_interaction_id();

  public:
  void clear_response_type();
  ResponseTypeCase response_type_case() const;
  // @@protoc_insertion_point(class_scope:service.GetResponseResponse)
 private:
  class _Internal;
  void set_has_action_response();
  void set_has_audio_response();
  void set_has_debug_log();
  void set_has_user_query();
  void set_has_bt_response();
  void set_has_emotion_response();
  void set_has_interaction_id();
  inline bool has_response_type() const;
  inline void clear_has_response_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 8, 4,
      93, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr session_id_;
    union ResponseTypeUnion {
      constexpr ResponseTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::service::GetResponseResponse_ActionResponse* action_response_;
      ::service::GetResponseResponse_AudioResponse* audio_response_;
      ::google::protobuf::internal::ArenaStringPtr debug_log_;
      ::service::GetResponseResponse_UserTranscript* user_query_;
      ::service::GetResponseResponse_BehaviorTreeResponse* bt_response_;
      ::google::protobuf::internal::ArenaStringPtr emotion_response_;
      ::google::protobuf::internal::ArenaStringPtr interaction_id_;
    } response_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:service.GetResponseRequest) */ {
 public:
  inline GetResponseRequest() : GetResponseRequest(nullptr) {}
  ~GetResponseRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetResponseRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetResponseRequest(const GetResponseRequest& from) : GetResponseRequest(nullptr, from) {}
  inline GetResponseRequest(GetResponseRequest&& from) noexcept
      : GetResponseRequest(nullptr, std::move(from)) {}
  inline GetResponseRequest& operator=(const GetResponseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseRequest& operator=(GetResponseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponseRequest& default_instance() {
    return *internal_default_instance();
  }
  enum RequestTypeCase {
    kGetResponseConfig = 1,
    kGetResponseData = 2,
    REQUEST_TYPE_NOT_SET = 0,
  };
  static inline const GetResponseRequest* internal_default_instance() {
    return reinterpret_cast<const GetResponseRequest*>(
        &_GetResponseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(GetResponseRequest& a, GetResponseRequest& b) { a.Swap(&b); }
  inline void Swap(GetResponseRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponseRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetResponseRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetResponseRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetResponseRequest& from) { GetResponseRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetResponseRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "service.GetResponseRequest"; }

 protected:
  explicit GetResponseRequest(::google::protobuf::Arena* arena);
  GetResponseRequest(::google::protobuf::Arena* arena, const GetResponseRequest& from);
  GetResponseRequest(::google::protobuf::Arena* arena, GetResponseRequest&& from) noexcept
      : GetResponseRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using GetResponseConfig = GetResponseRequest_GetResponseConfig;
  using GetResponseData = GetResponseRequest_GetResponseData;

  // accessors -------------------------------------------------------
  enum : int {
    kGetResponseConfigFieldNumber = 1,
    kGetResponseDataFieldNumber = 2,
  };
  // .service.GetResponseRequest.GetResponseConfig get_response_config = 1;
  bool has_get_response_config() const;
  private:
  bool _internal_has_get_response_config() const;

  public:
  void clear_get_response_config() ;
  const ::service::GetResponseRequest_GetResponseConfig& get_response_config() const;
  PROTOBUF_NODISCARD ::service::GetResponseRequest_GetResponseConfig* release_get_response_config();
  ::service::GetResponseRequest_GetResponseConfig* mutable_get_response_config();
  void set_allocated_get_response_config(::service::GetResponseRequest_GetResponseConfig* value);
  void unsafe_arena_set_allocated_get_response_config(::service::GetResponseRequest_GetResponseConfig* value);
  ::service::GetResponseRequest_GetResponseConfig* unsafe_arena_release_get_response_config();

  private:
  const ::service::GetResponseRequest_GetResponseConfig& _internal_get_response_config() const;
  ::service::GetResponseRequest_GetResponseConfig* _internal_mutable_get_response_config();

  public:
  // .service.GetResponseRequest.GetResponseData get_response_data = 2;
  bool has_get_response_data() const;
  private:
  bool _internal_has_get_response_data() const;

  public:
  void clear_get_response_data() ;
  const ::service::GetResponseRequest_GetResponseData& get_response_data() const;
  PROTOBUF_NODISCARD ::service::GetResponseRequest_GetResponseData* release_get_response_data();
  ::service::GetResponseRequest_GetResponseData* mutable_get_response_data();
  void set_allocated_get_response_data(::service::GetResponseRequest_GetResponseData* value);
  void unsafe_arena_set_allocated_get_response_data(::service::GetResponseRequest_GetResponseData* value);
  ::service::GetResponseRequest_GetResponseData* unsafe_arena_release_get_response_data();

  private:
  const ::service::GetResponseRequest_GetResponseData& _internal_get_response_data() const;
  ::service::GetResponseRequest_GetResponseData* _internal_mutable_get_response_data();

  public:
  void clear_request_type();
  RequestTypeCase request_type_case() const;
  // @@protoc_insertion_point(class_scope:service.GetResponseRequest)
 private:
  class _Internal;
  void set_has_get_response_config();
  void set_has_get_response_data();
  inline bool has_request_type() const;
  inline void clear_has_request_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    union RequestTypeUnion {
      constexpr RequestTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::service::GetResponseRequest_GetResponseConfig* get_response_config_;
      ::service::GetResponseRequest_GetResponseData* get_response_data_;
    } request_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseRequestSingle final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:service.GetResponseRequestSingle) */ {
 public:
  inline GetResponseRequestSingle() : GetResponseRequestSingle(nullptr) {}
  ~GetResponseRequestSingle() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetResponseRequestSingle(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetResponseRequestSingle(const GetResponseRequestSingle& from) : GetResponseRequestSingle(nullptr, from) {}
  inline GetResponseRequestSingle(GetResponseRequestSingle&& from) noexcept
      : GetResponseRequestSingle(nullptr, std::move(from)) {}
  inline GetResponseRequestSingle& operator=(const GetResponseRequestSingle& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseRequestSingle& operator=(GetResponseRequestSingle&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponseRequestSingle& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetResponseRequestSingle* internal_default_instance() {
    return reinterpret_cast<const GetResponseRequestSingle*>(
        &_GetResponseRequestSingle_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(GetResponseRequestSingle& a, GetResponseRequestSingle& b) { a.Swap(&b); }
  inline void Swap(GetResponseRequestSingle* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseRequestSingle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponseRequestSingle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetResponseRequestSingle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetResponseRequestSingle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetResponseRequestSingle& from) { GetResponseRequestSingle::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetResponseRequestSingle* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "service.GetResponseRequestSingle"; }

 protected:
  explicit GetResponseRequestSingle(::google::protobuf::Arena* arena);
  GetResponseRequestSingle(::google::protobuf::Arena* arena, const GetResponseRequestSingle& from);
  GetResponseRequestSingle(::google::protobuf::Arena* arena, GetResponseRequestSingle&& from) noexcept
      : GetResponseRequestSingle(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResponseConfigFieldNumber = 1,
    kResponseDataFieldNumber = 2,
  };
  // .service.GetResponseRequest response_config = 1;
  bool has_response_config() const;
  void clear_response_config() ;
  const ::service::GetResponseRequest& response_config() const;
  PROTOBUF_NODISCARD ::service::GetResponseRequest* release_response_config();
  ::service::GetResponseRequest* mutable_response_config();
  void set_allocated_response_config(::service::GetResponseRequest* value);
  void unsafe_arena_set_allocated_response_config(::service::GetResponseRequest* value);
  ::service::GetResponseRequest* unsafe_arena_release_response_config();

  private:
  const ::service::GetResponseRequest& _internal_response_config() const;
  ::service::GetResponseRequest* _internal_mutable_response_config();

  public:
  // .service.GetResponseRequest response_data = 2;
  bool has_response_data() const;
  void clear_response_data() ;
  const ::service::GetResponseRequest& response_data() const;
  PROTOBUF_NODISCARD ::service::GetResponseRequest* release_response_data();
  ::service::GetResponseRequest* mutable_response_data();
  void set_allocated_response_data(::service::GetResponseRequest* value);
  void unsafe_arena_set_allocated_response_data(::service::GetResponseRequest* value);
  ::service::GetResponseRequest* unsafe_arena_release_response_data();

  private:
  const ::service::GetResponseRequest& _internal_response_data() const;
  ::service::GetResponseRequest* _internal_mutable_response_data();

  public:
  // @@protoc_insertion_point(class_scope:service.GetResponseRequestSingle)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::service::GetResponseRequest* response_config_;
    ::service::GetResponseRequest* response_data_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// AudioConfig

// int32 sample_rate_hertz = 1;
inline void AudioConfig::clear_sample_rate_hertz() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sample_rate_hertz_ = 0;
}
inline ::int32_t AudioConfig::sample_rate_hertz() const {
  // @@protoc_insertion_point(field_get:service.AudioConfig.sample_rate_hertz)
  return _internal_sample_rate_hertz();
}
inline void AudioConfig::set_sample_rate_hertz(::int32_t value) {
  _internal_set_sample_rate_hertz(value);
  // @@protoc_insertion_point(field_set:service.AudioConfig.sample_rate_hertz)
}
inline ::int32_t AudioConfig::_internal_sample_rate_hertz() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sample_rate_hertz_;
}
inline void AudioConfig::_internal_set_sample_rate_hertz(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sample_rate_hertz_ = value;
}

// bool disable_audio = 2;
inline void AudioConfig::clear_disable_audio() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.disable_audio_ = false;
}
inline bool AudioConfig::disable_audio() const {
  // @@protoc_insertion_point(field_get:service.AudioConfig.disable_audio)
  return _internal_disable_audio();
}
inline void AudioConfig::set_disable_audio(bool value) {
  _internal_set_disable_audio(value);
  // @@protoc_insertion_point(field_set:service.AudioConfig.disable_audio)
}
inline bool AudioConfig::_internal_disable_audio() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.disable_audio_;
}
inline void AudioConfig::_internal_set_disable_audio(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.disable_audio_ = value;
}

// bool enable_facial_data = 3;
inline void AudioConfig::clear_enable_facial_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enable_facial_data_ = false;
}
inline bool AudioConfig::enable_facial_data() const {
  // @@protoc_insertion_point(field_get:service.AudioConfig.enable_facial_data)
  return _internal_enable_facial_data();
}
inline void AudioConfig::set_enable_facial_data(bool value) {
  _internal_set_enable_facial_data(value);
  // @@protoc_insertion_point(field_set:service.AudioConfig.enable_facial_data)
}
inline bool AudioConfig::_internal_enable_facial_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enable_facial_data_;
}
inline void AudioConfig::_internal_set_enable_facial_data(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enable_facial_data_ = value;
}

// .service.FaceModel face_model = 4;
inline void AudioConfig::clear_face_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.face_model_ = 0;
}
inline ::service::FaceModel AudioConfig::face_model() const {
  // @@protoc_insertion_point(field_get:service.AudioConfig.face_model)
  return _internal_face_model();
}
inline void AudioConfig::set_face_model(::service::FaceModel value) {
  _internal_set_face_model(value);
  // @@protoc_insertion_point(field_set:service.AudioConfig.face_model)
}
inline ::service::FaceModel AudioConfig::_internal_face_model() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::service::FaceModel>(_impl_.face_model_);
}
inline void AudioConfig::_internal_set_face_model(::service::FaceModel value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.face_model_ = value;
}

// bool enable_facial_emotion_data = 5;
inline void AudioConfig::clear_enable_facial_emotion_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enable_facial_emotion_data_ = false;
}
inline bool AudioConfig::enable_facial_emotion_data() const {
  // @@protoc_insertion_point(field_get:service.AudioConfig.enable_facial_emotion_data)
  return _internal_enable_facial_emotion_data();
}
inline void AudioConfig::set_enable_facial_emotion_data(bool value) {
  _internal_set_enable_facial_emotion_data(value);
  // @@protoc_insertion_point(field_set:service.AudioConfig.enable_facial_emotion_data)
}
inline bool AudioConfig::_internal_enable_facial_emotion_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enable_facial_emotion_data_;
}
inline void AudioConfig::_internal_set_enable_facial_emotion_data(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enable_facial_emotion_data_ = value;
}

// -------------------------------------------------------------------

// TriggerConfig

// string trigger_name = 1;
inline void TriggerConfig::clear_trigger_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.trigger_name_.ClearToEmpty();
}
inline const std::string& TriggerConfig::trigger_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.TriggerConfig.trigger_name)
  return _internal_trigger_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TriggerConfig::set_trigger_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.trigger_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.TriggerConfig.trigger_name)
}
inline std::string* TriggerConfig::mutable_trigger_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_trigger_name();
  // @@protoc_insertion_point(field_mutable:service.TriggerConfig.trigger_name)
  return _s;
}
inline const std::string& TriggerConfig::_internal_trigger_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.trigger_name_.Get();
}
inline void TriggerConfig::_internal_set_trigger_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.trigger_name_.Set(value, GetArena());
}
inline std::string* TriggerConfig::_internal_mutable_trigger_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.trigger_name_.Mutable( GetArena());
}
inline std::string* TriggerConfig::release_trigger_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.TriggerConfig.trigger_name)
  return _impl_.trigger_name_.Release();
}
inline void TriggerConfig::set_allocated_trigger_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.trigger_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.trigger_name_.IsDefault()) {
          _impl_.trigger_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.TriggerConfig.trigger_name)
}

// string trigger_message = 2;
inline void TriggerConfig::clear_trigger_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.trigger_message_.ClearToEmpty();
}
inline const std::string& TriggerConfig::trigger_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.TriggerConfig.trigger_message)
  return _internal_trigger_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TriggerConfig::set_trigger_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.trigger_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.TriggerConfig.trigger_message)
}
inline std::string* TriggerConfig::mutable_trigger_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_trigger_message();
  // @@protoc_insertion_point(field_mutable:service.TriggerConfig.trigger_message)
  return _s;
}
inline const std::string& TriggerConfig::_internal_trigger_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.trigger_message_.Get();
}
inline void TriggerConfig::_internal_set_trigger_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.trigger_message_.Set(value, GetArena());
}
inline std::string* TriggerConfig::_internal_mutable_trigger_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.trigger_message_.Mutable( GetArena());
}
inline std::string* TriggerConfig::release_trigger_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.TriggerConfig.trigger_message)
  return _impl_.trigger_message_.Release();
}
inline void TriggerConfig::set_allocated_trigger_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.trigger_message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.trigger_message_.IsDefault()) {
          _impl_.trigger_message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.TriggerConfig.trigger_message)
}

// -------------------------------------------------------------------

// ActionConfig_Character

// string name = 1;
inline void ActionConfig_Character::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ActionConfig_Character::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.ActionConfig.Character.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ActionConfig_Character::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.ActionConfig.Character.name)
}
inline std::string* ActionConfig_Character::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.Character.name)
  return _s;
}
inline const std::string& ActionConfig_Character::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void ActionConfig_Character::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* ActionConfig_Character::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* ActionConfig_Character::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.ActionConfig.Character.name)
  return _impl_.name_.Release();
}
inline void ActionConfig_Character::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.ActionConfig.Character.name)
}

// string bio = 2;
inline void ActionConfig_Character::clear_bio() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bio_.ClearToEmpty();
}
inline const std::string& ActionConfig_Character::bio() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.ActionConfig.Character.bio)
  return _internal_bio();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ActionConfig_Character::set_bio(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bio_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.ActionConfig.Character.bio)
}
inline std::string* ActionConfig_Character::mutable_bio() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_bio();
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.Character.bio)
  return _s;
}
inline const std::string& ActionConfig_Character::_internal_bio() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bio_.Get();
}
inline void ActionConfig_Character::_internal_set_bio(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bio_.Set(value, GetArena());
}
inline std::string* ActionConfig_Character::_internal_mutable_bio() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.bio_.Mutable( GetArena());
}
inline std::string* ActionConfig_Character::release_bio() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.ActionConfig.Character.bio)
  return _impl_.bio_.Release();
}
inline void ActionConfig_Character::set_allocated_bio(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bio_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.bio_.IsDefault()) {
          _impl_.bio_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.ActionConfig.Character.bio)
}

// -------------------------------------------------------------------

// ActionConfig_Object

// string name = 1;
inline void ActionConfig_Object::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ActionConfig_Object::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.ActionConfig.Object.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ActionConfig_Object::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.ActionConfig.Object.name)
}
inline std::string* ActionConfig_Object::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.Object.name)
  return _s;
}
inline const std::string& ActionConfig_Object::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void ActionConfig_Object::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* ActionConfig_Object::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* ActionConfig_Object::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.ActionConfig.Object.name)
  return _impl_.name_.Release();
}
inline void ActionConfig_Object::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.ActionConfig.Object.name)
}

// string description = 2;
inline void ActionConfig_Object::clear_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ActionConfig_Object::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.ActionConfig.Object.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ActionConfig_Object::set_description(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.ActionConfig.Object.description)
}
inline std::string* ActionConfig_Object::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.Object.description)
  return _s;
}
inline const std::string& ActionConfig_Object::_internal_description() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.description_.Get();
}
inline void ActionConfig_Object::_internal_set_description(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.Set(value, GetArena());
}
inline std::string* ActionConfig_Object::_internal_mutable_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* ActionConfig_Object::release_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.ActionConfig.Object.description)
  return _impl_.description_.Release();
}
inline void ActionConfig_Object::set_allocated_description(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.ActionConfig.Object.description)
}

// -------------------------------------------------------------------

// ActionConfig

// repeated string actions = 1;
inline int ActionConfig::_internal_actions_size() const {
  return _internal_actions().size();
}
inline int ActionConfig::actions_size() const {
  return _internal_actions_size();
}
inline void ActionConfig::clear_actions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.actions_.Clear();
}
inline std::string* ActionConfig::add_actions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_actions()->Add();
  // @@protoc_insertion_point(field_add_mutable:service.ActionConfig.actions)
  return _s;
}
inline const std::string& ActionConfig::actions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.ActionConfig.actions)
  return _internal_actions().Get(index);
}
inline std::string* ActionConfig::mutable_actions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.actions)
  return _internal_mutable_actions()->Mutable(index);
}
inline void ActionConfig::set_actions(int index, const std::string& value) {
  _internal_mutable_actions()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:service.ActionConfig.actions)
}
inline void ActionConfig::set_actions(int index, std::string&& value) {
  _internal_mutable_actions()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:service.ActionConfig.actions)
}
inline void ActionConfig::set_actions(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_actions()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:service.ActionConfig.actions)
}
inline void ActionConfig::set_actions(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_actions()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:service.ActionConfig.actions)
}
inline void ActionConfig::set_actions(int index, absl::string_view value) {
  _internal_mutable_actions()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:service.ActionConfig.actions)
}
inline void ActionConfig::add_actions(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_actions()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:service.ActionConfig.actions)
}
inline void ActionConfig::add_actions(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_actions()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:service.ActionConfig.actions)
}
inline void ActionConfig::add_actions(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_actions()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:service.ActionConfig.actions)
}
inline void ActionConfig::add_actions(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_actions()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:service.ActionConfig.actions)
}
inline void ActionConfig::add_actions(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_actions()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:service.ActionConfig.actions)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ActionConfig::actions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:service.ActionConfig.actions)
  return _internal_actions();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ActionConfig::mutable_actions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:service.ActionConfig.actions)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_actions();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ActionConfig::_internal_actions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.actions_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ActionConfig::_internal_mutable_actions() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.actions_;
}

// repeated .service.ActionConfig.Character characters = 2;
inline int ActionConfig::_internal_characters_size() const {
  return _internal_characters().size();
}
inline int ActionConfig::characters_size() const {
  return _internal_characters_size();
}
inline void ActionConfig::clear_characters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.characters_.Clear();
}
inline ::service::ActionConfig_Character* ActionConfig::mutable_characters(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.characters)
  return _internal_mutable_characters()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::service::ActionConfig_Character>* ActionConfig::mutable_characters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:service.ActionConfig.characters)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_characters();
}
inline const ::service::ActionConfig_Character& ActionConfig::characters(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.ActionConfig.characters)
  return _internal_characters().Get(index);
}
inline ::service::ActionConfig_Character* ActionConfig::add_characters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::service::ActionConfig_Character* _add = _internal_mutable_characters()->Add();
  // @@protoc_insertion_point(field_add:service.ActionConfig.characters)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::service::ActionConfig_Character>& ActionConfig::characters() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:service.ActionConfig.characters)
  return _internal_characters();
}
inline const ::google::protobuf::RepeatedPtrField<::service::ActionConfig_Character>&
ActionConfig::_internal_characters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.characters_;
}
inline ::google::protobuf::RepeatedPtrField<::service::ActionConfig_Character>*
ActionConfig::_internal_mutable_characters() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.characters_;
}

// repeated .service.ActionConfig.Object objects = 3;
inline int ActionConfig::_internal_objects_size() const {
  return _internal_objects().size();
}
inline int ActionConfig::objects_size() const {
  return _internal_objects_size();
}
inline void ActionConfig::clear_objects() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objects_.Clear();
}
inline ::service::ActionConfig_Object* ActionConfig::mutable_objects(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.objects)
  return _internal_mutable_objects()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::service::ActionConfig_Object>* ActionConfig::mutable_objects()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:service.ActionConfig.objects)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_objects();
}
inline const ::service::ActionConfig_Object& ActionConfig::objects(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.ActionConfig.objects)
  return _internal_objects().Get(index);
}
inline ::service::ActionConfig_Object* ActionConfig::add_objects() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::service::ActionConfig_Object* _add = _internal_mutable_objects()->Add();
  // @@protoc_insertion_point(field_add:service.ActionConfig.objects)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::service::ActionConfig_Object>& ActionConfig::objects() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:service.ActionConfig.objects)
  return _internal_objects();
}
inline const ::google::protobuf::RepeatedPtrField<::service::ActionConfig_Object>&
ActionConfig::_internal_objects() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.objects_;
}
inline ::google::protobuf::RepeatedPtrField<::service::ActionConfig_Object>*
ActionConfig::_internal_mutable_objects() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.objects_;
}

// string classification = 4;
inline void ActionConfig::clear_classification() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.classification_.ClearToEmpty();
}
inline const std::string& ActionConfig::classification() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.ActionConfig.classification)
  return _internal_classification();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ActionConfig::set_classification(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.classification_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.ActionConfig.classification)
}
inline std::string* ActionConfig::mutable_classification() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_classification();
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.classification)
  return _s;
}
inline const std::string& ActionConfig::_internal_classification() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.classification_.Get();
}
inline void ActionConfig::_internal_set_classification(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.classification_.Set(value, GetArena());
}
inline std::string* ActionConfig::_internal_mutable_classification() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.classification_.Mutable( GetArena());
}
inline std::string* ActionConfig::release_classification() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.ActionConfig.classification)
  return _impl_.classification_.Release();
}
inline void ActionConfig::set_allocated_classification(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.classification_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.classification_.IsDefault()) {
          _impl_.classification_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.ActionConfig.classification)
}

// int32 context_level = 5;
inline void ActionConfig::clear_context_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.context_level_ = 0;
}
inline ::int32_t ActionConfig::context_level() const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.context_level)
  return _internal_context_level();
}
inline void ActionConfig::set_context_level(::int32_t value) {
  _internal_set_context_level(value);
  // @@protoc_insertion_point(field_set:service.ActionConfig.context_level)
}
inline ::int32_t ActionConfig::_internal_context_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.context_level_;
}
inline void ActionConfig::_internal_set_context_level(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.context_level_ = value;
}

// string current_attention_object = 6;
inline void ActionConfig::clear_current_attention_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.current_attention_object_.ClearToEmpty();
}
inline const std::string& ActionConfig::current_attention_object() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.ActionConfig.current_attention_object)
  return _internal_current_attention_object();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ActionConfig::set_current_attention_object(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.current_attention_object_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.ActionConfig.current_attention_object)
}
inline std::string* ActionConfig::mutable_current_attention_object() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_current_attention_object();
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.current_attention_object)
  return _s;
}
inline const std::string& ActionConfig::_internal_current_attention_object() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.current_attention_object_.Get();
}
inline void ActionConfig::_internal_set_current_attention_object(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.current_attention_object_.Set(value, GetArena());
}
inline std::string* ActionConfig::_internal_mutable_current_attention_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.current_attention_object_.Mutable( GetArena());
}
inline std::string* ActionConfig::release_current_attention_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.ActionConfig.current_attention_object)
  return _impl_.current_attention_object_.Release();
}
inline void ActionConfig::set_allocated_current_attention_object(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.current_attention_object_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.current_attention_object_.IsDefault()) {
          _impl_.current_attention_object_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.ActionConfig.current_attention_object)
}

// -------------------------------------------------------------------

// STTRequest

// .service.AudioConfig audio_config = 1;
inline bool STTRequest::has_audio_config() const {
  return request_type_case() == kAudioConfig;
}
inline bool STTRequest::_internal_has_audio_config() const {
  return request_type_case() == kAudioConfig;
}
inline void STTRequest::set_has_audio_config() {
  _impl_._oneof_case_[0] = kAudioConfig;
}
inline void STTRequest::clear_audio_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (request_type_case() == kAudioConfig) {
    if (GetArena() == nullptr) {
      delete _impl_.request_type_.audio_config_;
    }
    clear_has_request_type();
  }
}
inline ::service::AudioConfig* STTRequest::release_audio_config() {
  // @@protoc_insertion_point(field_release:service.STTRequest.audio_config)
  if (request_type_case() == kAudioConfig) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.audio_config_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.audio_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::AudioConfig& STTRequest::_internal_audio_config() const {
  return request_type_case() == kAudioConfig ? *_impl_.request_type_.audio_config_ : reinterpret_cast<::service::AudioConfig&>(::service::_AudioConfig_default_instance_);
}
inline const ::service::AudioConfig& STTRequest::audio_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.STTRequest.audio_config)
  return _internal_audio_config();
}
inline ::service::AudioConfig* STTRequest::unsafe_arena_release_audio_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.STTRequest.audio_config)
  if (request_type_case() == kAudioConfig) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.audio_config_;
    _impl_.request_type_.audio_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void STTRequest::unsafe_arena_set_allocated_audio_config(::service::AudioConfig* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_audio_config();
    _impl_.request_type_.audio_config_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.STTRequest.audio_config)
}
inline ::service::AudioConfig* STTRequest::_internal_mutable_audio_config() {
  if (request_type_case() != kAudioConfig) {
    clear_request_type();
    set_has_audio_config();
    _impl_.request_type_.audio_config_ =
        ::google::protobuf::Message::DefaultConstruct<::service::AudioConfig>(GetArena());
  }
  return _impl_.request_type_.audio_config_;
}
inline ::service::AudioConfig* STTRequest::mutable_audio_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::service::AudioConfig* _msg = _internal_mutable_audio_config();
  // @@protoc_insertion_point(field_mutable:service.STTRequest.audio_config)
  return _msg;
}

// bytes audio_chunk = 2;
inline bool STTRequest::has_audio_chunk() const {
  return request_type_case() == kAudioChunk;
}
inline void STTRequest::set_has_audio_chunk() {
  _impl_._oneof_case_[0] = kAudioChunk;
}
inline void STTRequest::clear_audio_chunk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (request_type_case() == kAudioChunk) {
    _impl_.request_type_.audio_chunk_.Destroy();
    clear_has_request_type();
  }
}
inline const std::string& STTRequest::audio_chunk() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.STTRequest.audio_chunk)
  return _internal_audio_chunk();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void STTRequest::set_audio_chunk(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (request_type_case() != kAudioChunk) {
    clear_request_type();

    set_has_audio_chunk();
    _impl_.request_type_.audio_chunk_.InitDefault();
  }
  _impl_.request_type_.audio_chunk_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.STTRequest.audio_chunk)
}
inline std::string* STTRequest::mutable_audio_chunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_audio_chunk();
  // @@protoc_insertion_point(field_mutable:service.STTRequest.audio_chunk)
  return _s;
}
inline const std::string& STTRequest::_internal_audio_chunk() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (request_type_case() != kAudioChunk) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.request_type_.audio_chunk_.Get();
}
inline void STTRequest::_internal_set_audio_chunk(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (request_type_case() != kAudioChunk) {
    clear_request_type();

    set_has_audio_chunk();
    _impl_.request_type_.audio_chunk_.InitDefault();
  }
  _impl_.request_type_.audio_chunk_.Set(value, GetArena());
}
inline std::string* STTRequest::_internal_mutable_audio_chunk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (request_type_case() != kAudioChunk) {
    clear_request_type();

    set_has_audio_chunk();
    _impl_.request_type_.audio_chunk_.InitDefault();
  }
  return _impl_.request_type_.audio_chunk_.Mutable( GetArena());
}
inline std::string* STTRequest::release_audio_chunk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.STTRequest.audio_chunk)
  if (request_type_case() != kAudioChunk) {
    return nullptr;
  }
  clear_has_request_type();
  return _impl_.request_type_.audio_chunk_.Release();
}
inline void STTRequest::set_allocated_audio_chunk(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_request_type()) {
    clear_request_type();
  }
  if (value != nullptr) {
    set_has_audio_chunk();
    _impl_.request_type_.audio_chunk_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:service.STTRequest.audio_chunk)
}

inline bool STTRequest::has_request_type() const {
  return request_type_case() != REQUEST_TYPE_NOT_SET;
}
inline void STTRequest::clear_has_request_type() {
  _impl_._oneof_case_[0] = REQUEST_TYPE_NOT_SET;
}
inline STTRequest::RequestTypeCase STTRequest::request_type_case() const {
  return STTRequest::RequestTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// STTResponse

// string text = 1;
inline void STTResponse::clear_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.ClearToEmpty();
}
inline const std::string& STTResponse::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.STTResponse.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void STTResponse::set_text(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.STTResponse.text)
}
inline std::string* STTResponse::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:service.STTResponse.text)
  return _s;
}
inline const std::string& STTResponse::_internal_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_.Get();
}
inline void STTResponse::_internal_set_text(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.Set(value, GetArena());
}
inline std::string* STTResponse::_internal_mutable_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.text_.Mutable( GetArena());
}
inline std::string* STTResponse::release_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.STTResponse.text)
  return _impl_.text_.Release();
}
inline void STTResponse::set_allocated_text(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_.IsDefault()) {
          _impl_.text_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.STTResponse.text)
}

// -------------------------------------------------------------------

// DynamicInfoConfig

// string text = 1;
inline void DynamicInfoConfig::clear_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.ClearToEmpty();
}
inline const std::string& DynamicInfoConfig::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.DynamicInfoConfig.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DynamicInfoConfig::set_text(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.DynamicInfoConfig.text)
}
inline std::string* DynamicInfoConfig::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:service.DynamicInfoConfig.text)
  return _s;
}
inline const std::string& DynamicInfoConfig::_internal_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_.Get();
}
inline void DynamicInfoConfig::_internal_set_text(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.Set(value, GetArena());
}
inline std::string* DynamicInfoConfig::_internal_mutable_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.text_.Mutable( GetArena());
}
inline std::string* DynamicInfoConfig::release_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.DynamicInfoConfig.text)
  return _impl_.text_.Release();
}
inline void DynamicInfoConfig::set_allocated_text(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_.IsDefault()) {
          _impl_.text_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.DynamicInfoConfig.text)
}

// -------------------------------------------------------------------

// VisionInput_ImageData

// int32 width = 1;
inline void VisionInput_ImageData::clear_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.width_ = 0;
}
inline ::int32_t VisionInput_ImageData::width() const {
  // @@protoc_insertion_point(field_get:service.VisionInput.ImageData.width)
  return _internal_width();
}
inline void VisionInput_ImageData::set_width(::int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:service.VisionInput.ImageData.width)
}
inline ::int32_t VisionInput_ImageData::_internal_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.width_;
}
inline void VisionInput_ImageData::_internal_set_width(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.width_ = value;
}

// int32 height = 2;
inline void VisionInput_ImageData::clear_height() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.height_ = 0;
}
inline ::int32_t VisionInput_ImageData::height() const {
  // @@protoc_insertion_point(field_get:service.VisionInput.ImageData.height)
  return _internal_height();
}
inline void VisionInput_ImageData::set_height(::int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:service.VisionInput.ImageData.height)
}
inline ::int32_t VisionInput_ImageData::_internal_height() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.height_;
}
inline void VisionInput_ImageData::_internal_set_height(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.height_ = value;
}

// bytes data = 3;
inline void VisionInput_ImageData::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.ClearToEmpty();
}
inline const std::string& VisionInput_ImageData::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.VisionInput.ImageData.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VisionInput_ImageData::set_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.VisionInput.ImageData.data)
}
inline std::string* VisionInput_ImageData::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:service.VisionInput.ImageData.data)
  return _s;
}
inline const std::string& VisionInput_ImageData::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_.Get();
}
inline void VisionInput_ImageData::_internal_set_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.Set(value, GetArena());
}
inline std::string* VisionInput_ImageData::_internal_mutable_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* VisionInput_ImageData::release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.VisionInput.ImageData.data)
  return _impl_.data_.Release();
}
inline void VisionInput_ImageData::set_allocated_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.VisionInput.ImageData.data)
}

// -------------------------------------------------------------------

// VisionInput_VideoData

// int32 fps = 1;
inline void VisionInput_VideoData::clear_fps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fps_ = 0;
}
inline ::int32_t VisionInput_VideoData::fps() const {
  // @@protoc_insertion_point(field_get:service.VisionInput.VideoData.fps)
  return _internal_fps();
}
inline void VisionInput_VideoData::set_fps(::int32_t value) {
  _internal_set_fps(value);
  // @@protoc_insertion_point(field_set:service.VisionInput.VideoData.fps)
}
inline ::int32_t VisionInput_VideoData::_internal_fps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fps_;
}
inline void VisionInput_VideoData::_internal_set_fps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fps_ = value;
}

// int32 width = 2;
inline void VisionInput_VideoData::clear_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.width_ = 0;
}
inline ::int32_t VisionInput_VideoData::width() const {
  // @@protoc_insertion_point(field_get:service.VisionInput.VideoData.width)
  return _internal_width();
}
inline void VisionInput_VideoData::set_width(::int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:service.VisionInput.VideoData.width)
}
inline ::int32_t VisionInput_VideoData::_internal_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.width_;
}
inline void VisionInput_VideoData::_internal_set_width(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.width_ = value;
}

// int32 height = 3;
inline void VisionInput_VideoData::clear_height() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.height_ = 0;
}
inline ::int32_t VisionInput_VideoData::height() const {
  // @@protoc_insertion_point(field_get:service.VisionInput.VideoData.height)
  return _internal_height();
}
inline void VisionInput_VideoData::set_height(::int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:service.VisionInput.VideoData.height)
}
inline ::int32_t VisionInput_VideoData::_internal_height() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.height_;
}
inline void VisionInput_VideoData::_internal_set_height(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.height_ = value;
}

// bytes data = 4;
inline void VisionInput_VideoData::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.ClearToEmpty();
}
inline const std::string& VisionInput_VideoData::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.VisionInput.VideoData.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VisionInput_VideoData::set_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.VisionInput.VideoData.data)
}
inline std::string* VisionInput_VideoData::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:service.VisionInput.VideoData.data)
  return _s;
}
inline const std::string& VisionInput_VideoData::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_.Get();
}
inline void VisionInput_VideoData::_internal_set_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.Set(value, GetArena());
}
inline std::string* VisionInput_VideoData::_internal_mutable_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* VisionInput_VideoData::release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.VisionInput.VideoData.data)
  return _impl_.data_.Release();
}
inline void VisionInput_VideoData::set_allocated_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.VisionInput.VideoData.data)
}

// -------------------------------------------------------------------

// VisionInput

// .service.VisionInput.ImageData image_data = 1;
inline bool VisionInput::has_image_data() const {
  return vision_data_case() == kImageData;
}
inline bool VisionInput::_internal_has_image_data() const {
  return vision_data_case() == kImageData;
}
inline void VisionInput::set_has_image_data() {
  _impl_._oneof_case_[0] = kImageData;
}
inline void VisionInput::clear_image_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (vision_data_case() == kImageData) {
    if (GetArena() == nullptr) {
      delete _impl_.vision_data_.image_data_;
    }
    clear_has_vision_data();
  }
}
inline ::service::VisionInput_ImageData* VisionInput::release_image_data() {
  // @@protoc_insertion_point(field_release:service.VisionInput.image_data)
  if (vision_data_case() == kImageData) {
    clear_has_vision_data();
    auto* temp = _impl_.vision_data_.image_data_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.vision_data_.image_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::VisionInput_ImageData& VisionInput::_internal_image_data() const {
  return vision_data_case() == kImageData ? *_impl_.vision_data_.image_data_ : reinterpret_cast<::service::VisionInput_ImageData&>(::service::_VisionInput_ImageData_default_instance_);
}
inline const ::service::VisionInput_ImageData& VisionInput::image_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.VisionInput.image_data)
  return _internal_image_data();
}
inline ::service::VisionInput_ImageData* VisionInput::unsafe_arena_release_image_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.VisionInput.image_data)
  if (vision_data_case() == kImageData) {
    clear_has_vision_data();
    auto* temp = _impl_.vision_data_.image_data_;
    _impl_.vision_data_.image_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VisionInput::unsafe_arena_set_allocated_image_data(::service::VisionInput_ImageData* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_vision_data();
  if (value) {
    set_has_image_data();
    _impl_.vision_data_.image_data_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.VisionInput.image_data)
}
inline ::service::VisionInput_ImageData* VisionInput::_internal_mutable_image_data() {
  if (vision_data_case() != kImageData) {
    clear_vision_data();
    set_has_image_data();
    _impl_.vision_data_.image_data_ =
        ::google::protobuf::Message::DefaultConstruct<::service::VisionInput_ImageData>(GetArena());
  }
  return _impl_.vision_data_.image_data_;
}
inline ::service::VisionInput_ImageData* VisionInput::mutable_image_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::service::VisionInput_ImageData* _msg = _internal_mutable_image_data();
  // @@protoc_insertion_point(field_mutable:service.VisionInput.image_data)
  return _msg;
}

// .service.VisionInput.VideoData video_data = 2;
inline bool VisionInput::has_video_data() const {
  return vision_data_case() == kVideoData;
}
inline bool VisionInput::_internal_has_video_data() const {
  return vision_data_case() == kVideoData;
}
inline void VisionInput::set_has_video_data() {
  _impl_._oneof_case_[0] = kVideoData;
}
inline void VisionInput::clear_video_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (vision_data_case() == kVideoData) {
    if (GetArena() == nullptr) {
      delete _impl_.vision_data_.video_data_;
    }
    clear_has_vision_data();
  }
}
inline ::service::VisionInput_VideoData* VisionInput::release_video_data() {
  // @@protoc_insertion_point(field_release:service.VisionInput.video_data)
  if (vision_data_case() == kVideoData) {
    clear_has_vision_data();
    auto* temp = _impl_.vision_data_.video_data_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.vision_data_.video_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::VisionInput_VideoData& VisionInput::_internal_video_data() const {
  return vision_data_case() == kVideoData ? *_impl_.vision_data_.video_data_ : reinterpret_cast<::service::VisionInput_VideoData&>(::service::_VisionInput_VideoData_default_instance_);
}
inline const ::service::VisionInput_VideoData& VisionInput::video_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.VisionInput.video_data)
  return _internal_video_data();
}
inline ::service::VisionInput_VideoData* VisionInput::unsafe_arena_release_video_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.VisionInput.video_data)
  if (vision_data_case() == kVideoData) {
    clear_has_vision_data();
    auto* temp = _impl_.vision_data_.video_data_;
    _impl_.vision_data_.video_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VisionInput::unsafe_arena_set_allocated_video_data(::service::VisionInput_VideoData* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_vision_data();
  if (value) {
    set_has_video_data();
    _impl_.vision_data_.video_data_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.VisionInput.video_data)
}
inline ::service::VisionInput_VideoData* VisionInput::_internal_mutable_video_data() {
  if (vision_data_case() != kVideoData) {
    clear_vision_data();
    set_has_video_data();
    _impl_.vision_data_.video_data_ =
        ::google::protobuf::Message::DefaultConstruct<::service::VisionInput_VideoData>(GetArena());
  }
  return _impl_.vision_data_.video_data_;
}
inline ::service::VisionInput_VideoData* VisionInput::mutable_video_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::service::VisionInput_VideoData* _msg = _internal_mutable_video_data();
  // @@protoc_insertion_point(field_mutable:service.VisionInput.video_data)
  return _msg;
}

inline bool VisionInput::has_vision_data() const {
  return vision_data_case() != VISION_DATA_NOT_SET;
}
inline void VisionInput::clear_has_vision_data() {
  _impl_._oneof_case_[0] = VISION_DATA_NOT_SET;
}
inline VisionInput::VisionDataCase VisionInput::vision_data_case() const {
  return VisionInput::VisionDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetResponseRequest_GetResponseConfig

// string character_id = 2;
inline void GetResponseRequest_GetResponseConfig::clear_character_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.character_id_.ClearToEmpty();
}
inline const std::string& GetResponseRequest_GetResponseConfig::character_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.character_id)
  return _internal_character_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetResponseRequest_GetResponseConfig::set_character_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.character_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseConfig.character_id)
}
inline std::string* GetResponseRequest_GetResponseConfig::mutable_character_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_character_id();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.character_id)
  return _s;
}
inline const std::string& GetResponseRequest_GetResponseConfig::_internal_character_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.character_id_.Get();
}
inline void GetResponseRequest_GetResponseConfig::_internal_set_character_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.character_id_.Set(value, GetArena());
}
inline std::string* GetResponseRequest_GetResponseConfig::_internal_mutable_character_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.character_id_.Mutable( GetArena());
}
inline std::string* GetResponseRequest_GetResponseConfig::release_character_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.character_id)
  return _impl_.character_id_.Release();
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_character_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.character_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.character_id_.IsDefault()) {
          _impl_.character_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.character_id)
}

// string api_key = 3;
inline void GetResponseRequest_GetResponseConfig::clear_api_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.api_key_.ClearToEmpty();
}
inline const std::string& GetResponseRequest_GetResponseConfig::api_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.api_key)
  return _internal_api_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetResponseRequest_GetResponseConfig::set_api_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.api_key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseConfig.api_key)
}
inline std::string* GetResponseRequest_GetResponseConfig::mutable_api_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_api_key();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.api_key)
  return _s;
}
inline const std::string& GetResponseRequest_GetResponseConfig::_internal_api_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.api_key_.Get();
}
inline void GetResponseRequest_GetResponseConfig::_internal_set_api_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.api_key_.Set(value, GetArena());
}
inline std::string* GetResponseRequest_GetResponseConfig::_internal_mutable_api_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.api_key_.Mutable( GetArena());
}
inline std::string* GetResponseRequest_GetResponseConfig::release_api_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.api_key)
  return _impl_.api_key_.Release();
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_api_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.api_key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.api_key_.IsDefault()) {
          _impl_.api_key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.api_key)
}

// string session_id = 4;
inline void GetResponseRequest_GetResponseConfig::clear_session_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& GetResponseRequest_GetResponseConfig::session_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.session_id)
  return _internal_session_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetResponseRequest_GetResponseConfig::set_session_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseConfig.session_id)
}
inline std::string* GetResponseRequest_GetResponseConfig::mutable_session_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.session_id)
  return _s;
}
inline const std::string& GetResponseRequest_GetResponseConfig::_internal_session_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.session_id_.Get();
}
inline void GetResponseRequest_GetResponseConfig::_internal_set_session_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_.Set(value, GetArena());
}
inline std::string* GetResponseRequest_GetResponseConfig::_internal_mutable_session_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.session_id_.Mutable( GetArena());
}
inline std::string* GetResponseRequest_GetResponseConfig::release_session_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.session_id)
  return _impl_.session_id_.Release();
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_session_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_id_.IsDefault()) {
          _impl_.session_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.session_id)
}

// .service.AudioConfig audio_config = 5;
inline bool GetResponseRequest_GetResponseConfig::has_audio_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.audio_config_ != nullptr);
  return value;
}
inline void GetResponseRequest_GetResponseConfig::clear_audio_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.audio_config_ != nullptr) _impl_.audio_config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::service::AudioConfig& GetResponseRequest_GetResponseConfig::_internal_audio_config() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::service::AudioConfig* p = _impl_.audio_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::AudioConfig&>(::service::_AudioConfig_default_instance_);
}
inline const ::service::AudioConfig& GetResponseRequest_GetResponseConfig::audio_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.audio_config)
  return _internal_audio_config();
}
inline void GetResponseRequest_GetResponseConfig::unsafe_arena_set_allocated_audio_config(::service::AudioConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.audio_config_);
  }
  _impl_.audio_config_ = reinterpret_cast<::service::AudioConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequest.GetResponseConfig.audio_config)
}
inline ::service::AudioConfig* GetResponseRequest_GetResponseConfig::release_audio_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::service::AudioConfig* released = _impl_.audio_config_;
  _impl_.audio_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::service::AudioConfig* GetResponseRequest_GetResponseConfig::unsafe_arena_release_audio_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.audio_config)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::service::AudioConfig* temp = _impl_.audio_config_;
  _impl_.audio_config_ = nullptr;
  return temp;
}
inline ::service::AudioConfig* GetResponseRequest_GetResponseConfig::_internal_mutable_audio_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.audio_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::service::AudioConfig>(GetArena());
    _impl_.audio_config_ = reinterpret_cast<::service::AudioConfig*>(p);
  }
  return _impl_.audio_config_;
}
inline ::service::AudioConfig* GetResponseRequest_GetResponseConfig::mutable_audio_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::service::AudioConfig* _msg = _internal_mutable_audio_config();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.audio_config)
  return _msg;
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_audio_config(::service::AudioConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.audio_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.audio_config_ = reinterpret_cast<::service::AudioConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.audio_config)
}

// .service.ActionConfig action_config = 6;
inline bool GetResponseRequest_GetResponseConfig::has_action_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.action_config_ != nullptr);
  return value;
}
inline void GetResponseRequest_GetResponseConfig::clear_action_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.action_config_ != nullptr) _impl_.action_config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::service::ActionConfig& GetResponseRequest_GetResponseConfig::_internal_action_config() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::service::ActionConfig* p = _impl_.action_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::ActionConfig&>(::service::_ActionConfig_default_instance_);
}
inline const ::service::ActionConfig& GetResponseRequest_GetResponseConfig::action_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.action_config)
  return _internal_action_config();
}
inline void GetResponseRequest_GetResponseConfig::unsafe_arena_set_allocated_action_config(::service::ActionConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.action_config_);
  }
  _impl_.action_config_ = reinterpret_cast<::service::ActionConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequest.GetResponseConfig.action_config)
}
inline ::service::ActionConfig* GetResponseRequest_GetResponseConfig::release_action_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::service::ActionConfig* released = _impl_.action_config_;
  _impl_.action_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::service::ActionConfig* GetResponseRequest_GetResponseConfig::unsafe_arena_release_action_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.action_config)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::service::ActionConfig* temp = _impl_.action_config_;
  _impl_.action_config_ = nullptr;
  return temp;
}
inline ::service::ActionConfig* GetResponseRequest_GetResponseConfig::_internal_mutable_action_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.action_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::service::ActionConfig>(GetArena());
    _impl_.action_config_ = reinterpret_cast<::service::ActionConfig*>(p);
  }
  return _impl_.action_config_;
}
inline ::service::ActionConfig* GetResponseRequest_GetResponseConfig::mutable_action_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::service::ActionConfig* _msg = _internal_mutable_action_config();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.action_config)
  return _msg;
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_action_config(::service::ActionConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.action_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.action_config_ = reinterpret_cast<::service::ActionConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.action_config)
}

// string speaker = 7;
inline void GetResponseRequest_GetResponseConfig::clear_speaker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.speaker_.ClearToEmpty();
}
inline const std::string& GetResponseRequest_GetResponseConfig::speaker() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.speaker)
  return _internal_speaker();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetResponseRequest_GetResponseConfig::set_speaker(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.speaker_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseConfig.speaker)
}
inline std::string* GetResponseRequest_GetResponseConfig::mutable_speaker() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_speaker();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.speaker)
  return _s;
}
inline const std::string& GetResponseRequest_GetResponseConfig::_internal_speaker() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.speaker_.Get();
}
inline void GetResponseRequest_GetResponseConfig::_internal_set_speaker(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.speaker_.Set(value, GetArena());
}
inline std::string* GetResponseRequest_GetResponseConfig::_internal_mutable_speaker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.speaker_.Mutable( GetArena());
}
inline std::string* GetResponseRequest_GetResponseConfig::release_speaker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.speaker)
  return _impl_.speaker_.Release();
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_speaker(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.speaker_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.speaker_.IsDefault()) {
          _impl_.speaker_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.speaker)
}

// string language_code = 8;
inline void GetResponseRequest_GetResponseConfig::clear_language_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.language_code_.ClearToEmpty();
}
inline const std::string& GetResponseRequest_GetResponseConfig::language_code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.language_code)
  return _internal_language_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetResponseRequest_GetResponseConfig::set_language_code(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.language_code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseConfig.language_code)
}
inline std::string* GetResponseRequest_GetResponseConfig::mutable_language_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_language_code();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.language_code)
  return _s;
}
inline const std::string& GetResponseRequest_GetResponseConfig::_internal_language_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.language_code_.Get();
}
inline void GetResponseRequest_GetResponseConfig::_internal_set_language_code(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.language_code_.Set(value, GetArena());
}
inline std::string* GetResponseRequest_GetResponseConfig::_internal_mutable_language_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.language_code_.Mutable( GetArena());
}
inline std::string* GetResponseRequest_GetResponseConfig::release_language_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.language_code)
  return _impl_.language_code_.Release();
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_language_code(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.language_code_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.language_code_.IsDefault()) {
          _impl_.language_code_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.language_code)
}

// string speaker_id = 9;
inline void GetResponseRequest_GetResponseConfig::clear_speaker_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.speaker_id_.ClearToEmpty();
}
inline const std::string& GetResponseRequest_GetResponseConfig::speaker_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.speaker_id)
  return _internal_speaker_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetResponseRequest_GetResponseConfig::set_speaker_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.speaker_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseConfig.speaker_id)
}
inline std::string* GetResponseRequest_GetResponseConfig::mutable_speaker_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_speaker_id();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.speaker_id)
  return _s;
}
inline const std::string& GetResponseRequest_GetResponseConfig::_internal_speaker_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.speaker_id_.Get();
}
inline void GetResponseRequest_GetResponseConfig::_internal_set_speaker_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.speaker_id_.Set(value, GetArena());
}
inline std::string* GetResponseRequest_GetResponseConfig::_internal_mutable_speaker_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.speaker_id_.Mutable( GetArena());
}
inline std::string* GetResponseRequest_GetResponseConfig::release_speaker_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.speaker_id)
  return _impl_.speaker_id_.Release();
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_speaker_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.speaker_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.speaker_id_.IsDefault()) {
          _impl_.speaker_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.speaker_id)
}

// string api_auth_token = 10;
inline void GetResponseRequest_GetResponseConfig::clear_api_auth_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.api_auth_token_.ClearToEmpty();
}
inline const std::string& GetResponseRequest_GetResponseConfig::api_auth_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.api_auth_token)
  return _internal_api_auth_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetResponseRequest_GetResponseConfig::set_api_auth_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.api_auth_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseConfig.api_auth_token)
}
inline std::string* GetResponseRequest_GetResponseConfig::mutable_api_auth_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_api_auth_token();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.api_auth_token)
  return _s;
}
inline const std::string& GetResponseRequest_GetResponseConfig::_internal_api_auth_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.api_auth_token_.Get();
}
inline void GetResponseRequest_GetResponseConfig::_internal_set_api_auth_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.api_auth_token_.Set(value, GetArena());
}
inline std::string* GetResponseRequest_GetResponseConfig::_internal_mutable_api_auth_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.api_auth_token_.Mutable( GetArena());
}
inline std::string* GetResponseRequest_GetResponseConfig::release_api_auth_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.api_auth_token)
  return _impl_.api_auth_token_.Release();
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_api_auth_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.api_auth_token_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.api_auth_token_.IsDefault()) {
          _impl_.api_auth_token_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.api_auth_token)
}

// map<string, string> narrative_template_keys = 11;
inline int GetResponseRequest_GetResponseConfig::_internal_narrative_template_keys_size() const {
  return _internal_narrative_template_keys().size();
}
inline int GetResponseRequest_GetResponseConfig::narrative_template_keys_size() const {
  return _internal_narrative_template_keys_size();
}
inline void GetResponseRequest_GetResponseConfig::clear_narrative_template_keys() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.narrative_template_keys_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& GetResponseRequest_GetResponseConfig::_internal_narrative_template_keys() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.narrative_template_keys_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& GetResponseRequest_GetResponseConfig::narrative_template_keys() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:service.GetResponseRequest.GetResponseConfig.narrative_template_keys)
  return _internal_narrative_template_keys();
}
inline ::google::protobuf::Map<std::string, std::string>* GetResponseRequest_GetResponseConfig::_internal_mutable_narrative_template_keys() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.narrative_template_keys_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* GetResponseRequest_GetResponseConfig::mutable_narrative_template_keys() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:service.GetResponseRequest.GetResponseConfig.narrative_template_keys)
  return _internal_mutable_narrative_template_keys();
}

// .service.DynamicInfoConfig dynamic_info_config = 12;
inline bool GetResponseRequest_GetResponseConfig::has_dynamic_info_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dynamic_info_config_ != nullptr);
  return value;
}
inline void GetResponseRequest_GetResponseConfig::clear_dynamic_info_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dynamic_info_config_ != nullptr) _impl_.dynamic_info_config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::service::DynamicInfoConfig& GetResponseRequest_GetResponseConfig::_internal_dynamic_info_config() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::service::DynamicInfoConfig* p = _impl_.dynamic_info_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::DynamicInfoConfig&>(::service::_DynamicInfoConfig_default_instance_);
}
inline const ::service::DynamicInfoConfig& GetResponseRequest_GetResponseConfig::dynamic_info_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.dynamic_info_config)
  return _internal_dynamic_info_config();
}
inline void GetResponseRequest_GetResponseConfig::unsafe_arena_set_allocated_dynamic_info_config(::service::DynamicInfoConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dynamic_info_config_);
  }
  _impl_.dynamic_info_config_ = reinterpret_cast<::service::DynamicInfoConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequest.GetResponseConfig.dynamic_info_config)
}
inline ::service::DynamicInfoConfig* GetResponseRequest_GetResponseConfig::release_dynamic_info_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::service::DynamicInfoConfig* released = _impl_.dynamic_info_config_;
  _impl_.dynamic_info_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::service::DynamicInfoConfig* GetResponseRequest_GetResponseConfig::unsafe_arena_release_dynamic_info_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.dynamic_info_config)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::service::DynamicInfoConfig* temp = _impl_.dynamic_info_config_;
  _impl_.dynamic_info_config_ = nullptr;
  return temp;
}
inline ::service::DynamicInfoConfig* GetResponseRequest_GetResponseConfig::_internal_mutable_dynamic_info_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dynamic_info_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::service::DynamicInfoConfig>(GetArena());
    _impl_.dynamic_info_config_ = reinterpret_cast<::service::DynamicInfoConfig*>(p);
  }
  return _impl_.dynamic_info_config_;
}
inline ::service::DynamicInfoConfig* GetResponseRequest_GetResponseConfig::mutable_dynamic_info_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::service::DynamicInfoConfig* _msg = _internal_mutable_dynamic_info_config();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.dynamic_info_config)
  return _msg;
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_dynamic_info_config(::service::DynamicInfoConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.dynamic_info_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.dynamic_info_config_ = reinterpret_cast<::service::DynamicInfoConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.dynamic_info_config)
}

// .service.VisionInput vision_input = 13;
inline bool GetResponseRequest_GetResponseConfig::has_vision_input() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vision_input_ != nullptr);
  return value;
}
inline void GetResponseRequest_GetResponseConfig::clear_vision_input() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.vision_input_ != nullptr) _impl_.vision_input_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::service::VisionInput& GetResponseRequest_GetResponseConfig::_internal_vision_input() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::service::VisionInput* p = _impl_.vision_input_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::VisionInput&>(::service::_VisionInput_default_instance_);
}
inline const ::service::VisionInput& GetResponseRequest_GetResponseConfig::vision_input() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.vision_input)
  return _internal_vision_input();
}
inline void GetResponseRequest_GetResponseConfig::unsafe_arena_set_allocated_vision_input(::service::VisionInput* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vision_input_);
  }
  _impl_.vision_input_ = reinterpret_cast<::service::VisionInput*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequest.GetResponseConfig.vision_input)
}
inline ::service::VisionInput* GetResponseRequest_GetResponseConfig::release_vision_input() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::service::VisionInput* released = _impl_.vision_input_;
  _impl_.vision_input_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::service::VisionInput* GetResponseRequest_GetResponseConfig::unsafe_arena_release_vision_input() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.vision_input)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::service::VisionInput* temp = _impl_.vision_input_;
  _impl_.vision_input_ = nullptr;
  return temp;
}
inline ::service::VisionInput* GetResponseRequest_GetResponseConfig::_internal_mutable_vision_input() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.vision_input_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::service::VisionInput>(GetArena());
    _impl_.vision_input_ = reinterpret_cast<::service::VisionInput*>(p);
  }
  return _impl_.vision_input_;
}
inline ::service::VisionInput* GetResponseRequest_GetResponseConfig::mutable_vision_input() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::service::VisionInput* _msg = _internal_mutable_vision_input();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.vision_input)
  return _msg;
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_vision_input(::service::VisionInput* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.vision_input_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.vision_input_ = reinterpret_cast<::service::VisionInput*>(value);
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.vision_input)
}

// -------------------------------------------------------------------

// GetResponseRequest_GetResponseData

// bytes audio_data = 1;
inline bool GetResponseRequest_GetResponseData::has_audio_data() const {
  return input_type_case() == kAudioData;
}
inline void GetResponseRequest_GetResponseData::set_has_audio_data() {
  _impl_._oneof_case_[0] = kAudioData;
}
inline void GetResponseRequest_GetResponseData::clear_audio_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (input_type_case() == kAudioData) {
    _impl_.input_type_.audio_data_.Destroy();
    clear_has_input_type();
  }
}
inline const std::string& GetResponseRequest_GetResponseData::audio_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseData.audio_data)
  return _internal_audio_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetResponseRequest_GetResponseData::set_audio_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (input_type_case() != kAudioData) {
    clear_input_type();

    set_has_audio_data();
    _impl_.input_type_.audio_data_.InitDefault();
  }
  _impl_.input_type_.audio_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseData.audio_data)
}
inline std::string* GetResponseRequest_GetResponseData::mutable_audio_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_audio_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseData.audio_data)
  return _s;
}
inline const std::string& GetResponseRequest_GetResponseData::_internal_audio_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (input_type_case() != kAudioData) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.input_type_.audio_data_.Get();
}
inline void GetResponseRequest_GetResponseData::_internal_set_audio_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (input_type_case() != kAudioData) {
    clear_input_type();

    set_has_audio_data();
    _impl_.input_type_.audio_data_.InitDefault();
  }
  _impl_.input_type_.audio_data_.Set(value, GetArena());
}
inline std::string* GetResponseRequest_GetResponseData::_internal_mutable_audio_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (input_type_case() != kAudioData) {
    clear_input_type();

    set_has_audio_data();
    _impl_.input_type_.audio_data_.InitDefault();
  }
  return _impl_.input_type_.audio_data_.Mutable( GetArena());
}
inline std::string* GetResponseRequest_GetResponseData::release_audio_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseData.audio_data)
  if (input_type_case() != kAudioData) {
    return nullptr;
  }
  clear_has_input_type();
  return _impl_.input_type_.audio_data_.Release();
}
inline void GetResponseRequest_GetResponseData::set_allocated_audio_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_input_type()) {
    clear_input_type();
  }
  if (value != nullptr) {
    set_has_audio_data();
    _impl_.input_type_.audio_data_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseData.audio_data)
}

// string text_data = 2;
inline bool GetResponseRequest_GetResponseData::has_text_data() const {
  return input_type_case() == kTextData;
}
inline void GetResponseRequest_GetResponseData::set_has_text_data() {
  _impl_._oneof_case_[0] = kTextData;
}
inline void GetResponseRequest_GetResponseData::clear_text_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (input_type_case() == kTextData) {
    _impl_.input_type_.text_data_.Destroy();
    clear_has_input_type();
  }
}
inline const std::string& GetResponseRequest_GetResponseData::text_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseData.text_data)
  return _internal_text_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetResponseRequest_GetResponseData::set_text_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (input_type_case() != kTextData) {
    clear_input_type();

    set_has_text_data();
    _impl_.input_type_.text_data_.InitDefault();
  }
  _impl_.input_type_.text_data_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseData.text_data)
}
inline std::string* GetResponseRequest_GetResponseData::mutable_text_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseData.text_data)
  return _s;
}
inline const std::string& GetResponseRequest_GetResponseData::_internal_text_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (input_type_case() != kTextData) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.input_type_.text_data_.Get();
}
inline void GetResponseRequest_GetResponseData::_internal_set_text_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (input_type_case() != kTextData) {
    clear_input_type();

    set_has_text_data();
    _impl_.input_type_.text_data_.InitDefault();
  }
  _impl_.input_type_.text_data_.Set(value, GetArena());
}
inline std::string* GetResponseRequest_GetResponseData::_internal_mutable_text_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (input_type_case() != kTextData) {
    clear_input_type();

    set_has_text_data();
    _impl_.input_type_.text_data_.InitDefault();
  }
  return _impl_.input_type_.text_data_.Mutable( GetArena());
}
inline std::string* GetResponseRequest_GetResponseData::release_text_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseData.text_data)
  if (input_type_case() != kTextData) {
    return nullptr;
  }
  clear_has_input_type();
  return _impl_.input_type_.text_data_.Release();
}
inline void GetResponseRequest_GetResponseData::set_allocated_text_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_input_type()) {
    clear_input_type();
  }
  if (value != nullptr) {
    set_has_text_data();
    _impl_.input_type_.text_data_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseData.text_data)
}

// .service.TriggerConfig trigger_data = 3;
inline bool GetResponseRequest_GetResponseData::has_trigger_data() const {
  return input_type_case() == kTriggerData;
}
inline bool GetResponseRequest_GetResponseData::_internal_has_trigger_data() const {
  return input_type_case() == kTriggerData;
}
inline void GetResponseRequest_GetResponseData::set_has_trigger_data() {
  _impl_._oneof_case_[0] = kTriggerData;
}
inline void GetResponseRequest_GetResponseData::clear_trigger_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (input_type_case() == kTriggerData) {
    if (GetArena() == nullptr) {
      delete _impl_.input_type_.trigger_data_;
    }
    clear_has_input_type();
  }
}
inline ::service::TriggerConfig* GetResponseRequest_GetResponseData::release_trigger_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseData.trigger_data)
  if (input_type_case() == kTriggerData) {
    clear_has_input_type();
    auto* temp = _impl_.input_type_.trigger_data_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.input_type_.trigger_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::TriggerConfig& GetResponseRequest_GetResponseData::_internal_trigger_data() const {
  return input_type_case() == kTriggerData ? *_impl_.input_type_.trigger_data_ : reinterpret_cast<::service::TriggerConfig&>(::service::_TriggerConfig_default_instance_);
}
inline const ::service::TriggerConfig& GetResponseRequest_GetResponseData::trigger_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseData.trigger_data)
  return _internal_trigger_data();
}
inline ::service::TriggerConfig* GetResponseRequest_GetResponseData::unsafe_arena_release_trigger_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseRequest.GetResponseData.trigger_data)
  if (input_type_case() == kTriggerData) {
    clear_has_input_type();
    auto* temp = _impl_.input_type_.trigger_data_;
    _impl_.input_type_.trigger_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseRequest_GetResponseData::unsafe_arena_set_allocated_trigger_data(::service::TriggerConfig* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_input_type();
  if (value) {
    set_has_trigger_data();
    _impl_.input_type_.trigger_data_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequest.GetResponseData.trigger_data)
}
inline ::service::TriggerConfig* GetResponseRequest_GetResponseData::_internal_mutable_trigger_data() {
  if (input_type_case() != kTriggerData) {
    clear_input_type();
    set_has_trigger_data();
    _impl_.input_type_.trigger_data_ =
        ::google::protobuf::Message::DefaultConstruct<::service::TriggerConfig>(GetArena());
  }
  return _impl_.input_type_.trigger_data_;
}
inline ::service::TriggerConfig* GetResponseRequest_GetResponseData::mutable_trigger_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::service::TriggerConfig* _msg = _internal_mutable_trigger_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseData.trigger_data)
  return _msg;
}

inline bool GetResponseRequest_GetResponseData::has_input_type() const {
  return input_type_case() != INPUT_TYPE_NOT_SET;
}
inline void GetResponseRequest_GetResponseData::clear_has_input_type() {
  _impl_._oneof_case_[0] = INPUT_TYPE_NOT_SET;
}
inline GetResponseRequest_GetResponseData::InputTypeCase GetResponseRequest_GetResponseData::input_type_case() const {
  return GetResponseRequest_GetResponseData::InputTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetResponseRequest

// .service.GetResponseRequest.GetResponseConfig get_response_config = 1;
inline bool GetResponseRequest::has_get_response_config() const {
  return request_type_case() == kGetResponseConfig;
}
inline bool GetResponseRequest::_internal_has_get_response_config() const {
  return request_type_case() == kGetResponseConfig;
}
inline void GetResponseRequest::set_has_get_response_config() {
  _impl_._oneof_case_[0] = kGetResponseConfig;
}
inline void GetResponseRequest::clear_get_response_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (request_type_case() == kGetResponseConfig) {
    if (GetArena() == nullptr) {
      delete _impl_.request_type_.get_response_config_;
    }
    clear_has_request_type();
  }
}
inline ::service::GetResponseRequest_GetResponseConfig* GetResponseRequest::release_get_response_config() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.get_response_config)
  if (request_type_case() == kGetResponseConfig) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.get_response_config_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.get_response_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::GetResponseRequest_GetResponseConfig& GetResponseRequest::_internal_get_response_config() const {
  return request_type_case() == kGetResponseConfig ? *_impl_.request_type_.get_response_config_ : reinterpret_cast<::service::GetResponseRequest_GetResponseConfig&>(::service::_GetResponseRequest_GetResponseConfig_default_instance_);
}
inline const ::service::GetResponseRequest_GetResponseConfig& GetResponseRequest::get_response_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.get_response_config)
  return _internal_get_response_config();
}
inline ::service::GetResponseRequest_GetResponseConfig* GetResponseRequest::unsafe_arena_release_get_response_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseRequest.get_response_config)
  if (request_type_case() == kGetResponseConfig) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.get_response_config_;
    _impl_.request_type_.get_response_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseRequest::unsafe_arena_set_allocated_get_response_config(::service::GetResponseRequest_GetResponseConfig* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_get_response_config();
    _impl_.request_type_.get_response_config_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequest.get_response_config)
}
inline ::service::GetResponseRequest_GetResponseConfig* GetResponseRequest::_internal_mutable_get_response_config() {
  if (request_type_case() != kGetResponseConfig) {
    clear_request_type();
    set_has_get_response_config();
    _impl_.request_type_.get_response_config_ =
        ::google::protobuf::Message::DefaultConstruct<::service::GetResponseRequest_GetResponseConfig>(GetArena());
  }
  return _impl_.request_type_.get_response_config_;
}
inline ::service::GetResponseRequest_GetResponseConfig* GetResponseRequest::mutable_get_response_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::service::GetResponseRequest_GetResponseConfig* _msg = _internal_mutable_get_response_config();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.get_response_config)
  return _msg;
}

// .service.GetResponseRequest.GetResponseData get_response_data = 2;
inline bool GetResponseRequest::has_get_response_data() const {
  return request_type_case() == kGetResponseData;
}
inline bool GetResponseRequest::_internal_has_get_response_data() const {
  return request_type_case() == kGetResponseData;
}
inline void GetResponseRequest::set_has_get_response_data() {
  _impl_._oneof_case_[0] = kGetResponseData;
}
inline void GetResponseRequest::clear_get_response_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (request_type_case() == kGetResponseData) {
    if (GetArena() == nullptr) {
      delete _impl_.request_type_.get_response_data_;
    }
    clear_has_request_type();
  }
}
inline ::service::GetResponseRequest_GetResponseData* GetResponseRequest::release_get_response_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.get_response_data)
  if (request_type_case() == kGetResponseData) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.get_response_data_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.get_response_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::GetResponseRequest_GetResponseData& GetResponseRequest::_internal_get_response_data() const {
  return request_type_case() == kGetResponseData ? *_impl_.request_type_.get_response_data_ : reinterpret_cast<::service::GetResponseRequest_GetResponseData&>(::service::_GetResponseRequest_GetResponseData_default_instance_);
}
inline const ::service::GetResponseRequest_GetResponseData& GetResponseRequest::get_response_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.get_response_data)
  return _internal_get_response_data();
}
inline ::service::GetResponseRequest_GetResponseData* GetResponseRequest::unsafe_arena_release_get_response_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseRequest.get_response_data)
  if (request_type_case() == kGetResponseData) {
    clear_has_request_type();
    auto* temp = _impl_.request_type_.get_response_data_;
    _impl_.request_type_.get_response_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseRequest::unsafe_arena_set_allocated_get_response_data(::service::GetResponseRequest_GetResponseData* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_get_response_data();
    _impl_.request_type_.get_response_data_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequest.get_response_data)
}
inline ::service::GetResponseRequest_GetResponseData* GetResponseRequest::_internal_mutable_get_response_data() {
  if (request_type_case() != kGetResponseData) {
    clear_request_type();
    set_has_get_response_data();
    _impl_.request_type_.get_response_data_ =
        ::google::protobuf::Message::DefaultConstruct<::service::GetResponseRequest_GetResponseData>(GetArena());
  }
  return _impl_.request_type_.get_response_data_;
}
inline ::service::GetResponseRequest_GetResponseData* GetResponseRequest::mutable_get_response_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::service::GetResponseRequest_GetResponseData* _msg = _internal_mutable_get_response_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.get_response_data)
  return _msg;
}

inline bool GetResponseRequest::has_request_type() const {
  return request_type_case() != REQUEST_TYPE_NOT_SET;
}
inline void GetResponseRequest::clear_has_request_type() {
  _impl_._oneof_case_[0] = REQUEST_TYPE_NOT_SET;
}
inline GetResponseRequest::RequestTypeCase GetResponseRequest::request_type_case() const {
  return GetResponseRequest::RequestTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetResponseRequestSingle

// .service.GetResponseRequest response_config = 1;
inline bool GetResponseRequestSingle::has_response_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_config_ != nullptr);
  return value;
}
inline void GetResponseRequestSingle::clear_response_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.response_config_ != nullptr) _impl_.response_config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::service::GetResponseRequest& GetResponseRequestSingle::_internal_response_config() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::service::GetResponseRequest* p = _impl_.response_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::GetResponseRequest&>(::service::_GetResponseRequest_default_instance_);
}
inline const ::service::GetResponseRequest& GetResponseRequestSingle::response_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseRequestSingle.response_config)
  return _internal_response_config();
}
inline void GetResponseRequestSingle::unsafe_arena_set_allocated_response_config(::service::GetResponseRequest* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.response_config_);
  }
  _impl_.response_config_ = reinterpret_cast<::service::GetResponseRequest*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequestSingle.response_config)
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::release_response_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::service::GetResponseRequest* released = _impl_.response_config_;
  _impl_.response_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::unsafe_arena_release_response_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseRequestSingle.response_config)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::service::GetResponseRequest* temp = _impl_.response_config_;
  _impl_.response_config_ = nullptr;
  return temp;
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::_internal_mutable_response_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.response_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::service::GetResponseRequest>(GetArena());
    _impl_.response_config_ = reinterpret_cast<::service::GetResponseRequest*>(p);
  }
  return _impl_.response_config_;
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::mutable_response_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::service::GetResponseRequest* _msg = _internal_mutable_response_config();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequestSingle.response_config)
  return _msg;
}
inline void GetResponseRequestSingle::set_allocated_response_config(::service::GetResponseRequest* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.response_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.response_config_ = reinterpret_cast<::service::GetResponseRequest*>(value);
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequestSingle.response_config)
}

// .service.GetResponseRequest response_data = 2;
inline bool GetResponseRequestSingle::has_response_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_data_ != nullptr);
  return value;
}
inline void GetResponseRequestSingle::clear_response_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.response_data_ != nullptr) _impl_.response_data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::service::GetResponseRequest& GetResponseRequestSingle::_internal_response_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::service::GetResponseRequest* p = _impl_.response_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::GetResponseRequest&>(::service::_GetResponseRequest_default_instance_);
}
inline const ::service::GetResponseRequest& GetResponseRequestSingle::response_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseRequestSingle.response_data)
  return _internal_response_data();
}
inline void GetResponseRequestSingle::unsafe_arena_set_allocated_response_data(::service::GetResponseRequest* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.response_data_);
  }
  _impl_.response_data_ = reinterpret_cast<::service::GetResponseRequest*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequestSingle.response_data)
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::release_response_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::service::GetResponseRequest* released = _impl_.response_data_;
  _impl_.response_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::unsafe_arena_release_response_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseRequestSingle.response_data)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::service::GetResponseRequest* temp = _impl_.response_data_;
  _impl_.response_data_ = nullptr;
  return temp;
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::_internal_mutable_response_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.response_data_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::service::GetResponseRequest>(GetArena());
    _impl_.response_data_ = reinterpret_cast<::service::GetResponseRequest*>(p);
  }
  return _impl_.response_data_;
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::mutable_response_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::service::GetResponseRequest* _msg = _internal_mutable_response_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequestSingle.response_data)
  return _msg;
}
inline void GetResponseRequestSingle::set_allocated_response_data(::service::GetResponseRequest* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.response_data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.response_data_ = reinterpret_cast<::service::GetResponseRequest*>(value);
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequestSingle.response_data)
}

// -------------------------------------------------------------------

// GetResponseResponse_AudioResponse

// bytes audio_data = 1;
inline void GetResponseResponse_AudioResponse::clear_audio_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audio_data_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_AudioResponse::audio_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.audio_data)
  return _internal_audio_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetResponseResponse_AudioResponse::set_audio_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audio_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.AudioResponse.audio_data)
}
inline std::string* GetResponseResponse_AudioResponse::mutable_audio_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_audio_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.AudioResponse.audio_data)
  return _s;
}
inline const std::string& GetResponseResponse_AudioResponse::_internal_audio_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.audio_data_.Get();
}
inline void GetResponseResponse_AudioResponse::_internal_set_audio_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audio_data_.Set(value, GetArena());
}
inline std::string* GetResponseResponse_AudioResponse::_internal_mutable_audio_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.audio_data_.Mutable( GetArena());
}
inline std::string* GetResponseResponse_AudioResponse::release_audio_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.AudioResponse.audio_data)
  return _impl_.audio_data_.Release();
}
inline void GetResponseResponse_AudioResponse::set_allocated_audio_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audio_data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.audio_data_.IsDefault()) {
          _impl_.audio_data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.AudioResponse.audio_data)
}

// .service.AudioConfig audio_config = 2;
inline bool GetResponseResponse_AudioResponse::has_audio_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.audio_config_ != nullptr);
  return value;
}
inline void GetResponseResponse_AudioResponse::clear_audio_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.audio_config_ != nullptr) _impl_.audio_config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::service::AudioConfig& GetResponseResponse_AudioResponse::_internal_audio_config() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::service::AudioConfig* p = _impl_.audio_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::AudioConfig&>(::service::_AudioConfig_default_instance_);
}
inline const ::service::AudioConfig& GetResponseResponse_AudioResponse::audio_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.audio_config)
  return _internal_audio_config();
}
inline void GetResponseResponse_AudioResponse::unsafe_arena_set_allocated_audio_config(::service::AudioConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.audio_config_);
  }
  _impl_.audio_config_ = reinterpret_cast<::service::AudioConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.AudioResponse.audio_config)
}
inline ::service::AudioConfig* GetResponseResponse_AudioResponse::release_audio_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::service::AudioConfig* released = _impl_.audio_config_;
  _impl_.audio_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::service::AudioConfig* GetResponseResponse_AudioResponse::unsafe_arena_release_audio_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.AudioResponse.audio_config)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::service::AudioConfig* temp = _impl_.audio_config_;
  _impl_.audio_config_ = nullptr;
  return temp;
}
inline ::service::AudioConfig* GetResponseResponse_AudioResponse::_internal_mutable_audio_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.audio_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::service::AudioConfig>(GetArena());
    _impl_.audio_config_ = reinterpret_cast<::service::AudioConfig*>(p);
  }
  return _impl_.audio_config_;
}
inline ::service::AudioConfig* GetResponseResponse_AudioResponse::mutable_audio_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::service::AudioConfig* _msg = _internal_mutable_audio_config();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.AudioResponse.audio_config)
  return _msg;
}
inline void GetResponseResponse_AudioResponse::set_allocated_audio_config(::service::AudioConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.audio_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.audio_config_ = reinterpret_cast<::service::AudioConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.AudioResponse.audio_config)
}

// string text_data = 3;
inline void GetResponseResponse_AudioResponse::clear_text_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_data_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_AudioResponse::text_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.text_data)
  return _internal_text_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetResponseResponse_AudioResponse::set_text_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_data_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.AudioResponse.text_data)
}
inline std::string* GetResponseResponse_AudioResponse::mutable_text_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.AudioResponse.text_data)
  return _s;
}
inline const std::string& GetResponseResponse_AudioResponse::_internal_text_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_data_.Get();
}
inline void GetResponseResponse_AudioResponse::_internal_set_text_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_data_.Set(value, GetArena());
}
inline std::string* GetResponseResponse_AudioResponse::_internal_mutable_text_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.text_data_.Mutable( GetArena());
}
inline std::string* GetResponseResponse_AudioResponse::release_text_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.AudioResponse.text_data)
  return _impl_.text_data_.Release();
}
inline void GetResponseResponse_AudioResponse::set_allocated_text_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_data_.IsDefault()) {
          _impl_.text_data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.AudioResponse.text_data)
}

// bool end_of_response = 4;
inline void GetResponseResponse_AudioResponse::clear_end_of_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_of_response_ = false;
}
inline bool GetResponseResponse_AudioResponse::end_of_response() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.end_of_response)
  return _internal_end_of_response();
}
inline void GetResponseResponse_AudioResponse::set_end_of_response(bool value) {
  _internal_set_end_of_response(value);
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.AudioResponse.end_of_response)
}
inline bool GetResponseResponse_AudioResponse::_internal_end_of_response() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_of_response_;
}
inline void GetResponseResponse_AudioResponse::_internal_set_end_of_response(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_of_response_ = value;
}

// string face_data = 5;
inline void GetResponseResponse_AudioResponse::clear_face_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.face_data_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_AudioResponse::face_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.face_data)
  return _internal_face_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetResponseResponse_AudioResponse::set_face_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.face_data_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.AudioResponse.face_data)
}
inline std::string* GetResponseResponse_AudioResponse::mutable_face_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_face_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.AudioResponse.face_data)
  return _s;
}
inline const std::string& GetResponseResponse_AudioResponse::_internal_face_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.face_data_.Get();
}
inline void GetResponseResponse_AudioResponse::_internal_set_face_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.face_data_.Set(value, GetArena());
}
inline std::string* GetResponseResponse_AudioResponse::_internal_mutable_face_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.face_data_.Mutable( GetArena());
}
inline std::string* GetResponseResponse_AudioResponse::release_face_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.AudioResponse.face_data)
  return _impl_.face_data_.Release();
}
inline void GetResponseResponse_AudioResponse::set_allocated_face_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.face_data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.face_data_.IsDefault()) {
          _impl_.face_data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.AudioResponse.face_data)
}

// .service.VisemesData visemes_data = 6;
inline bool GetResponseResponse_AudioResponse::has_visemes_data() const {
  return face_data_type_case() == kVisemesData;
}
inline bool GetResponseResponse_AudioResponse::_internal_has_visemes_data() const {
  return face_data_type_case() == kVisemesData;
}
inline void GetResponseResponse_AudioResponse::set_has_visemes_data() {
  _impl_._oneof_case_[0] = kVisemesData;
}
inline void GetResponseResponse_AudioResponse::clear_visemes_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (face_data_type_case() == kVisemesData) {
    if (GetArena() == nullptr) {
      delete _impl_.face_data_type_.visemes_data_;
    }
    clear_has_face_data_type();
  }
}
inline ::service::VisemesData* GetResponseResponse_AudioResponse::release_visemes_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.AudioResponse.visemes_data)
  if (face_data_type_case() == kVisemesData) {
    clear_has_face_data_type();
    auto* temp = _impl_.face_data_type_.visemes_data_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.face_data_type_.visemes_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::VisemesData& GetResponseResponse_AudioResponse::_internal_visemes_data() const {
  return face_data_type_case() == kVisemesData ? *_impl_.face_data_type_.visemes_data_ : reinterpret_cast<::service::VisemesData&>(::service::_VisemesData_default_instance_);
}
inline const ::service::VisemesData& GetResponseResponse_AudioResponse::visemes_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.visemes_data)
  return _internal_visemes_data();
}
inline ::service::VisemesData* GetResponseResponse_AudioResponse::unsafe_arena_release_visemes_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseResponse.AudioResponse.visemes_data)
  if (face_data_type_case() == kVisemesData) {
    clear_has_face_data_type();
    auto* temp = _impl_.face_data_type_.visemes_data_;
    _impl_.face_data_type_.visemes_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse_AudioResponse::unsafe_arena_set_allocated_visemes_data(::service::VisemesData* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_face_data_type();
  if (value) {
    set_has_visemes_data();
    _impl_.face_data_type_.visemes_data_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.AudioResponse.visemes_data)
}
inline ::service::VisemesData* GetResponseResponse_AudioResponse::_internal_mutable_visemes_data() {
  if (face_data_type_case() != kVisemesData) {
    clear_face_data_type();
    set_has_visemes_data();
    _impl_.face_data_type_.visemes_data_ =
        ::google::protobuf::Message::DefaultConstruct<::service::VisemesData>(GetArena());
  }
  return _impl_.face_data_type_.visemes_data_;
}
inline ::service::VisemesData* GetResponseResponse_AudioResponse::mutable_visemes_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::service::VisemesData* _msg = _internal_mutable_visemes_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.AudioResponse.visemes_data)
  return _msg;
}

// .service.BlendShapesData blendshapes_data = 7;
inline bool GetResponseResponse_AudioResponse::has_blendshapes_data() const {
  return face_data_type_case() == kBlendshapesData;
}
inline bool GetResponseResponse_AudioResponse::_internal_has_blendshapes_data() const {
  return face_data_type_case() == kBlendshapesData;
}
inline void GetResponseResponse_AudioResponse::set_has_blendshapes_data() {
  _impl_._oneof_case_[0] = kBlendshapesData;
}
inline void GetResponseResponse_AudioResponse::clear_blendshapes_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (face_data_type_case() == kBlendshapesData) {
    if (GetArena() == nullptr) {
      delete _impl_.face_data_type_.blendshapes_data_;
    }
    clear_has_face_data_type();
  }
}
inline ::service::BlendShapesData* GetResponseResponse_AudioResponse::release_blendshapes_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.AudioResponse.blendshapes_data)
  if (face_data_type_case() == kBlendshapesData) {
    clear_has_face_data_type();
    auto* temp = _impl_.face_data_type_.blendshapes_data_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.face_data_type_.blendshapes_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::BlendShapesData& GetResponseResponse_AudioResponse::_internal_blendshapes_data() const {
  return face_data_type_case() == kBlendshapesData ? *_impl_.face_data_type_.blendshapes_data_ : reinterpret_cast<::service::BlendShapesData&>(::service::_BlendShapesData_default_instance_);
}
inline const ::service::BlendShapesData& GetResponseResponse_AudioResponse::blendshapes_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.blendshapes_data)
  return _internal_blendshapes_data();
}
inline ::service::BlendShapesData* GetResponseResponse_AudioResponse::unsafe_arena_release_blendshapes_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseResponse.AudioResponse.blendshapes_data)
  if (face_data_type_case() == kBlendshapesData) {
    clear_has_face_data_type();
    auto* temp = _impl_.face_data_type_.blendshapes_data_;
    _impl_.face_data_type_.blendshapes_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse_AudioResponse::unsafe_arena_set_allocated_blendshapes_data(::service::BlendShapesData* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_face_data_type();
  if (value) {
    set_has_blendshapes_data();
    _impl_.face_data_type_.blendshapes_data_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.AudioResponse.blendshapes_data)
}
inline ::service::BlendShapesData* GetResponseResponse_AudioResponse::_internal_mutable_blendshapes_data() {
  if (face_data_type_case() != kBlendshapesData) {
    clear_face_data_type();
    set_has_blendshapes_data();
    _impl_.face_data_type_.blendshapes_data_ =
        ::google::protobuf::Message::DefaultConstruct<::service::BlendShapesData>(GetArena());
  }
  return _impl_.face_data_type_.blendshapes_data_;
}
inline ::service::BlendShapesData* GetResponseResponse_AudioResponse::mutable_blendshapes_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::service::BlendShapesData* _msg = _internal_mutable_blendshapes_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.AudioResponse.blendshapes_data)
  return _msg;
}

// .service.ARKitBlendShapesData face_emotion = 8;
inline bool GetResponseResponse_AudioResponse::has_face_emotion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.face_emotion_ != nullptr);
  return value;
}
inline const ::service::ARKitBlendShapesData& GetResponseResponse_AudioResponse::_internal_face_emotion() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::service::ARKitBlendShapesData* p = _impl_.face_emotion_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::ARKitBlendShapesData&>(::service::_ARKitBlendShapesData_default_instance_);
}
inline const ::service::ARKitBlendShapesData& GetResponseResponse_AudioResponse::face_emotion() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.face_emotion)
  return _internal_face_emotion();
}
inline void GetResponseResponse_AudioResponse::unsafe_arena_set_allocated_face_emotion(::service::ARKitBlendShapesData* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.face_emotion_);
  }
  _impl_.face_emotion_ = reinterpret_cast<::service::ARKitBlendShapesData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.AudioResponse.face_emotion)
}
inline ::service::ARKitBlendShapesData* GetResponseResponse_AudioResponse::release_face_emotion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::service::ARKitBlendShapesData* released = _impl_.face_emotion_;
  _impl_.face_emotion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::service::ARKitBlendShapesData* GetResponseResponse_AudioResponse::unsafe_arena_release_face_emotion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.AudioResponse.face_emotion)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::service::ARKitBlendShapesData* temp = _impl_.face_emotion_;
  _impl_.face_emotion_ = nullptr;
  return temp;
}
inline ::service::ARKitBlendShapesData* GetResponseResponse_AudioResponse::_internal_mutable_face_emotion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.face_emotion_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::service::ARKitBlendShapesData>(GetArena());
    _impl_.face_emotion_ = reinterpret_cast<::service::ARKitBlendShapesData*>(p);
  }
  return _impl_.face_emotion_;
}
inline ::service::ARKitBlendShapesData* GetResponseResponse_AudioResponse::mutable_face_emotion() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::service::ARKitBlendShapesData* _msg = _internal_mutable_face_emotion();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.AudioResponse.face_emotion)
  return _msg;
}
inline void GetResponseResponse_AudioResponse::set_allocated_face_emotion(::service::ARKitBlendShapesData* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.face_emotion_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.face_emotion_ = reinterpret_cast<::service::ARKitBlendShapesData*>(value);
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.AudioResponse.face_emotion)
}

// .service.EmotionResponse emotion_response = 9;
inline bool GetResponseResponse_AudioResponse::has_emotion_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.emotion_response_ != nullptr);
  return value;
}
inline void GetResponseResponse_AudioResponse::clear_emotion_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.emotion_response_ != nullptr) _impl_.emotion_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::service::EmotionResponse& GetResponseResponse_AudioResponse::_internal_emotion_response() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::service::EmotionResponse* p = _impl_.emotion_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::EmotionResponse&>(::service::_EmotionResponse_default_instance_);
}
inline const ::service::EmotionResponse& GetResponseResponse_AudioResponse::emotion_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.emotion_response)
  return _internal_emotion_response();
}
inline void GetResponseResponse_AudioResponse::unsafe_arena_set_allocated_emotion_response(::service::EmotionResponse* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.emotion_response_);
  }
  _impl_.emotion_response_ = reinterpret_cast<::service::EmotionResponse*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.AudioResponse.emotion_response)
}
inline ::service::EmotionResponse* GetResponseResponse_AudioResponse::release_emotion_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::service::EmotionResponse* released = _impl_.emotion_response_;
  _impl_.emotion_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::service::EmotionResponse* GetResponseResponse_AudioResponse::unsafe_arena_release_emotion_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.AudioResponse.emotion_response)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::service::EmotionResponse* temp = _impl_.emotion_response_;
  _impl_.emotion_response_ = nullptr;
  return temp;
}
inline ::service::EmotionResponse* GetResponseResponse_AudioResponse::_internal_mutable_emotion_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.emotion_response_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::service::EmotionResponse>(GetArena());
    _impl_.emotion_response_ = reinterpret_cast<::service::EmotionResponse*>(p);
  }
  return _impl_.emotion_response_;
}
inline ::service::EmotionResponse* GetResponseResponse_AudioResponse::mutable_emotion_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::service::EmotionResponse* _msg = _internal_mutable_emotion_response();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.AudioResponse.emotion_response)
  return _msg;
}
inline void GetResponseResponse_AudioResponse::set_allocated_emotion_response(::service::EmotionResponse* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.emotion_response_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.emotion_response_ = reinterpret_cast<::service::EmotionResponse*>(value);
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.AudioResponse.emotion_response)
}

inline bool GetResponseResponse_AudioResponse::has_face_data_type() const {
  return face_data_type_case() != FACE_DATA_TYPE_NOT_SET;
}
inline void GetResponseResponse_AudioResponse::clear_has_face_data_type() {
  _impl_._oneof_case_[0] = FACE_DATA_TYPE_NOT_SET;
}
inline GetResponseResponse_AudioResponse::FaceDataTypeCase GetResponseResponse_AudioResponse::face_data_type_case() const {
  return GetResponseResponse_AudioResponse::FaceDataTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetResponseResponse_ActionResponse

// string action = 1;
inline void GetResponseResponse_ActionResponse::clear_action() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.action_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_ActionResponse::action() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.ActionResponse.action)
  return _internal_action();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetResponseResponse_ActionResponse::set_action(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.action_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.ActionResponse.action)
}
inline std::string* GetResponseResponse_ActionResponse::mutable_action() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.ActionResponse.action)
  return _s;
}
inline const std::string& GetResponseResponse_ActionResponse::_internal_action() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.action_.Get();
}
inline void GetResponseResponse_ActionResponse::_internal_set_action(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.action_.Set(value, GetArena());
}
inline std::string* GetResponseResponse_ActionResponse::_internal_mutable_action() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.action_.Mutable( GetArena());
}
inline std::string* GetResponseResponse_ActionResponse::release_action() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.ActionResponse.action)
  return _impl_.action_.Release();
}
inline void GetResponseResponse_ActionResponse::set_allocated_action(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.action_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.action_.IsDefault()) {
          _impl_.action_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.ActionResponse.action)
}

// -------------------------------------------------------------------

// GetResponseResponse_BehaviorTreeResponse

// string bt_code = 1;
inline void GetResponseResponse_BehaviorTreeResponse::clear_bt_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bt_code_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_BehaviorTreeResponse::bt_code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.BehaviorTreeResponse.bt_code)
  return _internal_bt_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetResponseResponse_BehaviorTreeResponse::set_bt_code(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bt_code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.BehaviorTreeResponse.bt_code)
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::mutable_bt_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_bt_code();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.BehaviorTreeResponse.bt_code)
  return _s;
}
inline const std::string& GetResponseResponse_BehaviorTreeResponse::_internal_bt_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bt_code_.Get();
}
inline void GetResponseResponse_BehaviorTreeResponse::_internal_set_bt_code(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bt_code_.Set(value, GetArena());
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::_internal_mutable_bt_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.bt_code_.Mutable( GetArena());
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::release_bt_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.BehaviorTreeResponse.bt_code)
  return _impl_.bt_code_.Release();
}
inline void GetResponseResponse_BehaviorTreeResponse::set_allocated_bt_code(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bt_code_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.bt_code_.IsDefault()) {
          _impl_.bt_code_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.BehaviorTreeResponse.bt_code)
}

// string bt_constants = 2;
inline void GetResponseResponse_BehaviorTreeResponse::clear_bt_constants() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bt_constants_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_BehaviorTreeResponse::bt_constants() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.BehaviorTreeResponse.bt_constants)
  return _internal_bt_constants();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetResponseResponse_BehaviorTreeResponse::set_bt_constants(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bt_constants_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.BehaviorTreeResponse.bt_constants)
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::mutable_bt_constants() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_bt_constants();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.BehaviorTreeResponse.bt_constants)
  return _s;
}
inline const std::string& GetResponseResponse_BehaviorTreeResponse::_internal_bt_constants() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bt_constants_.Get();
}
inline void GetResponseResponse_BehaviorTreeResponse::_internal_set_bt_constants(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bt_constants_.Set(value, GetArena());
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::_internal_mutable_bt_constants() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.bt_constants_.Mutable( GetArena());
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::release_bt_constants() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.BehaviorTreeResponse.bt_constants)
  return _impl_.bt_constants_.Release();
}
inline void GetResponseResponse_BehaviorTreeResponse::set_allocated_bt_constants(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bt_constants_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.bt_constants_.IsDefault()) {
          _impl_.bt_constants_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.BehaviorTreeResponse.bt_constants)
}

// string narrative_section_id = 3;
inline void GetResponseResponse_BehaviorTreeResponse::clear_narrative_section_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.narrative_section_id_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_BehaviorTreeResponse::narrative_section_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.BehaviorTreeResponse.narrative_section_id)
  return _internal_narrative_section_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetResponseResponse_BehaviorTreeResponse::set_narrative_section_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.narrative_section_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.BehaviorTreeResponse.narrative_section_id)
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::mutable_narrative_section_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_narrative_section_id();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.BehaviorTreeResponse.narrative_section_id)
  return _s;
}
inline const std::string& GetResponseResponse_BehaviorTreeResponse::_internal_narrative_section_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.narrative_section_id_.Get();
}
inline void GetResponseResponse_BehaviorTreeResponse::_internal_set_narrative_section_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.narrative_section_id_.Set(value, GetArena());
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::_internal_mutable_narrative_section_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.narrative_section_id_.Mutable( GetArena());
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::release_narrative_section_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.BehaviorTreeResponse.narrative_section_id)
  return _impl_.narrative_section_id_.Release();
}
inline void GetResponseResponse_BehaviorTreeResponse::set_allocated_narrative_section_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.narrative_section_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.narrative_section_id_.IsDefault()) {
          _impl_.narrative_section_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.BehaviorTreeResponse.narrative_section_id)
}

// -------------------------------------------------------------------

// GetResponseResponse_UserTranscript

// string text_data = 1;
inline void GetResponseResponse_UserTranscript::clear_text_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_data_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_UserTranscript::text_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.UserTranscript.text_data)
  return _internal_text_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetResponseResponse_UserTranscript::set_text_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_data_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.UserTranscript.text_data)
}
inline std::string* GetResponseResponse_UserTranscript::mutable_text_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.UserTranscript.text_data)
  return _s;
}
inline const std::string& GetResponseResponse_UserTranscript::_internal_text_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_data_.Get();
}
inline void GetResponseResponse_UserTranscript::_internal_set_text_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_data_.Set(value, GetArena());
}
inline std::string* GetResponseResponse_UserTranscript::_internal_mutable_text_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.text_data_.Mutable( GetArena());
}
inline std::string* GetResponseResponse_UserTranscript::release_text_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.UserTranscript.text_data)
  return _impl_.text_data_.Release();
}
inline void GetResponseResponse_UserTranscript::set_allocated_text_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_data_.IsDefault()) {
          _impl_.text_data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.UserTranscript.text_data)
}

// bool is_final = 2;
inline void GetResponseResponse_UserTranscript::clear_is_final() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_final_ = false;
}
inline bool GetResponseResponse_UserTranscript::is_final() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.UserTranscript.is_final)
  return _internal_is_final();
}
inline void GetResponseResponse_UserTranscript::set_is_final(bool value) {
  _internal_set_is_final(value);
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.UserTranscript.is_final)
}
inline bool GetResponseResponse_UserTranscript::_internal_is_final() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_final_;
}
inline void GetResponseResponse_UserTranscript::_internal_set_is_final(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_final_ = value;
}

// bool end_of_response = 3;
inline void GetResponseResponse_UserTranscript::clear_end_of_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_of_response_ = false;
}
inline bool GetResponseResponse_UserTranscript::end_of_response() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.UserTranscript.end_of_response)
  return _internal_end_of_response();
}
inline void GetResponseResponse_UserTranscript::set_end_of_response(bool value) {
  _internal_set_end_of_response(value);
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.UserTranscript.end_of_response)
}
inline bool GetResponseResponse_UserTranscript::_internal_end_of_response() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_of_response_;
}
inline void GetResponseResponse_UserTranscript::_internal_set_end_of_response(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_of_response_ = value;
}

// -------------------------------------------------------------------

// GetResponseResponse

// string session_id = 1;
inline void GetResponseResponse::clear_session_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& GetResponseResponse::session_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.session_id)
  return _internal_session_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetResponseResponse::set_session_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.session_id)
}
inline std::string* GetResponseResponse::mutable_session_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.session_id)
  return _s;
}
inline const std::string& GetResponseResponse::_internal_session_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.session_id_.Get();
}
inline void GetResponseResponse::_internal_set_session_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_.Set(value, GetArena());
}
inline std::string* GetResponseResponse::_internal_mutable_session_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.session_id_.Mutable( GetArena());
}
inline std::string* GetResponseResponse::release_session_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.session_id)
  return _impl_.session_id_.Release();
}
inline void GetResponseResponse::set_allocated_session_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_id_.IsDefault()) {
          _impl_.session_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.session_id)
}

// .service.GetResponseResponse.ActionResponse action_response = 2;
inline bool GetResponseResponse::has_action_response() const {
  return response_type_case() == kActionResponse;
}
inline bool GetResponseResponse::_internal_has_action_response() const {
  return response_type_case() == kActionResponse;
}
inline void GetResponseResponse::set_has_action_response() {
  _impl_._oneof_case_[0] = kActionResponse;
}
inline void GetResponseResponse::clear_action_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (response_type_case() == kActionResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.response_type_.action_response_;
    }
    clear_has_response_type();
  }
}
inline ::service::GetResponseResponse_ActionResponse* GetResponseResponse::release_action_response() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.action_response)
  if (response_type_case() == kActionResponse) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.action_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.action_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::GetResponseResponse_ActionResponse& GetResponseResponse::_internal_action_response() const {
  return response_type_case() == kActionResponse ? *_impl_.response_type_.action_response_ : reinterpret_cast<::service::GetResponseResponse_ActionResponse&>(::service::_GetResponseResponse_ActionResponse_default_instance_);
}
inline const ::service::GetResponseResponse_ActionResponse& GetResponseResponse::action_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.action_response)
  return _internal_action_response();
}
inline ::service::GetResponseResponse_ActionResponse* GetResponseResponse::unsafe_arena_release_action_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseResponse.action_response)
  if (response_type_case() == kActionResponse) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.action_response_;
    _impl_.response_type_.action_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse::unsafe_arena_set_allocated_action_response(::service::GetResponseResponse_ActionResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_action_response();
    _impl_.response_type_.action_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.action_response)
}
inline ::service::GetResponseResponse_ActionResponse* GetResponseResponse::_internal_mutable_action_response() {
  if (response_type_case() != kActionResponse) {
    clear_response_type();
    set_has_action_response();
    _impl_.response_type_.action_response_ =
        ::google::protobuf::Message::DefaultConstruct<::service::GetResponseResponse_ActionResponse>(GetArena());
  }
  return _impl_.response_type_.action_response_;
}
inline ::service::GetResponseResponse_ActionResponse* GetResponseResponse::mutable_action_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::service::GetResponseResponse_ActionResponse* _msg = _internal_mutable_action_response();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.action_response)
  return _msg;
}

// .service.GetResponseResponse.AudioResponse audio_response = 3;
inline bool GetResponseResponse::has_audio_response() const {
  return response_type_case() == kAudioResponse;
}
inline bool GetResponseResponse::_internal_has_audio_response() const {
  return response_type_case() == kAudioResponse;
}
inline void GetResponseResponse::set_has_audio_response() {
  _impl_._oneof_case_[0] = kAudioResponse;
}
inline void GetResponseResponse::clear_audio_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (response_type_case() == kAudioResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.response_type_.audio_response_;
    }
    clear_has_response_type();
  }
}
inline ::service::GetResponseResponse_AudioResponse* GetResponseResponse::release_audio_response() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.audio_response)
  if (response_type_case() == kAudioResponse) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.audio_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.audio_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::GetResponseResponse_AudioResponse& GetResponseResponse::_internal_audio_response() const {
  return response_type_case() == kAudioResponse ? *_impl_.response_type_.audio_response_ : reinterpret_cast<::service::GetResponseResponse_AudioResponse&>(::service::_GetResponseResponse_AudioResponse_default_instance_);
}
inline const ::service::GetResponseResponse_AudioResponse& GetResponseResponse::audio_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.audio_response)
  return _internal_audio_response();
}
inline ::service::GetResponseResponse_AudioResponse* GetResponseResponse::unsafe_arena_release_audio_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseResponse.audio_response)
  if (response_type_case() == kAudioResponse) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.audio_response_;
    _impl_.response_type_.audio_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse::unsafe_arena_set_allocated_audio_response(::service::GetResponseResponse_AudioResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_audio_response();
    _impl_.response_type_.audio_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.audio_response)
}
inline ::service::GetResponseResponse_AudioResponse* GetResponseResponse::_internal_mutable_audio_response() {
  if (response_type_case() != kAudioResponse) {
    clear_response_type();
    set_has_audio_response();
    _impl_.response_type_.audio_response_ =
        ::google::protobuf::Message::DefaultConstruct<::service::GetResponseResponse_AudioResponse>(GetArena());
  }
  return _impl_.response_type_.audio_response_;
}
inline ::service::GetResponseResponse_AudioResponse* GetResponseResponse::mutable_audio_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::service::GetResponseResponse_AudioResponse* _msg = _internal_mutable_audio_response();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.audio_response)
  return _msg;
}

// string debug_log = 4;
inline bool GetResponseResponse::has_debug_log() const {
  return response_type_case() == kDebugLog;
}
inline void GetResponseResponse::set_has_debug_log() {
  _impl_._oneof_case_[0] = kDebugLog;
}
inline void GetResponseResponse::clear_debug_log() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (response_type_case() == kDebugLog) {
    _impl_.response_type_.debug_log_.Destroy();
    clear_has_response_type();
  }
}
inline const std::string& GetResponseResponse::debug_log() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.debug_log)
  return _internal_debug_log();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetResponseResponse::set_debug_log(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (response_type_case() != kDebugLog) {
    clear_response_type();

    set_has_debug_log();
    _impl_.response_type_.debug_log_.InitDefault();
  }
  _impl_.response_type_.debug_log_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.debug_log)
}
inline std::string* GetResponseResponse::mutable_debug_log() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_debug_log();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.debug_log)
  return _s;
}
inline const std::string& GetResponseResponse::_internal_debug_log() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (response_type_case() != kDebugLog) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.response_type_.debug_log_.Get();
}
inline void GetResponseResponse::_internal_set_debug_log(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (response_type_case() != kDebugLog) {
    clear_response_type();

    set_has_debug_log();
    _impl_.response_type_.debug_log_.InitDefault();
  }
  _impl_.response_type_.debug_log_.Set(value, GetArena());
}
inline std::string* GetResponseResponse::_internal_mutable_debug_log() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (response_type_case() != kDebugLog) {
    clear_response_type();

    set_has_debug_log();
    _impl_.response_type_.debug_log_.InitDefault();
  }
  return _impl_.response_type_.debug_log_.Mutable( GetArena());
}
inline std::string* GetResponseResponse::release_debug_log() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.debug_log)
  if (response_type_case() != kDebugLog) {
    return nullptr;
  }
  clear_has_response_type();
  return _impl_.response_type_.debug_log_.Release();
}
inline void GetResponseResponse::set_allocated_debug_log(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_response_type()) {
    clear_response_type();
  }
  if (value != nullptr) {
    set_has_debug_log();
    _impl_.response_type_.debug_log_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.debug_log)
}

// .service.GetResponseResponse.UserTranscript user_query = 5;
inline bool GetResponseResponse::has_user_query() const {
  return response_type_case() == kUserQuery;
}
inline bool GetResponseResponse::_internal_has_user_query() const {
  return response_type_case() == kUserQuery;
}
inline void GetResponseResponse::set_has_user_query() {
  _impl_._oneof_case_[0] = kUserQuery;
}
inline void GetResponseResponse::clear_user_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (response_type_case() == kUserQuery) {
    if (GetArena() == nullptr) {
      delete _impl_.response_type_.user_query_;
    }
    clear_has_response_type();
  }
}
inline ::service::GetResponseResponse_UserTranscript* GetResponseResponse::release_user_query() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.user_query)
  if (response_type_case() == kUserQuery) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.user_query_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.user_query_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::GetResponseResponse_UserTranscript& GetResponseResponse::_internal_user_query() const {
  return response_type_case() == kUserQuery ? *_impl_.response_type_.user_query_ : reinterpret_cast<::service::GetResponseResponse_UserTranscript&>(::service::_GetResponseResponse_UserTranscript_default_instance_);
}
inline const ::service::GetResponseResponse_UserTranscript& GetResponseResponse::user_query() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.user_query)
  return _internal_user_query();
}
inline ::service::GetResponseResponse_UserTranscript* GetResponseResponse::unsafe_arena_release_user_query() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseResponse.user_query)
  if (response_type_case() == kUserQuery) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.user_query_;
    _impl_.response_type_.user_query_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse::unsafe_arena_set_allocated_user_query(::service::GetResponseResponse_UserTranscript* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_user_query();
    _impl_.response_type_.user_query_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.user_query)
}
inline ::service::GetResponseResponse_UserTranscript* GetResponseResponse::_internal_mutable_user_query() {
  if (response_type_case() != kUserQuery) {
    clear_response_type();
    set_has_user_query();
    _impl_.response_type_.user_query_ =
        ::google::protobuf::Message::DefaultConstruct<::service::GetResponseResponse_UserTranscript>(GetArena());
  }
  return _impl_.response_type_.user_query_;
}
inline ::service::GetResponseResponse_UserTranscript* GetResponseResponse::mutable_user_query() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::service::GetResponseResponse_UserTranscript* _msg = _internal_mutable_user_query();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.user_query)
  return _msg;
}

// .service.GetResponseResponse.BehaviorTreeResponse bt_response = 6;
inline bool GetResponseResponse::has_bt_response() const {
  return response_type_case() == kBtResponse;
}
inline bool GetResponseResponse::_internal_has_bt_response() const {
  return response_type_case() == kBtResponse;
}
inline void GetResponseResponse::set_has_bt_response() {
  _impl_._oneof_case_[0] = kBtResponse;
}
inline void GetResponseResponse::clear_bt_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (response_type_case() == kBtResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.response_type_.bt_response_;
    }
    clear_has_response_type();
  }
}
inline ::service::GetResponseResponse_BehaviorTreeResponse* GetResponseResponse::release_bt_response() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.bt_response)
  if (response_type_case() == kBtResponse) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.bt_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.bt_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::GetResponseResponse_BehaviorTreeResponse& GetResponseResponse::_internal_bt_response() const {
  return response_type_case() == kBtResponse ? *_impl_.response_type_.bt_response_ : reinterpret_cast<::service::GetResponseResponse_BehaviorTreeResponse&>(::service::_GetResponseResponse_BehaviorTreeResponse_default_instance_);
}
inline const ::service::GetResponseResponse_BehaviorTreeResponse& GetResponseResponse::bt_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.bt_response)
  return _internal_bt_response();
}
inline ::service::GetResponseResponse_BehaviorTreeResponse* GetResponseResponse::unsafe_arena_release_bt_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseResponse.bt_response)
  if (response_type_case() == kBtResponse) {
    clear_has_response_type();
    auto* temp = _impl_.response_type_.bt_response_;
    _impl_.response_type_.bt_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse::unsafe_arena_set_allocated_bt_response(::service::GetResponseResponse_BehaviorTreeResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_bt_response();
    _impl_.response_type_.bt_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.bt_response)
}
inline ::service::GetResponseResponse_BehaviorTreeResponse* GetResponseResponse::_internal_mutable_bt_response() {
  if (response_type_case() != kBtResponse) {
    clear_response_type();
    set_has_bt_response();
    _impl_.response_type_.bt_response_ =
        ::google::protobuf::Message::DefaultConstruct<::service::GetResponseResponse_BehaviorTreeResponse>(GetArena());
  }
  return _impl_.response_type_.bt_response_;
}
inline ::service::GetResponseResponse_BehaviorTreeResponse* GetResponseResponse::mutable_bt_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::service::GetResponseResponse_BehaviorTreeResponse* _msg = _internal_mutable_bt_response();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.bt_response)
  return _msg;
}

// string emotion_response = 7;
inline bool GetResponseResponse::has_emotion_response() const {
  return response_type_case() == kEmotionResponse;
}
inline void GetResponseResponse::set_has_emotion_response() {
  _impl_._oneof_case_[0] = kEmotionResponse;
}
inline void GetResponseResponse::clear_emotion_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (response_type_case() == kEmotionResponse) {
    _impl_.response_type_.emotion_response_.Destroy();
    clear_has_response_type();
  }
}
inline const std::string& GetResponseResponse::emotion_response() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.emotion_response)
  return _internal_emotion_response();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetResponseResponse::set_emotion_response(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (response_type_case() != kEmotionResponse) {
    clear_response_type();

    set_has_emotion_response();
    _impl_.response_type_.emotion_response_.InitDefault();
  }
  _impl_.response_type_.emotion_response_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.emotion_response)
}
inline std::string* GetResponseResponse::mutable_emotion_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_emotion_response();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.emotion_response)
  return _s;
}
inline const std::string& GetResponseResponse::_internal_emotion_response() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (response_type_case() != kEmotionResponse) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.response_type_.emotion_response_.Get();
}
inline void GetResponseResponse::_internal_set_emotion_response(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (response_type_case() != kEmotionResponse) {
    clear_response_type();

    set_has_emotion_response();
    _impl_.response_type_.emotion_response_.InitDefault();
  }
  _impl_.response_type_.emotion_response_.Set(value, GetArena());
}
inline std::string* GetResponseResponse::_internal_mutable_emotion_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (response_type_case() != kEmotionResponse) {
    clear_response_type();

    set_has_emotion_response();
    _impl_.response_type_.emotion_response_.InitDefault();
  }
  return _impl_.response_type_.emotion_response_.Mutable( GetArena());
}
inline std::string* GetResponseResponse::release_emotion_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.emotion_response)
  if (response_type_case() != kEmotionResponse) {
    return nullptr;
  }
  clear_has_response_type();
  return _impl_.response_type_.emotion_response_.Release();
}
inline void GetResponseResponse::set_allocated_emotion_response(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_response_type()) {
    clear_response_type();
  }
  if (value != nullptr) {
    set_has_emotion_response();
    _impl_.response_type_.emotion_response_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.emotion_response)
}

// string interaction_id = 8;
inline bool GetResponseResponse::has_interaction_id() const {
  return response_type_case() == kInteractionId;
}
inline void GetResponseResponse::set_has_interaction_id() {
  _impl_._oneof_case_[0] = kInteractionId;
}
inline void GetResponseResponse::clear_interaction_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (response_type_case() == kInteractionId) {
    _impl_.response_type_.interaction_id_.Destroy();
    clear_has_response_type();
  }
}
inline const std::string& GetResponseResponse::interaction_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.interaction_id)
  return _internal_interaction_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetResponseResponse::set_interaction_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (response_type_case() != kInteractionId) {
    clear_response_type();

    set_has_interaction_id();
    _impl_.response_type_.interaction_id_.InitDefault();
  }
  _impl_.response_type_.interaction_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.interaction_id)
}
inline std::string* GetResponseResponse::mutable_interaction_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_interaction_id();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.interaction_id)
  return _s;
}
inline const std::string& GetResponseResponse::_internal_interaction_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (response_type_case() != kInteractionId) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.response_type_.interaction_id_.Get();
}
inline void GetResponseResponse::_internal_set_interaction_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (response_type_case() != kInteractionId) {
    clear_response_type();

    set_has_interaction_id();
    _impl_.response_type_.interaction_id_.InitDefault();
  }
  _impl_.response_type_.interaction_id_.Set(value, GetArena());
}
inline std::string* GetResponseResponse::_internal_mutable_interaction_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (response_type_case() != kInteractionId) {
    clear_response_type();

    set_has_interaction_id();
    _impl_.response_type_.interaction_id_.InitDefault();
  }
  return _impl_.response_type_.interaction_id_.Mutable( GetArena());
}
inline std::string* GetResponseResponse::release_interaction_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.interaction_id)
  if (response_type_case() != kInteractionId) {
    return nullptr;
  }
  clear_has_response_type();
  return _impl_.response_type_.interaction_id_.Release();
}
inline void GetResponseResponse::set_allocated_interaction_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_response_type()) {
    clear_response_type();
  }
  if (value != nullptr) {
    set_has_interaction_id();
    _impl_.response_type_.interaction_id_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.interaction_id)
}

inline bool GetResponseResponse::has_response_type() const {
  return response_type_case() != RESPONSE_TYPE_NOT_SET;
}
inline void GetResponseResponse::clear_has_response_type() {
  _impl_._oneof_case_[0] = RESPONSE_TYPE_NOT_SET;
}
inline GetResponseResponse::ResponseTypeCase GetResponseResponse::response_type_case() const {
  return GetResponseResponse::ResponseTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// VisemesData

// .service.Viseme visemes = 1;
inline bool VisemesData::has_visemes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.visemes_ != nullptr);
  return value;
}
inline void VisemesData::clear_visemes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.visemes_ != nullptr) _impl_.visemes_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::service::Viseme& VisemesData::_internal_visemes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::service::Viseme* p = _impl_.visemes_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::Viseme&>(::service::_Viseme_default_instance_);
}
inline const ::service::Viseme& VisemesData::visemes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.VisemesData.visemes)
  return _internal_visemes();
}
inline void VisemesData::unsafe_arena_set_allocated_visemes(::service::Viseme* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.visemes_);
  }
  _impl_.visemes_ = reinterpret_cast<::service::Viseme*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.VisemesData.visemes)
}
inline ::service::Viseme* VisemesData::release_visemes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::service::Viseme* released = _impl_.visemes_;
  _impl_.visemes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::service::Viseme* VisemesData::unsafe_arena_release_visemes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.VisemesData.visemes)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::service::Viseme* temp = _impl_.visemes_;
  _impl_.visemes_ = nullptr;
  return temp;
}
inline ::service::Viseme* VisemesData::_internal_mutable_visemes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.visemes_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::service::Viseme>(GetArena());
    _impl_.visemes_ = reinterpret_cast<::service::Viseme*>(p);
  }
  return _impl_.visemes_;
}
inline ::service::Viseme* VisemesData::mutable_visemes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::service::Viseme* _msg = _internal_mutable_visemes();
  // @@protoc_insertion_point(field_mutable:service.VisemesData.visemes)
  return _msg;
}
inline void VisemesData::set_allocated_visemes(::service::Viseme* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.visemes_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.visemes_ = reinterpret_cast<::service::Viseme*>(value);
  // @@protoc_insertion_point(field_set_allocated:service.VisemesData.visemes)
}

// -------------------------------------------------------------------

// EmotionResponse

// string emotion = 1;
inline void EmotionResponse::clear_emotion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.emotion_.ClearToEmpty();
}
inline const std::string& EmotionResponse::emotion() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.EmotionResponse.emotion)
  return _internal_emotion();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EmotionResponse::set_emotion(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.emotion_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.EmotionResponse.emotion)
}
inline std::string* EmotionResponse::mutable_emotion() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_emotion();
  // @@protoc_insertion_point(field_mutable:service.EmotionResponse.emotion)
  return _s;
}
inline const std::string& EmotionResponse::_internal_emotion() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.emotion_.Get();
}
inline void EmotionResponse::_internal_set_emotion(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.emotion_.Set(value, GetArena());
}
inline std::string* EmotionResponse::_internal_mutable_emotion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.emotion_.Mutable( GetArena());
}
inline std::string* EmotionResponse::release_emotion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.EmotionResponse.emotion)
  return _impl_.emotion_.Release();
}
inline void EmotionResponse::set_allocated_emotion(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.emotion_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.emotion_.IsDefault()) {
          _impl_.emotion_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.EmotionResponse.emotion)
}

// string scale = 2;
inline void EmotionResponse::clear_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.scale_.ClearToEmpty();
}
inline const std::string& EmotionResponse::scale() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.EmotionResponse.scale)
  return _internal_scale();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EmotionResponse::set_scale(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.scale_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.EmotionResponse.scale)
}
inline std::string* EmotionResponse::mutable_scale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_scale();
  // @@protoc_insertion_point(field_mutable:service.EmotionResponse.scale)
  return _s;
}
inline const std::string& EmotionResponse::_internal_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.scale_.Get();
}
inline void EmotionResponse::_internal_set_scale(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.scale_.Set(value, GetArena());
}
inline std::string* EmotionResponse::_internal_mutable_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.scale_.Mutable( GetArena());
}
inline std::string* EmotionResponse::release_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.EmotionResponse.scale)
  return _impl_.scale_.Release();
}
inline void EmotionResponse::set_allocated_scale(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.scale_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.scale_.IsDefault()) {
          _impl_.scale_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.EmotionResponse.scale)
}

// -------------------------------------------------------------------

// Viseme

// float sil = 1;
inline void Viseme::clear_sil() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sil_ = 0;
}
inline float Viseme::sil() const {
  // @@protoc_insertion_point(field_get:service.Viseme.sil)
  return _internal_sil();
}
inline void Viseme::set_sil(float value) {
  _internal_set_sil(value);
  // @@protoc_insertion_point(field_set:service.Viseme.sil)
}
inline float Viseme::_internal_sil() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sil_;
}
inline void Viseme::_internal_set_sil(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sil_ = value;
}

// float pp = 2;
inline void Viseme::clear_pp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pp_ = 0;
}
inline float Viseme::pp() const {
  // @@protoc_insertion_point(field_get:service.Viseme.pp)
  return _internal_pp();
}
inline void Viseme::set_pp(float value) {
  _internal_set_pp(value);
  // @@protoc_insertion_point(field_set:service.Viseme.pp)
}
inline float Viseme::_internal_pp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pp_;
}
inline void Viseme::_internal_set_pp(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pp_ = value;
}

// float ff = 3;
inline void Viseme::clear_ff() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ff_ = 0;
}
inline float Viseme::ff() const {
  // @@protoc_insertion_point(field_get:service.Viseme.ff)
  return _internal_ff();
}
inline void Viseme::set_ff(float value) {
  _internal_set_ff(value);
  // @@protoc_insertion_point(field_set:service.Viseme.ff)
}
inline float Viseme::_internal_ff() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ff_;
}
inline void Viseme::_internal_set_ff(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ff_ = value;
}

// float th = 4;
inline void Viseme::clear_th() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.th_ = 0;
}
inline float Viseme::th() const {
  // @@protoc_insertion_point(field_get:service.Viseme.th)
  return _internal_th();
}
inline void Viseme::set_th(float value) {
  _internal_set_th(value);
  // @@protoc_insertion_point(field_set:service.Viseme.th)
}
inline float Viseme::_internal_th() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.th_;
}
inline void Viseme::_internal_set_th(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.th_ = value;
}

// float dd = 5;
inline void Viseme::clear_dd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dd_ = 0;
}
inline float Viseme::dd() const {
  // @@protoc_insertion_point(field_get:service.Viseme.dd)
  return _internal_dd();
}
inline void Viseme::set_dd(float value) {
  _internal_set_dd(value);
  // @@protoc_insertion_point(field_set:service.Viseme.dd)
}
inline float Viseme::_internal_dd() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dd_;
}
inline void Viseme::_internal_set_dd(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dd_ = value;
}

// float kk = 6;
inline void Viseme::clear_kk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kk_ = 0;
}
inline float Viseme::kk() const {
  // @@protoc_insertion_point(field_get:service.Viseme.kk)
  return _internal_kk();
}
inline void Viseme::set_kk(float value) {
  _internal_set_kk(value);
  // @@protoc_insertion_point(field_set:service.Viseme.kk)
}
inline float Viseme::_internal_kk() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kk_;
}
inline void Viseme::_internal_set_kk(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kk_ = value;
}

// float ch = 7;
inline void Viseme::clear_ch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ch_ = 0;
}
inline float Viseme::ch() const {
  // @@protoc_insertion_point(field_get:service.Viseme.ch)
  return _internal_ch();
}
inline void Viseme::set_ch(float value) {
  _internal_set_ch(value);
  // @@protoc_insertion_point(field_set:service.Viseme.ch)
}
inline float Viseme::_internal_ch() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ch_;
}
inline void Viseme::_internal_set_ch(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ch_ = value;
}

// float ss = 8;
inline void Viseme::clear_ss() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ss_ = 0;
}
inline float Viseme::ss() const {
  // @@protoc_insertion_point(field_get:service.Viseme.ss)
  return _internal_ss();
}
inline void Viseme::set_ss(float value) {
  _internal_set_ss(value);
  // @@protoc_insertion_point(field_set:service.Viseme.ss)
}
inline float Viseme::_internal_ss() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ss_;
}
inline void Viseme::_internal_set_ss(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ss_ = value;
}

// float nn = 9;
inline void Viseme::clear_nn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nn_ = 0;
}
inline float Viseme::nn() const {
  // @@protoc_insertion_point(field_get:service.Viseme.nn)
  return _internal_nn();
}
inline void Viseme::set_nn(float value) {
  _internal_set_nn(value);
  // @@protoc_insertion_point(field_set:service.Viseme.nn)
}
inline float Viseme::_internal_nn() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nn_;
}
inline void Viseme::_internal_set_nn(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nn_ = value;
}

// float rr = 10;
inline void Viseme::clear_rr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rr_ = 0;
}
inline float Viseme::rr() const {
  // @@protoc_insertion_point(field_get:service.Viseme.rr)
  return _internal_rr();
}
inline void Viseme::set_rr(float value) {
  _internal_set_rr(value);
  // @@protoc_insertion_point(field_set:service.Viseme.rr)
}
inline float Viseme::_internal_rr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rr_;
}
inline void Viseme::_internal_set_rr(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rr_ = value;
}

// float aa = 11;
inline void Viseme::clear_aa() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.aa_ = 0;
}
inline float Viseme::aa() const {
  // @@protoc_insertion_point(field_get:service.Viseme.aa)
  return _internal_aa();
}
inline void Viseme::set_aa(float value) {
  _internal_set_aa(value);
  // @@protoc_insertion_point(field_set:service.Viseme.aa)
}
inline float Viseme::_internal_aa() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.aa_;
}
inline void Viseme::_internal_set_aa(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.aa_ = value;
}

// float e = 12;
inline void Viseme::clear_e() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.e_ = 0;
}
inline float Viseme::e() const {
  // @@protoc_insertion_point(field_get:service.Viseme.e)
  return _internal_e();
}
inline void Viseme::set_e(float value) {
  _internal_set_e(value);
  // @@protoc_insertion_point(field_set:service.Viseme.e)
}
inline float Viseme::_internal_e() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.e_;
}
inline void Viseme::_internal_set_e(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.e_ = value;
}

// float ih = 13;
inline void Viseme::clear_ih() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ih_ = 0;
}
inline float Viseme::ih() const {
  // @@protoc_insertion_point(field_get:service.Viseme.ih)
  return _internal_ih();
}
inline void Viseme::set_ih(float value) {
  _internal_set_ih(value);
  // @@protoc_insertion_point(field_set:service.Viseme.ih)
}
inline float Viseme::_internal_ih() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ih_;
}
inline void Viseme::_internal_set_ih(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ih_ = value;
}

// float oh = 14;
inline void Viseme::clear_oh() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.oh_ = 0;
}
inline float Viseme::oh() const {
  // @@protoc_insertion_point(field_get:service.Viseme.oh)
  return _internal_oh();
}
inline void Viseme::set_oh(float value) {
  _internal_set_oh(value);
  // @@protoc_insertion_point(field_set:service.Viseme.oh)
}
inline float Viseme::_internal_oh() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.oh_;
}
inline void Viseme::_internal_set_oh(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.oh_ = value;
}

// float ou = 15;
inline void Viseme::clear_ou() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ou_ = 0;
}
inline float Viseme::ou() const {
  // @@protoc_insertion_point(field_get:service.Viseme.ou)
  return _internal_ou();
}
inline void Viseme::set_ou(float value) {
  _internal_set_ou(value);
  // @@protoc_insertion_point(field_set:service.Viseme.ou)
}
inline float Viseme::_internal_ou() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ou_;
}
inline void Viseme::_internal_set_ou(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ou_ = value;
}

// -------------------------------------------------------------------

// BlendShapesData

// string blendshape_data = 1;
inline void BlendShapesData::clear_blendshape_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.blendshape_data_.ClearToEmpty();
}
inline const std::string& BlendShapesData::blendshape_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.BlendShapesData.blendshape_data)
  return _internal_blendshape_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlendShapesData::set_blendshape_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.blendshape_data_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.BlendShapesData.blendshape_data)
}
inline std::string* BlendShapesData::mutable_blendshape_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_blendshape_data();
  // @@protoc_insertion_point(field_mutable:service.BlendShapesData.blendshape_data)
  return _s;
}
inline const std::string& BlendShapesData::_internal_blendshape_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.blendshape_data_.Get();
}
inline void BlendShapesData::_internal_set_blendshape_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.blendshape_data_.Set(value, GetArena());
}
inline std::string* BlendShapesData::_internal_mutable_blendshape_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.blendshape_data_.Mutable( GetArena());
}
inline std::string* BlendShapesData::release_blendshape_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.BlendShapesData.blendshape_data)
  return _impl_.blendshape_data_.Release();
}
inline void BlendShapesData::set_allocated_blendshape_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.blendshape_data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.blendshape_data_.IsDefault()) {
          _impl_.blendshape_data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.BlendShapesData.blendshape_data)
}

// -------------------------------------------------------------------

// HelloRequest

// string name = 1;
inline void HelloRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& HelloRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.HelloRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HelloRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.HelloRequest.name)
}
inline std::string* HelloRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:service.HelloRequest.name)
  return _s;
}
inline const std::string& HelloRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void HelloRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* HelloRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* HelloRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.HelloRequest.name)
  return _impl_.name_.Release();
}
inline void HelloRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.HelloRequest.name)
}

// -------------------------------------------------------------------

// HelloResponse

// string message = 1;
inline void HelloResponse::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& HelloResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.HelloResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HelloResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.HelloResponse.message)
}
inline std::string* HelloResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:service.HelloResponse.message)
  return _s;
}
inline const std::string& HelloResponse::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void HelloResponse::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.Set(value, GetArena());
}
inline std::string* HelloResponse::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* HelloResponse::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.HelloResponse.message)
  return _impl_.message_.Release();
}
inline void HelloResponse::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.HelloResponse.message)
}

// -------------------------------------------------------------------

// FeedbackRequest_Feedback

// bool thumbs_up = 1;
inline void FeedbackRequest_Feedback::clear_thumbs_up() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.thumbs_up_ = false;
}
inline bool FeedbackRequest_Feedback::thumbs_up() const {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.Feedback.thumbs_up)
  return _internal_thumbs_up();
}
inline void FeedbackRequest_Feedback::set_thumbs_up(bool value) {
  _internal_set_thumbs_up(value);
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.Feedback.thumbs_up)
}
inline bool FeedbackRequest_Feedback::_internal_thumbs_up() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.thumbs_up_;
}
inline void FeedbackRequest_Feedback::_internal_set_thumbs_up(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.thumbs_up_ = value;
}

// string feedback_text = 2;
inline void FeedbackRequest_Feedback::clear_feedback_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.feedback_text_.ClearToEmpty();
}
inline const std::string& FeedbackRequest_Feedback::feedback_text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.Feedback.feedback_text)
  return _internal_feedback_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FeedbackRequest_Feedback::set_feedback_text(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.feedback_text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.Feedback.feedback_text)
}
inline std::string* FeedbackRequest_Feedback::mutable_feedback_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_feedback_text();
  // @@protoc_insertion_point(field_mutable:service.FeedbackRequest.Feedback.feedback_text)
  return _s;
}
inline const std::string& FeedbackRequest_Feedback::_internal_feedback_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.feedback_text_.Get();
}
inline void FeedbackRequest_Feedback::_internal_set_feedback_text(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.feedback_text_.Set(value, GetArena());
}
inline std::string* FeedbackRequest_Feedback::_internal_mutable_feedback_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.feedback_text_.Mutable( GetArena());
}
inline std::string* FeedbackRequest_Feedback::release_feedback_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.FeedbackRequest.Feedback.feedback_text)
  return _impl_.feedback_text_.Release();
}
inline void FeedbackRequest_Feedback::set_allocated_feedback_text(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.feedback_text_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.feedback_text_.IsDefault()) {
          _impl_.feedback_text_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.FeedbackRequest.Feedback.feedback_text)
}

// repeated string tags = 3;
inline int FeedbackRequest_Feedback::_internal_tags_size() const {
  return _internal_tags().size();
}
inline int FeedbackRequest_Feedback::tags_size() const {
  return _internal_tags_size();
}
inline void FeedbackRequest_Feedback::clear_tags() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tags_.Clear();
}
inline std::string* FeedbackRequest_Feedback::add_tags()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_tags()->Add();
  // @@protoc_insertion_point(field_add_mutable:service.FeedbackRequest.Feedback.tags)
  return _s;
}
inline const std::string& FeedbackRequest_Feedback::tags(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.Feedback.tags)
  return _internal_tags().Get(index);
}
inline std::string* FeedbackRequest_Feedback::mutable_tags(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:service.FeedbackRequest.Feedback.tags)
  return _internal_mutable_tags()->Mutable(index);
}
inline void FeedbackRequest_Feedback::set_tags(int index, const std::string& value) {
  _internal_mutable_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.Feedback.tags)
}
inline void FeedbackRequest_Feedback::set_tags(int index, std::string&& value) {
  _internal_mutable_tags()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.Feedback.tags)
}
inline void FeedbackRequest_Feedback::set_tags(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:service.FeedbackRequest.Feedback.tags)
}
inline void FeedbackRequest_Feedback::set_tags(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_tags()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:service.FeedbackRequest.Feedback.tags)
}
inline void FeedbackRequest_Feedback::set_tags(int index, absl::string_view value) {
  _internal_mutable_tags()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:service.FeedbackRequest.Feedback.tags)
}
inline void FeedbackRequest_Feedback::add_tags(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:service.FeedbackRequest.Feedback.tags)
}
inline void FeedbackRequest_Feedback::add_tags(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:service.FeedbackRequest.Feedback.tags)
}
inline void FeedbackRequest_Feedback::add_tags(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:service.FeedbackRequest.Feedback.tags)
}
inline void FeedbackRequest_Feedback::add_tags(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:service.FeedbackRequest.Feedback.tags)
}
inline void FeedbackRequest_Feedback::add_tags(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_tags()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:service.FeedbackRequest.Feedback.tags)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
FeedbackRequest_Feedback::tags() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:service.FeedbackRequest.Feedback.tags)
  return _internal_tags();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
FeedbackRequest_Feedback::mutable_tags() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:service.FeedbackRequest.Feedback.tags)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tags();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
FeedbackRequest_Feedback::_internal_tags() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tags_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
FeedbackRequest_Feedback::_internal_mutable_tags() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tags_;
}

// bool is_test_case = 4;
inline void FeedbackRequest_Feedback::clear_is_test_case() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_test_case_ = false;
}
inline bool FeedbackRequest_Feedback::is_test_case() const {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.Feedback.is_test_case)
  return _internal_is_test_case();
}
inline void FeedbackRequest_Feedback::set_is_test_case(bool value) {
  _internal_set_is_test_case(value);
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.Feedback.is_test_case)
}
inline bool FeedbackRequest_Feedback::_internal_is_test_case() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_test_case_;
}
inline void FeedbackRequest_Feedback::_internal_set_is_test_case(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_test_case_ = value;
}

// -------------------------------------------------------------------

// FeedbackRequest

// string interaction_id = 1;
inline void FeedbackRequest::clear_interaction_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interaction_id_.ClearToEmpty();
}
inline const std::string& FeedbackRequest::interaction_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.interaction_id)
  return _internal_interaction_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FeedbackRequest::set_interaction_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interaction_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.interaction_id)
}
inline std::string* FeedbackRequest::mutable_interaction_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_interaction_id();
  // @@protoc_insertion_point(field_mutable:service.FeedbackRequest.interaction_id)
  return _s;
}
inline const std::string& FeedbackRequest::_internal_interaction_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.interaction_id_.Get();
}
inline void FeedbackRequest::_internal_set_interaction_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interaction_id_.Set(value, GetArena());
}
inline std::string* FeedbackRequest::_internal_mutable_interaction_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.interaction_id_.Mutable( GetArena());
}
inline std::string* FeedbackRequest::release_interaction_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.FeedbackRequest.interaction_id)
  return _impl_.interaction_id_.Release();
}
inline void FeedbackRequest::set_allocated_interaction_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interaction_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.interaction_id_.IsDefault()) {
          _impl_.interaction_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.FeedbackRequest.interaction_id)
}

// string character_id = 2;
inline void FeedbackRequest::clear_character_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.character_id_.ClearToEmpty();
}
inline const std::string& FeedbackRequest::character_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.character_id)
  return _internal_character_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FeedbackRequest::set_character_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.character_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.character_id)
}
inline std::string* FeedbackRequest::mutable_character_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_character_id();
  // @@protoc_insertion_point(field_mutable:service.FeedbackRequest.character_id)
  return _s;
}
inline const std::string& FeedbackRequest::_internal_character_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.character_id_.Get();
}
inline void FeedbackRequest::_internal_set_character_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.character_id_.Set(value, GetArena());
}
inline std::string* FeedbackRequest::_internal_mutable_character_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.character_id_.Mutable( GetArena());
}
inline std::string* FeedbackRequest::release_character_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.FeedbackRequest.character_id)
  return _impl_.character_id_.Release();
}
inline void FeedbackRequest::set_allocated_character_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.character_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.character_id_.IsDefault()) {
          _impl_.character_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.FeedbackRequest.character_id)
}

// string session_id = 3;
inline void FeedbackRequest::clear_session_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& FeedbackRequest::session_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.session_id)
  return _internal_session_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FeedbackRequest::set_session_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.session_id)
}
inline std::string* FeedbackRequest::mutable_session_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:service.FeedbackRequest.session_id)
  return _s;
}
inline const std::string& FeedbackRequest::_internal_session_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.session_id_.Get();
}
inline void FeedbackRequest::_internal_set_session_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_.Set(value, GetArena());
}
inline std::string* FeedbackRequest::_internal_mutable_session_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.session_id_.Mutable( GetArena());
}
inline std::string* FeedbackRequest::release_session_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.FeedbackRequest.session_id)
  return _impl_.session_id_.Release();
}
inline void FeedbackRequest::set_allocated_session_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_id_.IsDefault()) {
          _impl_.session_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.FeedbackRequest.session_id)
}

// .service.FeedbackRequest.Feedback text_feedback = 5;
inline bool FeedbackRequest::has_text_feedback() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.text_feedback_ != nullptr);
  return value;
}
inline void FeedbackRequest::clear_text_feedback() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.text_feedback_ != nullptr) _impl_.text_feedback_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::service::FeedbackRequest_Feedback& FeedbackRequest::_internal_text_feedback() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::service::FeedbackRequest_Feedback* p = _impl_.text_feedback_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::FeedbackRequest_Feedback&>(::service::_FeedbackRequest_Feedback_default_instance_);
}
inline const ::service::FeedbackRequest_Feedback& FeedbackRequest::text_feedback() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.text_feedback)
  return _internal_text_feedback();
}
inline void FeedbackRequest::unsafe_arena_set_allocated_text_feedback(::service::FeedbackRequest_Feedback* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.text_feedback_);
  }
  _impl_.text_feedback_ = reinterpret_cast<::service::FeedbackRequest_Feedback*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.FeedbackRequest.text_feedback)
}
inline ::service::FeedbackRequest_Feedback* FeedbackRequest::release_text_feedback() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::service::FeedbackRequest_Feedback* released = _impl_.text_feedback_;
  _impl_.text_feedback_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::service::FeedbackRequest_Feedback* FeedbackRequest::unsafe_arena_release_text_feedback() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.FeedbackRequest.text_feedback)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::service::FeedbackRequest_Feedback* temp = _impl_.text_feedback_;
  _impl_.text_feedback_ = nullptr;
  return temp;
}
inline ::service::FeedbackRequest_Feedback* FeedbackRequest::_internal_mutable_text_feedback() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.text_feedback_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::service::FeedbackRequest_Feedback>(GetArena());
    _impl_.text_feedback_ = reinterpret_cast<::service::FeedbackRequest_Feedback*>(p);
  }
  return _impl_.text_feedback_;
}
inline ::service::FeedbackRequest_Feedback* FeedbackRequest::mutable_text_feedback() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::service::FeedbackRequest_Feedback* _msg = _internal_mutable_text_feedback();
  // @@protoc_insertion_point(field_mutable:service.FeedbackRequest.text_feedback)
  return _msg;
}
inline void FeedbackRequest::set_allocated_text_feedback(::service::FeedbackRequest_Feedback* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.text_feedback_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.text_feedback_ = reinterpret_cast<::service::FeedbackRequest_Feedback*>(value);
  // @@protoc_insertion_point(field_set_allocated:service.FeedbackRequest.text_feedback)
}

// string user_query = 6;
inline void FeedbackRequest::clear_user_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_query_.ClearToEmpty();
}
inline const std::string& FeedbackRequest::user_query() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.user_query)
  return _internal_user_query();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FeedbackRequest::set_user_query(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_query_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.user_query)
}
inline std::string* FeedbackRequest::mutable_user_query() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_query();
  // @@protoc_insertion_point(field_mutable:service.FeedbackRequest.user_query)
  return _s;
}
inline const std::string& FeedbackRequest::_internal_user_query() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_query_.Get();
}
inline void FeedbackRequest::_internal_set_user_query(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_query_.Set(value, GetArena());
}
inline std::string* FeedbackRequest::_internal_mutable_user_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.user_query_.Mutable( GetArena());
}
inline std::string* FeedbackRequest::release_user_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.FeedbackRequest.user_query)
  return _impl_.user_query_.Release();
}
inline void FeedbackRequest::set_allocated_user_query(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_query_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_query_.IsDefault()) {
          _impl_.user_query_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.FeedbackRequest.user_query)
}

// string response = 7;
inline void FeedbackRequest::clear_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.response_.ClearToEmpty();
}
inline const std::string& FeedbackRequest::response() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.response)
  return _internal_response();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FeedbackRequest::set_response(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.response_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.response)
}
inline std::string* FeedbackRequest::mutable_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:service.FeedbackRequest.response)
  return _s;
}
inline const std::string& FeedbackRequest::_internal_response() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.response_.Get();
}
inline void FeedbackRequest::_internal_set_response(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.response_.Set(value, GetArena());
}
inline std::string* FeedbackRequest::_internal_mutable_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.response_.Mutable( GetArena());
}
inline std::string* FeedbackRequest::release_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.FeedbackRequest.response)
  return _impl_.response_.Release();
}
inline void FeedbackRequest::set_allocated_response(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.response_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.response_.IsDefault()) {
          _impl_.response_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.FeedbackRequest.response)
}

// -------------------------------------------------------------------

// FeedbackResponse

// string feedback_response = 1;
inline void FeedbackResponse::clear_feedback_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.feedback_response_.ClearToEmpty();
}
inline const std::string& FeedbackResponse::feedback_response() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:service.FeedbackResponse.feedback_response)
  return _internal_feedback_response();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FeedbackResponse::set_feedback_response(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.feedback_response_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:service.FeedbackResponse.feedback_response)
}
inline std::string* FeedbackResponse::mutable_feedback_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_feedback_response();
  // @@protoc_insertion_point(field_mutable:service.FeedbackResponse.feedback_response)
  return _s;
}
inline const std::string& FeedbackResponse::_internal_feedback_response() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.feedback_response_.Get();
}
inline void FeedbackResponse::_internal_set_feedback_response(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.feedback_response_.Set(value, GetArena());
}
inline std::string* FeedbackResponse::_internal_mutable_feedback_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.feedback_response_.Mutable( GetArena());
}
inline std::string* FeedbackResponse::release_feedback_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:service.FeedbackResponse.feedback_response)
  return _impl_.feedback_response_.Release();
}
inline void FeedbackResponse::set_allocated_feedback_response(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.feedback_response_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.feedback_response_.IsDefault()) {
          _impl_.feedback_response_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.FeedbackResponse.feedback_response)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace service


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::service::FaceModel> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::service::FaceModel>() {
  return ::service::FaceModel_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_service_2eproto_2epb_2eh
#else
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_service_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_service_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "arkit_blend_shapes.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_service_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_service_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_service_2eproto;
namespace service {
class ActionConfig;
struct ActionConfigDefaultTypeInternal;
extern ActionConfigDefaultTypeInternal _ActionConfig_default_instance_;
class ActionConfig_Character;
struct ActionConfig_CharacterDefaultTypeInternal;
extern ActionConfig_CharacterDefaultTypeInternal _ActionConfig_Character_default_instance_;
class ActionConfig_Object;
struct ActionConfig_ObjectDefaultTypeInternal;
extern ActionConfig_ObjectDefaultTypeInternal _ActionConfig_Object_default_instance_;
class AudioConfig;
struct AudioConfigDefaultTypeInternal;
extern AudioConfigDefaultTypeInternal _AudioConfig_default_instance_;
class BlendShapesData;
struct BlendShapesDataDefaultTypeInternal;
extern BlendShapesDataDefaultTypeInternal _BlendShapesData_default_instance_;
class DynamicInfoConfig;
struct DynamicInfoConfigDefaultTypeInternal;
extern DynamicInfoConfigDefaultTypeInternal _DynamicInfoConfig_default_instance_;
class EmotionResponse;
struct EmotionResponseDefaultTypeInternal;
extern EmotionResponseDefaultTypeInternal _EmotionResponse_default_instance_;
class FeedbackRequest;
struct FeedbackRequestDefaultTypeInternal;
extern FeedbackRequestDefaultTypeInternal _FeedbackRequest_default_instance_;
class FeedbackRequest_Feedback;
struct FeedbackRequest_FeedbackDefaultTypeInternal;
extern FeedbackRequest_FeedbackDefaultTypeInternal _FeedbackRequest_Feedback_default_instance_;
class FeedbackResponse;
struct FeedbackResponseDefaultTypeInternal;
extern FeedbackResponseDefaultTypeInternal _FeedbackResponse_default_instance_;
class GetResponseRequest;
struct GetResponseRequestDefaultTypeInternal;
extern GetResponseRequestDefaultTypeInternal _GetResponseRequest_default_instance_;
class GetResponseRequestSingle;
struct GetResponseRequestSingleDefaultTypeInternal;
extern GetResponseRequestSingleDefaultTypeInternal _GetResponseRequestSingle_default_instance_;
class GetResponseRequest_GetResponseConfig;
struct GetResponseRequest_GetResponseConfigDefaultTypeInternal;
extern GetResponseRequest_GetResponseConfigDefaultTypeInternal _GetResponseRequest_GetResponseConfig_default_instance_;
class GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUse;
struct GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUseDefaultTypeInternal;
extern GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUseDefaultTypeInternal _GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUse_default_instance_;
class GetResponseRequest_GetResponseData;
struct GetResponseRequest_GetResponseDataDefaultTypeInternal;
extern GetResponseRequest_GetResponseDataDefaultTypeInternal _GetResponseRequest_GetResponseData_default_instance_;
class GetResponseResponse;
struct GetResponseResponseDefaultTypeInternal;
extern GetResponseResponseDefaultTypeInternal _GetResponseResponse_default_instance_;
class GetResponseResponse_ActionResponse;
struct GetResponseResponse_ActionResponseDefaultTypeInternal;
extern GetResponseResponse_ActionResponseDefaultTypeInternal _GetResponseResponse_ActionResponse_default_instance_;
class GetResponseResponse_AudioResponse;
struct GetResponseResponse_AudioResponseDefaultTypeInternal;
extern GetResponseResponse_AudioResponseDefaultTypeInternal _GetResponseResponse_AudioResponse_default_instance_;
class GetResponseResponse_BehaviorTreeResponse;
struct GetResponseResponse_BehaviorTreeResponseDefaultTypeInternal;
extern GetResponseResponse_BehaviorTreeResponseDefaultTypeInternal _GetResponseResponse_BehaviorTreeResponse_default_instance_;
class GetResponseResponse_UserTranscript;
struct GetResponseResponse_UserTranscriptDefaultTypeInternal;
extern GetResponseResponse_UserTranscriptDefaultTypeInternal _GetResponseResponse_UserTranscript_default_instance_;
class HelloRequest;
struct HelloRequestDefaultTypeInternal;
extern HelloRequestDefaultTypeInternal _HelloRequest_default_instance_;
class HelloResponse;
struct HelloResponseDefaultTypeInternal;
extern HelloResponseDefaultTypeInternal _HelloResponse_default_instance_;
class STTRequest;
struct STTRequestDefaultTypeInternal;
extern STTRequestDefaultTypeInternal _STTRequest_default_instance_;
class STTResponse;
struct STTResponseDefaultTypeInternal;
extern STTResponseDefaultTypeInternal _STTResponse_default_instance_;
class TriggerConfig;
struct TriggerConfigDefaultTypeInternal;
extern TriggerConfigDefaultTypeInternal _TriggerConfig_default_instance_;
class Viseme;
struct VisemeDefaultTypeInternal;
extern VisemeDefaultTypeInternal _Viseme_default_instance_;
class VisemesData;
struct VisemesDataDefaultTypeInternal;
extern VisemesDataDefaultTypeInternal _VisemesData_default_instance_;
class VisionInput;
struct VisionInputDefaultTypeInternal;
extern VisionInputDefaultTypeInternal _VisionInput_default_instance_;
class VisionInput_ImageData;
struct VisionInput_ImageDataDefaultTypeInternal;
extern VisionInput_ImageDataDefaultTypeInternal _VisionInput_ImageData_default_instance_;
class VisionInput_VideoData;
struct VisionInput_VideoDataDefaultTypeInternal;
extern VisionInput_VideoDataDefaultTypeInternal _VisionInput_VideoData_default_instance_;
}  // namespace service
PROTOBUF_NAMESPACE_OPEN
template<> ::service::ActionConfig* Arena::CreateMaybeMessage<::service::ActionConfig>(Arena*);
template<> ::service::ActionConfig_Character* Arena::CreateMaybeMessage<::service::ActionConfig_Character>(Arena*);
template<> ::service::ActionConfig_Object* Arena::CreateMaybeMessage<::service::ActionConfig_Object>(Arena*);
template<> ::service::AudioConfig* Arena::CreateMaybeMessage<::service::AudioConfig>(Arena*);
template<> ::service::BlendShapesData* Arena::CreateMaybeMessage<::service::BlendShapesData>(Arena*);
template<> ::service::DynamicInfoConfig* Arena::CreateMaybeMessage<::service::DynamicInfoConfig>(Arena*);
template<> ::service::EmotionResponse* Arena::CreateMaybeMessage<::service::EmotionResponse>(Arena*);
template<> ::service::FeedbackRequest* Arena::CreateMaybeMessage<::service::FeedbackRequest>(Arena*);
template<> ::service::FeedbackRequest_Feedback* Arena::CreateMaybeMessage<::service::FeedbackRequest_Feedback>(Arena*);
template<> ::service::FeedbackResponse* Arena::CreateMaybeMessage<::service::FeedbackResponse>(Arena*);
template<> ::service::GetResponseRequest* Arena::CreateMaybeMessage<::service::GetResponseRequest>(Arena*);
template<> ::service::GetResponseRequestSingle* Arena::CreateMaybeMessage<::service::GetResponseRequestSingle>(Arena*);
template<> ::service::GetResponseRequest_GetResponseConfig* Arena::CreateMaybeMessage<::service::GetResponseRequest_GetResponseConfig>(Arena*);
template<> ::service::GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUse* Arena::CreateMaybeMessage<::service::GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUse>(Arena*);
template<> ::service::GetResponseRequest_GetResponseData* Arena::CreateMaybeMessage<::service::GetResponseRequest_GetResponseData>(Arena*);
template<> ::service::GetResponseResponse* Arena::CreateMaybeMessage<::service::GetResponseResponse>(Arena*);
template<> ::service::GetResponseResponse_ActionResponse* Arena::CreateMaybeMessage<::service::GetResponseResponse_ActionResponse>(Arena*);
template<> ::service::GetResponseResponse_AudioResponse* Arena::CreateMaybeMessage<::service::GetResponseResponse_AudioResponse>(Arena*);
template<> ::service::GetResponseResponse_BehaviorTreeResponse* Arena::CreateMaybeMessage<::service::GetResponseResponse_BehaviorTreeResponse>(Arena*);
template<> ::service::GetResponseResponse_UserTranscript* Arena::CreateMaybeMessage<::service::GetResponseResponse_UserTranscript>(Arena*);
template<> ::service::HelloRequest* Arena::CreateMaybeMessage<::service::HelloRequest>(Arena*);
template<> ::service::HelloResponse* Arena::CreateMaybeMessage<::service::HelloResponse>(Arena*);
template<> ::service::STTRequest* Arena::CreateMaybeMessage<::service::STTRequest>(Arena*);
template<> ::service::STTResponse* Arena::CreateMaybeMessage<::service::STTResponse>(Arena*);
template<> ::service::TriggerConfig* Arena::CreateMaybeMessage<::service::TriggerConfig>(Arena*);
template<> ::service::Viseme* Arena::CreateMaybeMessage<::service::Viseme>(Arena*);
template<> ::service::VisemesData* Arena::CreateMaybeMessage<::service::VisemesData>(Arena*);
template<> ::service::VisionInput* Arena::CreateMaybeMessage<::service::VisionInput>(Arena*);
template<> ::service::VisionInput_ImageData* Arena::CreateMaybeMessage<::service::VisionInput_ImageData>(Arena*);
template<> ::service::VisionInput_VideoData* Arena::CreateMaybeMessage<::service::VisionInput_VideoData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace service {

enum FaceModel : int {
  FACE_MODEL_UNSPECIFIED = 0,
  FACE_MODEL_A_2F_MODEL_NAME = 1,
  FACE_MODEL_PHONEMES_MODEL_NAME = 2,
  FACE_MODEL_OVR_MODEL_NAME = 3,
  FaceModel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FaceModel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FaceModel_IsValid(int value);
constexpr FaceModel FaceModel_MIN = FACE_MODEL_UNSPECIFIED;
constexpr FaceModel FaceModel_MAX = FACE_MODEL_OVR_MODEL_NAME;
constexpr int FaceModel_ARRAYSIZE = FaceModel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FaceModel_descriptor();
template<typename T>
inline const std::string& FaceModel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FaceModel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FaceModel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FaceModel_descriptor(), enum_t_value);
}
inline bool FaceModel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FaceModel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FaceModel>(
    FaceModel_descriptor(), name, value);
}
// ===================================================================

class AudioConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.AudioConfig) */ {
 public:
  inline AudioConfig() : AudioConfig(nullptr) {}
  ~AudioConfig() override;
  explicit PROTOBUF_CONSTEXPR AudioConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioConfig(const AudioConfig& from);
  AudioConfig(AudioConfig&& from) noexcept
    : AudioConfig() {
    *this = ::std::move(from);
  }

  inline AudioConfig& operator=(const AudioConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioConfig& operator=(AudioConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioConfig* internal_default_instance() {
    return reinterpret_cast<const AudioConfig*>(
               &_AudioConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AudioConfig& a, AudioConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioConfig& from) {
    AudioConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.AudioConfig";
  }
  protected:
  explicit AudioConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSampleRateHertzFieldNumber = 1,
    kDisableAudioFieldNumber = 2,
    kEnableFacialDataFieldNumber = 3,
    kEnableFacialEmotionDataFieldNumber = 5,
    kFaceModelFieldNumber = 4,
  };
  // int32 sample_rate_hertz = 1;
  void clear_sample_rate_hertz();
  int32_t sample_rate_hertz() const;
  void set_sample_rate_hertz(int32_t value);
  private:
  int32_t _internal_sample_rate_hertz() const;
  void _internal_set_sample_rate_hertz(int32_t value);
  public:

  // bool disable_audio = 2;
  void clear_disable_audio();
  bool disable_audio() const;
  void set_disable_audio(bool value);
  private:
  bool _internal_disable_audio() const;
  void _internal_set_disable_audio(bool value);
  public:

  // bool enable_facial_data = 3;
  void clear_enable_facial_data();
  bool enable_facial_data() const;
  void set_enable_facial_data(bool value);
  private:
  bool _internal_enable_facial_data() const;
  void _internal_set_enable_facial_data(bool value);
  public:

  // bool enable_facial_emotion_data = 5;
  void clear_enable_facial_emotion_data();
  bool enable_facial_emotion_data() const;
  void set_enable_facial_emotion_data(bool value);
  private:
  bool _internal_enable_facial_emotion_data() const;
  void _internal_set_enable_facial_emotion_data(bool value);
  public:

  // .service.FaceModel face_model = 4;
  void clear_face_model();
  ::service::FaceModel face_model() const;
  void set_face_model(::service::FaceModel value);
  private:
  ::service::FaceModel _internal_face_model() const;
  void _internal_set_face_model(::service::FaceModel value);
  public:

  // @@protoc_insertion_point(class_scope:service.AudioConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t sample_rate_hertz_;
    bool disable_audio_;
    bool enable_facial_data_;
    bool enable_facial_emotion_data_;
    int face_model_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class TriggerConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.TriggerConfig) */ {
 public:
  inline TriggerConfig() : TriggerConfig(nullptr) {}
  ~TriggerConfig() override;
  explicit PROTOBUF_CONSTEXPR TriggerConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TriggerConfig(const TriggerConfig& from);
  TriggerConfig(TriggerConfig&& from) noexcept
    : TriggerConfig() {
    *this = ::std::move(from);
  }

  inline TriggerConfig& operator=(const TriggerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline TriggerConfig& operator=(TriggerConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TriggerConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const TriggerConfig* internal_default_instance() {
    return reinterpret_cast<const TriggerConfig*>(
               &_TriggerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TriggerConfig& a, TriggerConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(TriggerConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TriggerConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TriggerConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TriggerConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TriggerConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TriggerConfig& from) {
    TriggerConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TriggerConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.TriggerConfig";
  }
  protected:
  explicit TriggerConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTriggerNameFieldNumber = 1,
    kTriggerMessageFieldNumber = 2,
  };
  // string trigger_name = 1;
  void clear_trigger_name();
  const std::string& trigger_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trigger_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trigger_name();
  PROTOBUF_NODISCARD std::string* release_trigger_name();
  void set_allocated_trigger_name(std::string* trigger_name);
  private:
  const std::string& _internal_trigger_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trigger_name(const std::string& value);
  std::string* _internal_mutable_trigger_name();
  public:

  // string trigger_message = 2;
  void clear_trigger_message();
  const std::string& trigger_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trigger_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trigger_message();
  PROTOBUF_NODISCARD std::string* release_trigger_message();
  void set_allocated_trigger_message(std::string* trigger_message);
  private:
  const std::string& _internal_trigger_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trigger_message(const std::string& value);
  std::string* _internal_mutable_trigger_message();
  public:

  // @@protoc_insertion_point(class_scope:service.TriggerConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trigger_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trigger_message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class ActionConfig_Character final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.ActionConfig.Character) */ {
 public:
  inline ActionConfig_Character() : ActionConfig_Character(nullptr) {}
  ~ActionConfig_Character() override;
  explicit PROTOBUF_CONSTEXPR ActionConfig_Character(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionConfig_Character(const ActionConfig_Character& from);
  ActionConfig_Character(ActionConfig_Character&& from) noexcept
    : ActionConfig_Character() {
    *this = ::std::move(from);
  }

  inline ActionConfig_Character& operator=(const ActionConfig_Character& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionConfig_Character& operator=(ActionConfig_Character&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionConfig_Character& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionConfig_Character* internal_default_instance() {
    return reinterpret_cast<const ActionConfig_Character*>(
               &_ActionConfig_Character_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ActionConfig_Character& a, ActionConfig_Character& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionConfig_Character* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionConfig_Character* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionConfig_Character* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionConfig_Character>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionConfig_Character& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionConfig_Character& from) {
    ActionConfig_Character::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionConfig_Character* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.ActionConfig.Character";
  }
  protected:
  explicit ActionConfig_Character(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kBioFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string bio = 2;
  void clear_bio();
  const std::string& bio() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bio(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bio();
  PROTOBUF_NODISCARD std::string* release_bio();
  void set_allocated_bio(std::string* bio);
  private:
  const std::string& _internal_bio() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bio(const std::string& value);
  std::string* _internal_mutable_bio();
  public:

  // @@protoc_insertion_point(class_scope:service.ActionConfig.Character)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bio_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class ActionConfig_Object final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.ActionConfig.Object) */ {
 public:
  inline ActionConfig_Object() : ActionConfig_Object(nullptr) {}
  ~ActionConfig_Object() override;
  explicit PROTOBUF_CONSTEXPR ActionConfig_Object(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionConfig_Object(const ActionConfig_Object& from);
  ActionConfig_Object(ActionConfig_Object&& from) noexcept
    : ActionConfig_Object() {
    *this = ::std::move(from);
  }

  inline ActionConfig_Object& operator=(const ActionConfig_Object& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionConfig_Object& operator=(ActionConfig_Object&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionConfig_Object& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionConfig_Object* internal_default_instance() {
    return reinterpret_cast<const ActionConfig_Object*>(
               &_ActionConfig_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ActionConfig_Object& a, ActionConfig_Object& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionConfig_Object* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionConfig_Object* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionConfig_Object* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionConfig_Object>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionConfig_Object& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionConfig_Object& from) {
    ActionConfig_Object::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionConfig_Object* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.ActionConfig.Object";
  }
  protected:
  explicit ActionConfig_Object(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // @@protoc_insertion_point(class_scope:service.ActionConfig.Object)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class ActionConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.ActionConfig) */ {
 public:
  inline ActionConfig() : ActionConfig(nullptr) {}
  ~ActionConfig() override;
  explicit PROTOBUF_CONSTEXPR ActionConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionConfig(const ActionConfig& from);
  ActionConfig(ActionConfig&& from) noexcept
    : ActionConfig() {
    *this = ::std::move(from);
  }

  inline ActionConfig& operator=(const ActionConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionConfig& operator=(ActionConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionConfig* internal_default_instance() {
    return reinterpret_cast<const ActionConfig*>(
               &_ActionConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ActionConfig& a, ActionConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionConfig& from) {
    ActionConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.ActionConfig";
  }
  protected:
  explicit ActionConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ActionConfig_Character Character;
  typedef ActionConfig_Object Object;

  // accessors -------------------------------------------------------

  enum : int {
    kActionsFieldNumber = 1,
    kCharactersFieldNumber = 2,
    kObjectsFieldNumber = 3,
    kClassificationFieldNumber = 4,
    kCurrentAttentionObjectFieldNumber = 6,
    kContextLevelFieldNumber = 5,
  };
  // repeated string actions = 1;
  int actions_size() const;
  private:
  int _internal_actions_size() const;
  public:
  void clear_actions();
  const std::string& actions(int index) const;
  std::string* mutable_actions(int index);
  void set_actions(int index, const std::string& value);
  void set_actions(int index, std::string&& value);
  void set_actions(int index, const char* value);
  void set_actions(int index, const char* value, size_t size);
  std::string* add_actions();
  void add_actions(const std::string& value);
  void add_actions(std::string&& value);
  void add_actions(const char* value);
  void add_actions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& actions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_actions();
  private:
  const std::string& _internal_actions(int index) const;
  std::string* _internal_add_actions();
  public:

  // repeated .service.ActionConfig.Character characters = 2;
  int characters_size() const;
  private:
  int _internal_characters_size() const;
  public:
  void clear_characters();
  ::service::ActionConfig_Character* mutable_characters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Character >*
      mutable_characters();
  private:
  const ::service::ActionConfig_Character& _internal_characters(int index) const;
  ::service::ActionConfig_Character* _internal_add_characters();
  public:
  const ::service::ActionConfig_Character& characters(int index) const;
  ::service::ActionConfig_Character* add_characters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Character >&
      characters() const;

  // repeated .service.ActionConfig.Object objects = 3;
  int objects_size() const;
  private:
  int _internal_objects_size() const;
  public:
  void clear_objects();
  ::service::ActionConfig_Object* mutable_objects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Object >*
      mutable_objects();
  private:
  const ::service::ActionConfig_Object& _internal_objects(int index) const;
  ::service::ActionConfig_Object* _internal_add_objects();
  public:
  const ::service::ActionConfig_Object& objects(int index) const;
  ::service::ActionConfig_Object* add_objects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Object >&
      objects() const;

  // string classification = 4;
  void clear_classification();
  const std::string& classification() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_classification(ArgT0&& arg0, ArgT... args);
  std::string* mutable_classification();
  PROTOBUF_NODISCARD std::string* release_classification();
  void set_allocated_classification(std::string* classification);
  private:
  const std::string& _internal_classification() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_classification(const std::string& value);
  std::string* _internal_mutable_classification();
  public:

  // string current_attention_object = 6;
  void clear_current_attention_object();
  const std::string& current_attention_object() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_current_attention_object(ArgT0&& arg0, ArgT... args);
  std::string* mutable_current_attention_object();
  PROTOBUF_NODISCARD std::string* release_current_attention_object();
  void set_allocated_current_attention_object(std::string* current_attention_object);
  private:
  const std::string& _internal_current_attention_object() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_attention_object(const std::string& value);
  std::string* _internal_mutable_current_attention_object();
  public:

  // int32 context_level = 5;
  void clear_context_level();
  int32_t context_level() const;
  void set_context_level(int32_t value);
  private:
  int32_t _internal_context_level() const;
  void _internal_set_context_level(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:service.ActionConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> actions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Character > characters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Object > objects_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr classification_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_attention_object_;
    int32_t context_level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class STTRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.STTRequest) */ {
 public:
  inline STTRequest() : STTRequest(nullptr) {}
  ~STTRequest() override;
  explicit PROTOBUF_CONSTEXPR STTRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  STTRequest(const STTRequest& from);
  STTRequest(STTRequest&& from) noexcept
    : STTRequest() {
    *this = ::std::move(from);
  }

  inline STTRequest& operator=(const STTRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline STTRequest& operator=(STTRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const STTRequest& default_instance() {
    return *internal_default_instance();
  }
  enum RequestTypeCase {
    kAudioConfig = 1,
    kAudioChunk = 2,
    REQUEST_TYPE_NOT_SET = 0,
  };

  static inline const STTRequest* internal_default_instance() {
    return reinterpret_cast<const STTRequest*>(
               &_STTRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(STTRequest& a, STTRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(STTRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(STTRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  STTRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<STTRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const STTRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const STTRequest& from) {
    STTRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(STTRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.STTRequest";
  }
  protected:
  explicit STTRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioConfigFieldNumber = 1,
    kAudioChunkFieldNumber = 2,
  };
  // .service.AudioConfig audio_config = 1;
  bool has_audio_config() const;
  private:
  bool _internal_has_audio_config() const;
  public:
  void clear_audio_config();
  const ::service::AudioConfig& audio_config() const;
  PROTOBUF_NODISCARD ::service::AudioConfig* release_audio_config();
  ::service::AudioConfig* mutable_audio_config();
  void set_allocated_audio_config(::service::AudioConfig* audio_config);
  private:
  const ::service::AudioConfig& _internal_audio_config() const;
  ::service::AudioConfig* _internal_mutable_audio_config();
  public:
  void unsafe_arena_set_allocated_audio_config(
      ::service::AudioConfig* audio_config);
  ::service::AudioConfig* unsafe_arena_release_audio_config();

  // bytes audio_chunk = 2;
  bool has_audio_chunk() const;
  private:
  bool _internal_has_audio_chunk() const;
  public:
  void clear_audio_chunk();
  const std::string& audio_chunk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audio_chunk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audio_chunk();
  PROTOBUF_NODISCARD std::string* release_audio_chunk();
  void set_allocated_audio_chunk(std::string* audio_chunk);
  private:
  const std::string& _internal_audio_chunk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_chunk(const std::string& value);
  std::string* _internal_mutable_audio_chunk();
  public:

  void clear_request_type();
  RequestTypeCase request_type_case() const;
  // @@protoc_insertion_point(class_scope:service.STTRequest)
 private:
  class _Internal;
  void set_has_audio_config();
  void set_has_audio_chunk();

  inline bool has_request_type() const;
  inline void clear_has_request_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union RequestTypeUnion {
      constexpr RequestTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::service::AudioConfig* audio_config_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_chunk_;
    } request_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class STTResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.STTResponse) */ {
 public:
  inline STTResponse() : STTResponse(nullptr) {}
  ~STTResponse() override;
  explicit PROTOBUF_CONSTEXPR STTResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  STTResponse(const STTResponse& from);
  STTResponse(STTResponse&& from) noexcept
    : STTResponse() {
    *this = ::std::move(from);
  }

  inline STTResponse& operator=(const STTResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline STTResponse& operator=(STTResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const STTResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const STTResponse* internal_default_instance() {
    return reinterpret_cast<const STTResponse*>(
               &_STTResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(STTResponse& a, STTResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(STTResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(STTResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  STTResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<STTResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const STTResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const STTResponse& from) {
    STTResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(STTResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.STTResponse";
  }
  protected:
  explicit STTResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:service.STTResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class DynamicInfoConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.DynamicInfoConfig) */ {
 public:
  inline DynamicInfoConfig() : DynamicInfoConfig(nullptr) {}
  ~DynamicInfoConfig() override;
  explicit PROTOBUF_CONSTEXPR DynamicInfoConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DynamicInfoConfig(const DynamicInfoConfig& from);
  DynamicInfoConfig(DynamicInfoConfig&& from) noexcept
    : DynamicInfoConfig() {
    *this = ::std::move(from);
  }

  inline DynamicInfoConfig& operator=(const DynamicInfoConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline DynamicInfoConfig& operator=(DynamicInfoConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DynamicInfoConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const DynamicInfoConfig* internal_default_instance() {
    return reinterpret_cast<const DynamicInfoConfig*>(
               &_DynamicInfoConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DynamicInfoConfig& a, DynamicInfoConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(DynamicInfoConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DynamicInfoConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DynamicInfoConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DynamicInfoConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DynamicInfoConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DynamicInfoConfig& from) {
    DynamicInfoConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DynamicInfoConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.DynamicInfoConfig";
  }
  protected:
  explicit DynamicInfoConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:service.DynamicInfoConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class VisionInput_ImageData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.VisionInput.ImageData) */ {
 public:
  inline VisionInput_ImageData() : VisionInput_ImageData(nullptr) {}
  ~VisionInput_ImageData() override;
  explicit PROTOBUF_CONSTEXPR VisionInput_ImageData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VisionInput_ImageData(const VisionInput_ImageData& from);
  VisionInput_ImageData(VisionInput_ImageData&& from) noexcept
    : VisionInput_ImageData() {
    *this = ::std::move(from);
  }

  inline VisionInput_ImageData& operator=(const VisionInput_ImageData& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisionInput_ImageData& operator=(VisionInput_ImageData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisionInput_ImageData& default_instance() {
    return *internal_default_instance();
  }
  static inline const VisionInput_ImageData* internal_default_instance() {
    return reinterpret_cast<const VisionInput_ImageData*>(
               &_VisionInput_ImageData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(VisionInput_ImageData& a, VisionInput_ImageData& b) {
    a.Swap(&b);
  }
  inline void Swap(VisionInput_ImageData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisionInput_ImageData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisionInput_ImageData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VisionInput_ImageData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VisionInput_ImageData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VisionInput_ImageData& from) {
    VisionInput_ImageData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VisionInput_ImageData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.VisionInput.ImageData";
  }
  protected:
  explicit VisionInput_ImageData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // bytes data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int32 width = 1;
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // int32 height = 2;
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:service.VisionInput.ImageData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int32_t width_;
    int32_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class VisionInput_VideoData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.VisionInput.VideoData) */ {
 public:
  inline VisionInput_VideoData() : VisionInput_VideoData(nullptr) {}
  ~VisionInput_VideoData() override;
  explicit PROTOBUF_CONSTEXPR VisionInput_VideoData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VisionInput_VideoData(const VisionInput_VideoData& from);
  VisionInput_VideoData(VisionInput_VideoData&& from) noexcept
    : VisionInput_VideoData() {
    *this = ::std::move(from);
  }

  inline VisionInput_VideoData& operator=(const VisionInput_VideoData& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisionInput_VideoData& operator=(VisionInput_VideoData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisionInput_VideoData& default_instance() {
    return *internal_default_instance();
  }
  static inline const VisionInput_VideoData* internal_default_instance() {
    return reinterpret_cast<const VisionInput_VideoData*>(
               &_VisionInput_VideoData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(VisionInput_VideoData& a, VisionInput_VideoData& b) {
    a.Swap(&b);
  }
  inline void Swap(VisionInput_VideoData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisionInput_VideoData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisionInput_VideoData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VisionInput_VideoData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VisionInput_VideoData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VisionInput_VideoData& from) {
    VisionInput_VideoData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VisionInput_VideoData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.VisionInput.VideoData";
  }
  protected:
  explicit VisionInput_VideoData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 4,
    kFpsFieldNumber = 1,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
  };
  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int32 fps = 1;
  void clear_fps();
  int32_t fps() const;
  void set_fps(int32_t value);
  private:
  int32_t _internal_fps() const;
  void _internal_set_fps(int32_t value);
  public:

  // int32 width = 2;
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // int32 height = 3;
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:service.VisionInput.VideoData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int32_t fps_;
    int32_t width_;
    int32_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class VisionInput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.VisionInput) */ {
 public:
  inline VisionInput() : VisionInput(nullptr) {}
  ~VisionInput() override;
  explicit PROTOBUF_CONSTEXPR VisionInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VisionInput(const VisionInput& from);
  VisionInput(VisionInput&& from) noexcept
    : VisionInput() {
    *this = ::std::move(from);
  }

  inline VisionInput& operator=(const VisionInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisionInput& operator=(VisionInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisionInput& default_instance() {
    return *internal_default_instance();
  }
  enum VisionDataCase {
    kImageData = 1,
    kVideoData = 2,
    VISION_DATA_NOT_SET = 0,
  };

  static inline const VisionInput* internal_default_instance() {
    return reinterpret_cast<const VisionInput*>(
               &_VisionInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(VisionInput& a, VisionInput& b) {
    a.Swap(&b);
  }
  inline void Swap(VisionInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisionInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisionInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VisionInput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VisionInput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VisionInput& from) {
    VisionInput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VisionInput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.VisionInput";
  }
  protected:
  explicit VisionInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VisionInput_ImageData ImageData;
  typedef VisionInput_VideoData VideoData;

  // accessors -------------------------------------------------------

  enum : int {
    kImageDataFieldNumber = 1,
    kVideoDataFieldNumber = 2,
  };
  // .service.VisionInput.ImageData image_data = 1;
  bool has_image_data() const;
  private:
  bool _internal_has_image_data() const;
  public:
  void clear_image_data();
  const ::service::VisionInput_ImageData& image_data() const;
  PROTOBUF_NODISCARD ::service::VisionInput_ImageData* release_image_data();
  ::service::VisionInput_ImageData* mutable_image_data();
  void set_allocated_image_data(::service::VisionInput_ImageData* image_data);
  private:
  const ::service::VisionInput_ImageData& _internal_image_data() const;
  ::service::VisionInput_ImageData* _internal_mutable_image_data();
  public:
  void unsafe_arena_set_allocated_image_data(
      ::service::VisionInput_ImageData* image_data);
  ::service::VisionInput_ImageData* unsafe_arena_release_image_data();

  // .service.VisionInput.VideoData video_data = 2;
  bool has_video_data() const;
  private:
  bool _internal_has_video_data() const;
  public:
  void clear_video_data();
  const ::service::VisionInput_VideoData& video_data() const;
  PROTOBUF_NODISCARD ::service::VisionInput_VideoData* release_video_data();
  ::service::VisionInput_VideoData* mutable_video_data();
  void set_allocated_video_data(::service::VisionInput_VideoData* video_data);
  private:
  const ::service::VisionInput_VideoData& _internal_video_data() const;
  ::service::VisionInput_VideoData* _internal_mutable_video_data();
  public:
  void unsafe_arena_set_allocated_video_data(
      ::service::VisionInput_VideoData* video_data);
  ::service::VisionInput_VideoData* unsafe_arena_release_video_data();

  void clear_vision_data();
  VisionDataCase vision_data_case() const;
  // @@protoc_insertion_point(class_scope:service.VisionInput)
 private:
  class _Internal;
  void set_has_image_data();
  void set_has_video_data();

  inline bool has_vision_data() const;
  inline void clear_has_vision_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union VisionDataUnion {
      constexpr VisionDataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::service::VisionInput_ImageData* image_data_;
      ::service::VisionInput_VideoData* video_data_;
    } vision_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUse& other);
  static const GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUse*>(&_GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "service.GetResponseRequest.GetResponseConfig.NarrativeTemplateKeysEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "service.GetResponseRequest.GetResponseConfig.NarrativeTemplateKeysEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_service_2eproto;
};

// -------------------------------------------------------------------

class GetResponseRequest_GetResponseConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.GetResponseRequest.GetResponseConfig) */ {
 public:
  inline GetResponseRequest_GetResponseConfig() : GetResponseRequest_GetResponseConfig(nullptr) {}
  ~GetResponseRequest_GetResponseConfig() override;
  explicit PROTOBUF_CONSTEXPR GetResponseRequest_GetResponseConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResponseRequest_GetResponseConfig(const GetResponseRequest_GetResponseConfig& from);
  GetResponseRequest_GetResponseConfig(GetResponseRequest_GetResponseConfig&& from) noexcept
    : GetResponseRequest_GetResponseConfig() {
    *this = ::std::move(from);
  }

  inline GetResponseRequest_GetResponseConfig& operator=(const GetResponseRequest_GetResponseConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseRequest_GetResponseConfig& operator=(GetResponseRequest_GetResponseConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponseRequest_GetResponseConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetResponseRequest_GetResponseConfig* internal_default_instance() {
    return reinterpret_cast<const GetResponseRequest_GetResponseConfig*>(
               &_GetResponseRequest_GetResponseConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetResponseRequest_GetResponseConfig& a, GetResponseRequest_GetResponseConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponseRequest_GetResponseConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseRequest_GetResponseConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponseRequest_GetResponseConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResponseRequest_GetResponseConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResponseRequest_GetResponseConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetResponseRequest_GetResponseConfig& from) {
    GetResponseRequest_GetResponseConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponseRequest_GetResponseConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.GetResponseRequest.GetResponseConfig";
  }
  protected:
  explicit GetResponseRequest_GetResponseConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kNarrativeTemplateKeysFieldNumber = 11,
    kCharacterIdFieldNumber = 2,
    kApiKeyFieldNumber = 3,
    kSessionIdFieldNumber = 4,
    kSpeakerFieldNumber = 7,
    kLanguageCodeFieldNumber = 8,
    kSpeakerIdFieldNumber = 9,
    kApiAuthTokenFieldNumber = 10,
    kAudioConfigFieldNumber = 5,
    kActionConfigFieldNumber = 6,
    kDynamicInfoConfigFieldNumber = 12,
    kVisionInputFieldNumber = 13,
  };
  // map<string, string> narrative_template_keys = 11;
  int narrative_template_keys_size() const;
  private:
  int _internal_narrative_template_keys_size() const;
  public:
  void clear_narrative_template_keys();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_narrative_template_keys() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_narrative_template_keys();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      narrative_template_keys() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_narrative_template_keys();

  // string character_id = 2;
  void clear_character_id();
  const std::string& character_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_character_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_character_id();
  PROTOBUF_NODISCARD std::string* release_character_id();
  void set_allocated_character_id(std::string* character_id);
  private:
  const std::string& _internal_character_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_character_id(const std::string& value);
  std::string* _internal_mutable_character_id();
  public:

  // string api_key = 3;
  void clear_api_key();
  const std::string& api_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_api_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_api_key();
  PROTOBUF_NODISCARD std::string* release_api_key();
  void set_allocated_api_key(std::string* api_key);
  private:
  const std::string& _internal_api_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_api_key(const std::string& value);
  std::string* _internal_mutable_api_key();
  public:

  // string session_id = 4;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // string speaker = 7;
  void clear_speaker();
  const std::string& speaker() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_speaker(ArgT0&& arg0, ArgT... args);
  std::string* mutable_speaker();
  PROTOBUF_NODISCARD std::string* release_speaker();
  void set_allocated_speaker(std::string* speaker);
  private:
  const std::string& _internal_speaker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_speaker(const std::string& value);
  std::string* _internal_mutable_speaker();
  public:

  // string language_code = 8;
  void clear_language_code();
  const std::string& language_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language_code();
  PROTOBUF_NODISCARD std::string* release_language_code();
  void set_allocated_language_code(std::string* language_code);
  private:
  const std::string& _internal_language_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language_code(const std::string& value);
  std::string* _internal_mutable_language_code();
  public:

  // string speaker_id = 9;
  void clear_speaker_id();
  const std::string& speaker_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_speaker_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_speaker_id();
  PROTOBUF_NODISCARD std::string* release_speaker_id();
  void set_allocated_speaker_id(std::string* speaker_id);
  private:
  const std::string& _internal_speaker_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_speaker_id(const std::string& value);
  std::string* _internal_mutable_speaker_id();
  public:

  // string api_auth_token = 10;
  void clear_api_auth_token();
  const std::string& api_auth_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_api_auth_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_api_auth_token();
  PROTOBUF_NODISCARD std::string* release_api_auth_token();
  void set_allocated_api_auth_token(std::string* api_auth_token);
  private:
  const std::string& _internal_api_auth_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_api_auth_token(const std::string& value);
  std::string* _internal_mutable_api_auth_token();
  public:

  // .service.AudioConfig audio_config = 5;
  bool has_audio_config() const;
  private:
  bool _internal_has_audio_config() const;
  public:
  void clear_audio_config();
  const ::service::AudioConfig& audio_config() const;
  PROTOBUF_NODISCARD ::service::AudioConfig* release_audio_config();
  ::service::AudioConfig* mutable_audio_config();
  void set_allocated_audio_config(::service::AudioConfig* audio_config);
  private:
  const ::service::AudioConfig& _internal_audio_config() const;
  ::service::AudioConfig* _internal_mutable_audio_config();
  public:
  void unsafe_arena_set_allocated_audio_config(
      ::service::AudioConfig* audio_config);
  ::service::AudioConfig* unsafe_arena_release_audio_config();

  // .service.ActionConfig action_config = 6;
  bool has_action_config() const;
  private:
  bool _internal_has_action_config() const;
  public:
  void clear_action_config();
  const ::service::ActionConfig& action_config() const;
  PROTOBUF_NODISCARD ::service::ActionConfig* release_action_config();
  ::service::ActionConfig* mutable_action_config();
  void set_allocated_action_config(::service::ActionConfig* action_config);
  private:
  const ::service::ActionConfig& _internal_action_config() const;
  ::service::ActionConfig* _internal_mutable_action_config();
  public:
  void unsafe_arena_set_allocated_action_config(
      ::service::ActionConfig* action_config);
  ::service::ActionConfig* unsafe_arena_release_action_config();

  // .service.DynamicInfoConfig dynamic_info_config = 12;
  bool has_dynamic_info_config() const;
  private:
  bool _internal_has_dynamic_info_config() const;
  public:
  void clear_dynamic_info_config();
  const ::service::DynamicInfoConfig& dynamic_info_config() const;
  PROTOBUF_NODISCARD ::service::DynamicInfoConfig* release_dynamic_info_config();
  ::service::DynamicInfoConfig* mutable_dynamic_info_config();
  void set_allocated_dynamic_info_config(::service::DynamicInfoConfig* dynamic_info_config);
  private:
  const ::service::DynamicInfoConfig& _internal_dynamic_info_config() const;
  ::service::DynamicInfoConfig* _internal_mutable_dynamic_info_config();
  public:
  void unsafe_arena_set_allocated_dynamic_info_config(
      ::service::DynamicInfoConfig* dynamic_info_config);
  ::service::DynamicInfoConfig* unsafe_arena_release_dynamic_info_config();

  // .service.VisionInput vision_input = 13;
  bool has_vision_input() const;
  private:
  bool _internal_has_vision_input() const;
  public:
  void clear_vision_input();
  const ::service::VisionInput& vision_input() const;
  PROTOBUF_NODISCARD ::service::VisionInput* release_vision_input();
  ::service::VisionInput* mutable_vision_input();
  void set_allocated_vision_input(::service::VisionInput* vision_input);
  private:
  const ::service::VisionInput& _internal_vision_input() const;
  ::service::VisionInput* _internal_mutable_vision_input();
  public:
  void unsafe_arena_set_allocated_vision_input(
      ::service::VisionInput* vision_input);
  ::service::VisionInput* unsafe_arena_release_vision_input();

  // @@protoc_insertion_point(class_scope:service.GetResponseRequest.GetResponseConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        GetResponseRequest_GetResponseConfig_NarrativeTemplateKeysEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> narrative_template_keys_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr character_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr api_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr speaker_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr speaker_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr api_auth_token_;
    ::service::AudioConfig* audio_config_;
    ::service::ActionConfig* action_config_;
    ::service::DynamicInfoConfig* dynamic_info_config_;
    ::service::VisionInput* vision_input_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseRequest_GetResponseData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.GetResponseRequest.GetResponseData) */ {
 public:
  inline GetResponseRequest_GetResponseData() : GetResponseRequest_GetResponseData(nullptr) {}
  ~GetResponseRequest_GetResponseData() override;
  explicit PROTOBUF_CONSTEXPR GetResponseRequest_GetResponseData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResponseRequest_GetResponseData(const GetResponseRequest_GetResponseData& from);
  GetResponseRequest_GetResponseData(GetResponseRequest_GetResponseData&& from) noexcept
    : GetResponseRequest_GetResponseData() {
    *this = ::std::move(from);
  }

  inline GetResponseRequest_GetResponseData& operator=(const GetResponseRequest_GetResponseData& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseRequest_GetResponseData& operator=(GetResponseRequest_GetResponseData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponseRequest_GetResponseData& default_instance() {
    return *internal_default_instance();
  }
  enum InputTypeCase {
    kAudioData = 1,
    kTextData = 2,
    kTriggerData = 3,
    INPUT_TYPE_NOT_SET = 0,
  };

  static inline const GetResponseRequest_GetResponseData* internal_default_instance() {
    return reinterpret_cast<const GetResponseRequest_GetResponseData*>(
               &_GetResponseRequest_GetResponseData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetResponseRequest_GetResponseData& a, GetResponseRequest_GetResponseData& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponseRequest_GetResponseData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseRequest_GetResponseData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponseRequest_GetResponseData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResponseRequest_GetResponseData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResponseRequest_GetResponseData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetResponseRequest_GetResponseData& from) {
    GetResponseRequest_GetResponseData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponseRequest_GetResponseData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.GetResponseRequest.GetResponseData";
  }
  protected:
  explicit GetResponseRequest_GetResponseData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioDataFieldNumber = 1,
    kTextDataFieldNumber = 2,
    kTriggerDataFieldNumber = 3,
  };
  // bytes audio_data = 1;
  bool has_audio_data() const;
  private:
  bool _internal_has_audio_data() const;
  public:
  void clear_audio_data();
  const std::string& audio_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audio_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audio_data();
  PROTOBUF_NODISCARD std::string* release_audio_data();
  void set_allocated_audio_data(std::string* audio_data);
  private:
  const std::string& _internal_audio_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_data(const std::string& value);
  std::string* _internal_mutable_audio_data();
  public:

  // string text_data = 2;
  bool has_text_data() const;
  private:
  bool _internal_has_text_data() const;
  public:
  void clear_text_data();
  const std::string& text_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text_data();
  PROTOBUF_NODISCARD std::string* release_text_data();
  void set_allocated_text_data(std::string* text_data);
  private:
  const std::string& _internal_text_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text_data(const std::string& value);
  std::string* _internal_mutable_text_data();
  public:

  // .service.TriggerConfig trigger_data = 3;
  bool has_trigger_data() const;
  private:
  bool _internal_has_trigger_data() const;
  public:
  void clear_trigger_data();
  const ::service::TriggerConfig& trigger_data() const;
  PROTOBUF_NODISCARD ::service::TriggerConfig* release_trigger_data();
  ::service::TriggerConfig* mutable_trigger_data();
  void set_allocated_trigger_data(::service::TriggerConfig* trigger_data);
  private:
  const ::service::TriggerConfig& _internal_trigger_data() const;
  ::service::TriggerConfig* _internal_mutable_trigger_data();
  public:
  void unsafe_arena_set_allocated_trigger_data(
      ::service::TriggerConfig* trigger_data);
  ::service::TriggerConfig* unsafe_arena_release_trigger_data();

  void clear_input_type();
  InputTypeCase input_type_case() const;
  // @@protoc_insertion_point(class_scope:service.GetResponseRequest.GetResponseData)
 private:
  class _Internal;
  void set_has_audio_data();
  void set_has_text_data();
  void set_has_trigger_data();

  inline bool has_input_type() const;
  inline void clear_has_input_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union InputTypeUnion {
      constexpr InputTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_data_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_data_;
      ::service::TriggerConfig* trigger_data_;
    } input_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.GetResponseRequest) */ {
 public:
  inline GetResponseRequest() : GetResponseRequest(nullptr) {}
  ~GetResponseRequest() override;
  explicit PROTOBUF_CONSTEXPR GetResponseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResponseRequest(const GetResponseRequest& from);
  GetResponseRequest(GetResponseRequest&& from) noexcept
    : GetResponseRequest() {
    *this = ::std::move(from);
  }

  inline GetResponseRequest& operator=(const GetResponseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseRequest& operator=(GetResponseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponseRequest& default_instance() {
    return *internal_default_instance();
  }
  enum RequestTypeCase {
    kGetResponseConfig = 1,
    kGetResponseData = 2,
    REQUEST_TYPE_NOT_SET = 0,
  };

  static inline const GetResponseRequest* internal_default_instance() {
    return reinterpret_cast<const GetResponseRequest*>(
               &_GetResponseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetResponseRequest& a, GetResponseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResponseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResponseRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetResponseRequest& from) {
    GetResponseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponseRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.GetResponseRequest";
  }
  protected:
  explicit GetResponseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetResponseRequest_GetResponseConfig GetResponseConfig;
  typedef GetResponseRequest_GetResponseData GetResponseData;

  // accessors -------------------------------------------------------

  enum : int {
    kGetResponseConfigFieldNumber = 1,
    kGetResponseDataFieldNumber = 2,
  };
  // .service.GetResponseRequest.GetResponseConfig get_response_config = 1;
  bool has_get_response_config() const;
  private:
  bool _internal_has_get_response_config() const;
  public:
  void clear_get_response_config();
  const ::service::GetResponseRequest_GetResponseConfig& get_response_config() const;
  PROTOBUF_NODISCARD ::service::GetResponseRequest_GetResponseConfig* release_get_response_config();
  ::service::GetResponseRequest_GetResponseConfig* mutable_get_response_config();
  void set_allocated_get_response_config(::service::GetResponseRequest_GetResponseConfig* get_response_config);
  private:
  const ::service::GetResponseRequest_GetResponseConfig& _internal_get_response_config() const;
  ::service::GetResponseRequest_GetResponseConfig* _internal_mutable_get_response_config();
  public:
  void unsafe_arena_set_allocated_get_response_config(
      ::service::GetResponseRequest_GetResponseConfig* get_response_config);
  ::service::GetResponseRequest_GetResponseConfig* unsafe_arena_release_get_response_config();

  // .service.GetResponseRequest.GetResponseData get_response_data = 2;
  bool has_get_response_data() const;
  private:
  bool _internal_has_get_response_data() const;
  public:
  void clear_get_response_data();
  const ::service::GetResponseRequest_GetResponseData& get_response_data() const;
  PROTOBUF_NODISCARD ::service::GetResponseRequest_GetResponseData* release_get_response_data();
  ::service::GetResponseRequest_GetResponseData* mutable_get_response_data();
  void set_allocated_get_response_data(::service::GetResponseRequest_GetResponseData* get_response_data);
  private:
  const ::service::GetResponseRequest_GetResponseData& _internal_get_response_data() const;
  ::service::GetResponseRequest_GetResponseData* _internal_mutable_get_response_data();
  public:
  void unsafe_arena_set_allocated_get_response_data(
      ::service::GetResponseRequest_GetResponseData* get_response_data);
  ::service::GetResponseRequest_GetResponseData* unsafe_arena_release_get_response_data();

  void clear_request_type();
  RequestTypeCase request_type_case() const;
  // @@protoc_insertion_point(class_scope:service.GetResponseRequest)
 private:
  class _Internal;
  void set_has_get_response_config();
  void set_has_get_response_data();

  inline bool has_request_type() const;
  inline void clear_has_request_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union RequestTypeUnion {
      constexpr RequestTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::service::GetResponseRequest_GetResponseConfig* get_response_config_;
      ::service::GetResponseRequest_GetResponseData* get_response_data_;
    } request_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseRequestSingle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.GetResponseRequestSingle) */ {
 public:
  inline GetResponseRequestSingle() : GetResponseRequestSingle(nullptr) {}
  ~GetResponseRequestSingle() override;
  explicit PROTOBUF_CONSTEXPR GetResponseRequestSingle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResponseRequestSingle(const GetResponseRequestSingle& from);
  GetResponseRequestSingle(GetResponseRequestSingle&& from) noexcept
    : GetResponseRequestSingle() {
    *this = ::std::move(from);
  }

  inline GetResponseRequestSingle& operator=(const GetResponseRequestSingle& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseRequestSingle& operator=(GetResponseRequestSingle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponseRequestSingle& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetResponseRequestSingle* internal_default_instance() {
    return reinterpret_cast<const GetResponseRequestSingle*>(
               &_GetResponseRequestSingle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetResponseRequestSingle& a, GetResponseRequestSingle& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponseRequestSingle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseRequestSingle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponseRequestSingle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResponseRequestSingle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResponseRequestSingle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetResponseRequestSingle& from) {
    GetResponseRequestSingle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponseRequestSingle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.GetResponseRequestSingle";
  }
  protected:
  explicit GetResponseRequestSingle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseConfigFieldNumber = 1,
    kResponseDataFieldNumber = 2,
  };
  // .service.GetResponseRequest response_config = 1;
  bool has_response_config() const;
  private:
  bool _internal_has_response_config() const;
  public:
  void clear_response_config();
  const ::service::GetResponseRequest& response_config() const;
  PROTOBUF_NODISCARD ::service::GetResponseRequest* release_response_config();
  ::service::GetResponseRequest* mutable_response_config();
  void set_allocated_response_config(::service::GetResponseRequest* response_config);
  private:
  const ::service::GetResponseRequest& _internal_response_config() const;
  ::service::GetResponseRequest* _internal_mutable_response_config();
  public:
  void unsafe_arena_set_allocated_response_config(
      ::service::GetResponseRequest* response_config);
  ::service::GetResponseRequest* unsafe_arena_release_response_config();

  // .service.GetResponseRequest response_data = 2;
  bool has_response_data() const;
  private:
  bool _internal_has_response_data() const;
  public:
  void clear_response_data();
  const ::service::GetResponseRequest& response_data() const;
  PROTOBUF_NODISCARD ::service::GetResponseRequest* release_response_data();
  ::service::GetResponseRequest* mutable_response_data();
  void set_allocated_response_data(::service::GetResponseRequest* response_data);
  private:
  const ::service::GetResponseRequest& _internal_response_data() const;
  ::service::GetResponseRequest* _internal_mutable_response_data();
  public:
  void unsafe_arena_set_allocated_response_data(
      ::service::GetResponseRequest* response_data);
  ::service::GetResponseRequest* unsafe_arena_release_response_data();

  // @@protoc_insertion_point(class_scope:service.GetResponseRequestSingle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::service::GetResponseRequest* response_config_;
    ::service::GetResponseRequest* response_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseResponse_AudioResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.GetResponseResponse.AudioResponse) */ {
 public:
  inline GetResponseResponse_AudioResponse() : GetResponseResponse_AudioResponse(nullptr) {}
  ~GetResponseResponse_AudioResponse() override;
  explicit PROTOBUF_CONSTEXPR GetResponseResponse_AudioResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResponseResponse_AudioResponse(const GetResponseResponse_AudioResponse& from);
  GetResponseResponse_AudioResponse(GetResponseResponse_AudioResponse&& from) noexcept
    : GetResponseResponse_AudioResponse() {
    *this = ::std::move(from);
  }

  inline GetResponseResponse_AudioResponse& operator=(const GetResponseResponse_AudioResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseResponse_AudioResponse& operator=(GetResponseResponse_AudioResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponseResponse_AudioResponse& default_instance() {
    return *internal_default_instance();
  }
  enum FaceDataTypeCase {
    kVisemesData = 6,
    kBlendshapesData = 7,
    FACE_DATA_TYPE_NOT_SET = 0,
  };

  static inline const GetResponseResponse_AudioResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponseResponse_AudioResponse*>(
               &_GetResponseResponse_AudioResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetResponseResponse_AudioResponse& a, GetResponseResponse_AudioResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponseResponse_AudioResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseResponse_AudioResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponseResponse_AudioResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResponseResponse_AudioResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResponseResponse_AudioResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetResponseResponse_AudioResponse& from) {
    GetResponseResponse_AudioResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponseResponse_AudioResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.GetResponseResponse.AudioResponse";
  }
  protected:
  explicit GetResponseResponse_AudioResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioDataFieldNumber = 1,
    kTextDataFieldNumber = 3,
    kFaceDataFieldNumber = 5,
    kAudioConfigFieldNumber = 2,
    kFaceEmotionFieldNumber = 8,
    kEmotionResponseFieldNumber = 9,
    kEndOfResponseFieldNumber = 4,
    kVisemesDataFieldNumber = 6,
    kBlendshapesDataFieldNumber = 7,
  };
  // bytes audio_data = 1;
  void clear_audio_data();
  const std::string& audio_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audio_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audio_data();
  PROTOBUF_NODISCARD std::string* release_audio_data();
  void set_allocated_audio_data(std::string* audio_data);
  private:
  const std::string& _internal_audio_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_data(const std::string& value);
  std::string* _internal_mutable_audio_data();
  public:

  // string text_data = 3;
  void clear_text_data();
  const std::string& text_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text_data();
  PROTOBUF_NODISCARD std::string* release_text_data();
  void set_allocated_text_data(std::string* text_data);
  private:
  const std::string& _internal_text_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text_data(const std::string& value);
  std::string* _internal_mutable_text_data();
  public:

  // string face_data = 5;
  void clear_face_data();
  const std::string& face_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_face_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_face_data();
  PROTOBUF_NODISCARD std::string* release_face_data();
  void set_allocated_face_data(std::string* face_data);
  private:
  const std::string& _internal_face_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_face_data(const std::string& value);
  std::string* _internal_mutable_face_data();
  public:

  // .service.AudioConfig audio_config = 2;
  bool has_audio_config() const;
  private:
  bool _internal_has_audio_config() const;
  public:
  void clear_audio_config();
  const ::service::AudioConfig& audio_config() const;
  PROTOBUF_NODISCARD ::service::AudioConfig* release_audio_config();
  ::service::AudioConfig* mutable_audio_config();
  void set_allocated_audio_config(::service::AudioConfig* audio_config);
  private:
  const ::service::AudioConfig& _internal_audio_config() const;
  ::service::AudioConfig* _internal_mutable_audio_config();
  public:
  void unsafe_arena_set_allocated_audio_config(
      ::service::AudioConfig* audio_config);
  ::service::AudioConfig* unsafe_arena_release_audio_config();

  // .service.ARKitBlendShapesData face_emotion = 8;
  bool has_face_emotion() const;
  private:
  bool _internal_has_face_emotion() const;
  public:
  void clear_face_emotion();
  const ::service::ARKitBlendShapesData& face_emotion() const;
  PROTOBUF_NODISCARD ::service::ARKitBlendShapesData* release_face_emotion();
  ::service::ARKitBlendShapesData* mutable_face_emotion();
  void set_allocated_face_emotion(::service::ARKitBlendShapesData* face_emotion);
  private:
  const ::service::ARKitBlendShapesData& _internal_face_emotion() const;
  ::service::ARKitBlendShapesData* _internal_mutable_face_emotion();
  public:
  void unsafe_arena_set_allocated_face_emotion(
      ::service::ARKitBlendShapesData* face_emotion);
  ::service::ARKitBlendShapesData* unsafe_arena_release_face_emotion();

  // .service.EmotionResponse emotion_response = 9;
  bool has_emotion_response() const;
  private:
  bool _internal_has_emotion_response() const;
  public:
  void clear_emotion_response();
  const ::service::EmotionResponse& emotion_response() const;
  PROTOBUF_NODISCARD ::service::EmotionResponse* release_emotion_response();
  ::service::EmotionResponse* mutable_emotion_response();
  void set_allocated_emotion_response(::service::EmotionResponse* emotion_response);
  private:
  const ::service::EmotionResponse& _internal_emotion_response() const;
  ::service::EmotionResponse* _internal_mutable_emotion_response();
  public:
  void unsafe_arena_set_allocated_emotion_response(
      ::service::EmotionResponse* emotion_response);
  ::service::EmotionResponse* unsafe_arena_release_emotion_response();

  // bool end_of_response = 4;
  void clear_end_of_response();
  bool end_of_response() const;
  void set_end_of_response(bool value);
  private:
  bool _internal_end_of_response() const;
  void _internal_set_end_of_response(bool value);
  public:

  // .service.VisemesData visemes_data = 6;
  bool has_visemes_data() const;
  private:
  bool _internal_has_visemes_data() const;
  public:
  void clear_visemes_data();
  const ::service::VisemesData& visemes_data() const;
  PROTOBUF_NODISCARD ::service::VisemesData* release_visemes_data();
  ::service::VisemesData* mutable_visemes_data();
  void set_allocated_visemes_data(::service::VisemesData* visemes_data);
  private:
  const ::service::VisemesData& _internal_visemes_data() const;
  ::service::VisemesData* _internal_mutable_visemes_data();
  public:
  void unsafe_arena_set_allocated_visemes_data(
      ::service::VisemesData* visemes_data);
  ::service::VisemesData* unsafe_arena_release_visemes_data();

  // .service.BlendShapesData blendshapes_data = 7;
  bool has_blendshapes_data() const;
  private:
  bool _internal_has_blendshapes_data() const;
  public:
  void clear_blendshapes_data();
  const ::service::BlendShapesData& blendshapes_data() const;
  PROTOBUF_NODISCARD ::service::BlendShapesData* release_blendshapes_data();
  ::service::BlendShapesData* mutable_blendshapes_data();
  void set_allocated_blendshapes_data(::service::BlendShapesData* blendshapes_data);
  private:
  const ::service::BlendShapesData& _internal_blendshapes_data() const;
  ::service::BlendShapesData* _internal_mutable_blendshapes_data();
  public:
  void unsafe_arena_set_allocated_blendshapes_data(
      ::service::BlendShapesData* blendshapes_data);
  ::service::BlendShapesData* unsafe_arena_release_blendshapes_data();

  void clear_face_data_type();
  FaceDataTypeCase face_data_type_case() const;
  // @@protoc_insertion_point(class_scope:service.GetResponseResponse.AudioResponse)
 private:
  class _Internal;
  void set_has_visemes_data();
  void set_has_blendshapes_data();

  inline bool has_face_data_type() const;
  inline void clear_has_face_data_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr face_data_;
    ::service::AudioConfig* audio_config_;
    ::service::ARKitBlendShapesData* face_emotion_;
    ::service::EmotionResponse* emotion_response_;
    bool end_of_response_;
    union FaceDataTypeUnion {
      constexpr FaceDataTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::service::VisemesData* visemes_data_;
      ::service::BlendShapesData* blendshapes_data_;
    } face_data_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseResponse_ActionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.GetResponseResponse.ActionResponse) */ {
 public:
  inline GetResponseResponse_ActionResponse() : GetResponseResponse_ActionResponse(nullptr) {}
  ~GetResponseResponse_ActionResponse() override;
  explicit PROTOBUF_CONSTEXPR GetResponseResponse_ActionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResponseResponse_ActionResponse(const GetResponseResponse_ActionResponse& from);
  GetResponseResponse_ActionResponse(GetResponseResponse_ActionResponse&& from) noexcept
    : GetResponseResponse_ActionResponse() {
    *this = ::std::move(from);
  }

  inline GetResponseResponse_ActionResponse& operator=(const GetResponseResponse_ActionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseResponse_ActionResponse& operator=(GetResponseResponse_ActionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponseResponse_ActionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetResponseResponse_ActionResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponseResponse_ActionResponse*>(
               &_GetResponseResponse_ActionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetResponseResponse_ActionResponse& a, GetResponseResponse_ActionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponseResponse_ActionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseResponse_ActionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponseResponse_ActionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResponseResponse_ActionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResponseResponse_ActionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetResponseResponse_ActionResponse& from) {
    GetResponseResponse_ActionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponseResponse_ActionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.GetResponseResponse.ActionResponse";
  }
  protected:
  explicit GetResponseResponse_ActionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 1,
  };
  // string action = 1;
  void clear_action();
  const std::string& action() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_action(ArgT0&& arg0, ArgT... args);
  std::string* mutable_action();
  PROTOBUF_NODISCARD std::string* release_action();
  void set_allocated_action(std::string* action);
  private:
  const std::string& _internal_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action(const std::string& value);
  std::string* _internal_mutable_action();
  public:

  // @@protoc_insertion_point(class_scope:service.GetResponseResponse.ActionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseResponse_BehaviorTreeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.GetResponseResponse.BehaviorTreeResponse) */ {
 public:
  inline GetResponseResponse_BehaviorTreeResponse() : GetResponseResponse_BehaviorTreeResponse(nullptr) {}
  ~GetResponseResponse_BehaviorTreeResponse() override;
  explicit PROTOBUF_CONSTEXPR GetResponseResponse_BehaviorTreeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResponseResponse_BehaviorTreeResponse(const GetResponseResponse_BehaviorTreeResponse& from);
  GetResponseResponse_BehaviorTreeResponse(GetResponseResponse_BehaviorTreeResponse&& from) noexcept
    : GetResponseResponse_BehaviorTreeResponse() {
    *this = ::std::move(from);
  }

  inline GetResponseResponse_BehaviorTreeResponse& operator=(const GetResponseResponse_BehaviorTreeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseResponse_BehaviorTreeResponse& operator=(GetResponseResponse_BehaviorTreeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponseResponse_BehaviorTreeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetResponseResponse_BehaviorTreeResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponseResponse_BehaviorTreeResponse*>(
               &_GetResponseResponse_BehaviorTreeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(GetResponseResponse_BehaviorTreeResponse& a, GetResponseResponse_BehaviorTreeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponseResponse_BehaviorTreeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseResponse_BehaviorTreeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponseResponse_BehaviorTreeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResponseResponse_BehaviorTreeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResponseResponse_BehaviorTreeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetResponseResponse_BehaviorTreeResponse& from) {
    GetResponseResponse_BehaviorTreeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponseResponse_BehaviorTreeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.GetResponseResponse.BehaviorTreeResponse";
  }
  protected:
  explicit GetResponseResponse_BehaviorTreeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBtCodeFieldNumber = 1,
    kBtConstantsFieldNumber = 2,
    kNarrativeSectionIdFieldNumber = 3,
  };
  // string bt_code = 1;
  void clear_bt_code();
  const std::string& bt_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bt_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bt_code();
  PROTOBUF_NODISCARD std::string* release_bt_code();
  void set_allocated_bt_code(std::string* bt_code);
  private:
  const std::string& _internal_bt_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bt_code(const std::string& value);
  std::string* _internal_mutable_bt_code();
  public:

  // string bt_constants = 2;
  void clear_bt_constants();
  const std::string& bt_constants() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bt_constants(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bt_constants();
  PROTOBUF_NODISCARD std::string* release_bt_constants();
  void set_allocated_bt_constants(std::string* bt_constants);
  private:
  const std::string& _internal_bt_constants() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bt_constants(const std::string& value);
  std::string* _internal_mutable_bt_constants();
  public:

  // string narrative_section_id = 3;
  void clear_narrative_section_id();
  const std::string& narrative_section_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_narrative_section_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_narrative_section_id();
  PROTOBUF_NODISCARD std::string* release_narrative_section_id();
  void set_allocated_narrative_section_id(std::string* narrative_section_id);
  private:
  const std::string& _internal_narrative_section_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_narrative_section_id(const std::string& value);
  std::string* _internal_mutable_narrative_section_id();
  public:

  // @@protoc_insertion_point(class_scope:service.GetResponseResponse.BehaviorTreeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bt_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bt_constants_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr narrative_section_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseResponse_UserTranscript final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.GetResponseResponse.UserTranscript) */ {
 public:
  inline GetResponseResponse_UserTranscript() : GetResponseResponse_UserTranscript(nullptr) {}
  ~GetResponseResponse_UserTranscript() override;
  explicit PROTOBUF_CONSTEXPR GetResponseResponse_UserTranscript(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResponseResponse_UserTranscript(const GetResponseResponse_UserTranscript& from);
  GetResponseResponse_UserTranscript(GetResponseResponse_UserTranscript&& from) noexcept
    : GetResponseResponse_UserTranscript() {
    *this = ::std::move(from);
  }

  inline GetResponseResponse_UserTranscript& operator=(const GetResponseResponse_UserTranscript& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseResponse_UserTranscript& operator=(GetResponseResponse_UserTranscript&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponseResponse_UserTranscript& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetResponseResponse_UserTranscript* internal_default_instance() {
    return reinterpret_cast<const GetResponseResponse_UserTranscript*>(
               &_GetResponseResponse_UserTranscript_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GetResponseResponse_UserTranscript& a, GetResponseResponse_UserTranscript& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponseResponse_UserTranscript* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseResponse_UserTranscript* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponseResponse_UserTranscript* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResponseResponse_UserTranscript>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResponseResponse_UserTranscript& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetResponseResponse_UserTranscript& from) {
    GetResponseResponse_UserTranscript::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponseResponse_UserTranscript* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.GetResponseResponse.UserTranscript";
  }
  protected:
  explicit GetResponseResponse_UserTranscript(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextDataFieldNumber = 1,
    kIsFinalFieldNumber = 2,
    kEndOfResponseFieldNumber = 3,
  };
  // string text_data = 1;
  void clear_text_data();
  const std::string& text_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text_data();
  PROTOBUF_NODISCARD std::string* release_text_data();
  void set_allocated_text_data(std::string* text_data);
  private:
  const std::string& _internal_text_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text_data(const std::string& value);
  std::string* _internal_mutable_text_data();
  public:

  // bool is_final = 2;
  void clear_is_final();
  bool is_final() const;
  void set_is_final(bool value);
  private:
  bool _internal_is_final() const;
  void _internal_set_is_final(bool value);
  public:

  // bool end_of_response = 3;
  void clear_end_of_response();
  bool end_of_response() const;
  void set_end_of_response(bool value);
  private:
  bool _internal_end_of_response() const;
  void _internal_set_end_of_response(bool value);
  public:

  // @@protoc_insertion_point(class_scope:service.GetResponseResponse.UserTranscript)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_data_;
    bool is_final_;
    bool end_of_response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.GetResponseResponse) */ {
 public:
  inline GetResponseResponse() : GetResponseResponse(nullptr) {}
  ~GetResponseResponse() override;
  explicit PROTOBUF_CONSTEXPR GetResponseResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResponseResponse(const GetResponseResponse& from);
  GetResponseResponse(GetResponseResponse&& from) noexcept
    : GetResponseResponse() {
    *this = ::std::move(from);
  }

  inline GetResponseResponse& operator=(const GetResponseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseResponse& operator=(GetResponseResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponseResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseTypeCase {
    kActionResponse = 2,
    kAudioResponse = 3,
    kDebugLog = 4,
    kUserQuery = 5,
    kBtResponse = 6,
    kEmotionResponse = 7,
    kInteractionId = 8,
    RESPONSE_TYPE_NOT_SET = 0,
  };

  static inline const GetResponseResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponseResponse*>(
               &_GetResponseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(GetResponseResponse& a, GetResponseResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponseResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponseResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResponseResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResponseResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetResponseResponse& from) {
    GetResponseResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponseResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.GetResponseResponse";
  }
  protected:
  explicit GetResponseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetResponseResponse_AudioResponse AudioResponse;
  typedef GetResponseResponse_ActionResponse ActionResponse;
  typedef GetResponseResponse_BehaviorTreeResponse BehaviorTreeResponse;
  typedef GetResponseResponse_UserTranscript UserTranscript;

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kActionResponseFieldNumber = 2,
    kAudioResponseFieldNumber = 3,
    kDebugLogFieldNumber = 4,
    kUserQueryFieldNumber = 5,
    kBtResponseFieldNumber = 6,
    kEmotionResponseFieldNumber = 7,
    kInteractionIdFieldNumber = 8,
  };
  // string session_id = 1;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // .service.GetResponseResponse.ActionResponse action_response = 2;
  bool has_action_response() const;
  private:
  bool _internal_has_action_response() const;
  public:
  void clear_action_response();
  const ::service::GetResponseResponse_ActionResponse& action_response() const;
  PROTOBUF_NODISCARD ::service::GetResponseResponse_ActionResponse* release_action_response();
  ::service::GetResponseResponse_ActionResponse* mutable_action_response();
  void set_allocated_action_response(::service::GetResponseResponse_ActionResponse* action_response);
  private:
  const ::service::GetResponseResponse_ActionResponse& _internal_action_response() const;
  ::service::GetResponseResponse_ActionResponse* _internal_mutable_action_response();
  public:
  void unsafe_arena_set_allocated_action_response(
      ::service::GetResponseResponse_ActionResponse* action_response);
  ::service::GetResponseResponse_ActionResponse* unsafe_arena_release_action_response();

  // .service.GetResponseResponse.AudioResponse audio_response = 3;
  bool has_audio_response() const;
  private:
  bool _internal_has_audio_response() const;
  public:
  void clear_audio_response();
  const ::service::GetResponseResponse_AudioResponse& audio_response() const;
  PROTOBUF_NODISCARD ::service::GetResponseResponse_AudioResponse* release_audio_response();
  ::service::GetResponseResponse_AudioResponse* mutable_audio_response();
  void set_allocated_audio_response(::service::GetResponseResponse_AudioResponse* audio_response);
  private:
  const ::service::GetResponseResponse_AudioResponse& _internal_audio_response() const;
  ::service::GetResponseResponse_AudioResponse* _internal_mutable_audio_response();
  public:
  void unsafe_arena_set_allocated_audio_response(
      ::service::GetResponseResponse_AudioResponse* audio_response);
  ::service::GetResponseResponse_AudioResponse* unsafe_arena_release_audio_response();

  // string debug_log = 4;
  bool has_debug_log() const;
  private:
  bool _internal_has_debug_log() const;
  public:
  void clear_debug_log();
  const std::string& debug_log() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_debug_log(ArgT0&& arg0, ArgT... args);
  std::string* mutable_debug_log();
  PROTOBUF_NODISCARD std::string* release_debug_log();
  void set_allocated_debug_log(std::string* debug_log);
  private:
  const std::string& _internal_debug_log() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_debug_log(const std::string& value);
  std::string* _internal_mutable_debug_log();
  public:

  // .service.GetResponseResponse.UserTranscript user_query = 5;
  bool has_user_query() const;
  private:
  bool _internal_has_user_query() const;
  public:
  void clear_user_query();
  const ::service::GetResponseResponse_UserTranscript& user_query() const;
  PROTOBUF_NODISCARD ::service::GetResponseResponse_UserTranscript* release_user_query();
  ::service::GetResponseResponse_UserTranscript* mutable_user_query();
  void set_allocated_user_query(::service::GetResponseResponse_UserTranscript* user_query);
  private:
  const ::service::GetResponseResponse_UserTranscript& _internal_user_query() const;
  ::service::GetResponseResponse_UserTranscript* _internal_mutable_user_query();
  public:
  void unsafe_arena_set_allocated_user_query(
      ::service::GetResponseResponse_UserTranscript* user_query);
  ::service::GetResponseResponse_UserTranscript* unsafe_arena_release_user_query();

  // .service.GetResponseResponse.BehaviorTreeResponse bt_response = 6;
  bool has_bt_response() const;
  private:
  bool _internal_has_bt_response() const;
  public:
  void clear_bt_response();
  const ::service::GetResponseResponse_BehaviorTreeResponse& bt_response() const;
  PROTOBUF_NODISCARD ::service::GetResponseResponse_BehaviorTreeResponse* release_bt_response();
  ::service::GetResponseResponse_BehaviorTreeResponse* mutable_bt_response();
  void set_allocated_bt_response(::service::GetResponseResponse_BehaviorTreeResponse* bt_response);
  private:
  const ::service::GetResponseResponse_BehaviorTreeResponse& _internal_bt_response() const;
  ::service::GetResponseResponse_BehaviorTreeResponse* _internal_mutable_bt_response();
  public:
  void unsafe_arena_set_allocated_bt_response(
      ::service::GetResponseResponse_BehaviorTreeResponse* bt_response);
  ::service::GetResponseResponse_BehaviorTreeResponse* unsafe_arena_release_bt_response();

  // string emotion_response = 7;
  bool has_emotion_response() const;
  private:
  bool _internal_has_emotion_response() const;
  public:
  void clear_emotion_response();
  const std::string& emotion_response() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_emotion_response(ArgT0&& arg0, ArgT... args);
  std::string* mutable_emotion_response();
  PROTOBUF_NODISCARD std::string* release_emotion_response();
  void set_allocated_emotion_response(std::string* emotion_response);
  private:
  const std::string& _internal_emotion_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_emotion_response(const std::string& value);
  std::string* _internal_mutable_emotion_response();
  public:

  // string interaction_id = 8;
  bool has_interaction_id() const;
  private:
  bool _internal_has_interaction_id() const;
  public:
  void clear_interaction_id();
  const std::string& interaction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_interaction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_interaction_id();
  PROTOBUF_NODISCARD std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* interaction_id);
  private:
  const std::string& _internal_interaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interaction_id(const std::string& value);
  std::string* _internal_mutable_interaction_id();
  public:

  void clear_response_type();
  ResponseTypeCase response_type_case() const;
  // @@protoc_insertion_point(class_scope:service.GetResponseResponse)
 private:
  class _Internal;
  void set_has_action_response();
  void set_has_audio_response();
  void set_has_debug_log();
  void set_has_user_query();
  void set_has_bt_response();
  void set_has_emotion_response();
  void set_has_interaction_id();

  inline bool has_response_type() const;
  inline void clear_has_response_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    union ResponseTypeUnion {
      constexpr ResponseTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::service::GetResponseResponse_ActionResponse* action_response_;
      ::service::GetResponseResponse_AudioResponse* audio_response_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr debug_log_;
      ::service::GetResponseResponse_UserTranscript* user_query_;
      ::service::GetResponseResponse_BehaviorTreeResponse* bt_response_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr emotion_response_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interaction_id_;
    } response_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class VisemesData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.VisemesData) */ {
 public:
  inline VisemesData() : VisemesData(nullptr) {}
  ~VisemesData() override;
  explicit PROTOBUF_CONSTEXPR VisemesData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VisemesData(const VisemesData& from);
  VisemesData(VisemesData&& from) noexcept
    : VisemesData() {
    *this = ::std::move(from);
  }

  inline VisemesData& operator=(const VisemesData& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisemesData& operator=(VisemesData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisemesData& default_instance() {
    return *internal_default_instance();
  }
  static inline const VisemesData* internal_default_instance() {
    return reinterpret_cast<const VisemesData*>(
               &_VisemesData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(VisemesData& a, VisemesData& b) {
    a.Swap(&b);
  }
  inline void Swap(VisemesData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisemesData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisemesData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VisemesData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VisemesData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VisemesData& from) {
    VisemesData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VisemesData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.VisemesData";
  }
  protected:
  explicit VisemesData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVisemesFieldNumber = 1,
  };
  // .service.Viseme visemes = 1;
  bool has_visemes() const;
  private:
  bool _internal_has_visemes() const;
  public:
  void clear_visemes();
  const ::service::Viseme& visemes() const;
  PROTOBUF_NODISCARD ::service::Viseme* release_visemes();
  ::service::Viseme* mutable_visemes();
  void set_allocated_visemes(::service::Viseme* visemes);
  private:
  const ::service::Viseme& _internal_visemes() const;
  ::service::Viseme* _internal_mutable_visemes();
  public:
  void unsafe_arena_set_allocated_visemes(
      ::service::Viseme* visemes);
  ::service::Viseme* unsafe_arena_release_visemes();

  // @@protoc_insertion_point(class_scope:service.VisemesData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::service::Viseme* visemes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class EmotionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.EmotionResponse) */ {
 public:
  inline EmotionResponse() : EmotionResponse(nullptr) {}
  ~EmotionResponse() override;
  explicit PROTOBUF_CONSTEXPR EmotionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmotionResponse(const EmotionResponse& from);
  EmotionResponse(EmotionResponse&& from) noexcept
    : EmotionResponse() {
    *this = ::std::move(from);
  }

  inline EmotionResponse& operator=(const EmotionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmotionResponse& operator=(EmotionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmotionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmotionResponse* internal_default_instance() {
    return reinterpret_cast<const EmotionResponse*>(
               &_EmotionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(EmotionResponse& a, EmotionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EmotionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmotionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmotionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmotionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EmotionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EmotionResponse& from) {
    EmotionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmotionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.EmotionResponse";
  }
  protected:
  explicit EmotionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmotionFieldNumber = 1,
    kScaleFieldNumber = 2,
  };
  // string emotion = 1;
  void clear_emotion();
  const std::string& emotion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_emotion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_emotion();
  PROTOBUF_NODISCARD std::string* release_emotion();
  void set_allocated_emotion(std::string* emotion);
  private:
  const std::string& _internal_emotion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_emotion(const std::string& value);
  std::string* _internal_mutable_emotion();
  public:

  // string scale = 2;
  void clear_scale();
  const std::string& scale() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_scale(ArgT0&& arg0, ArgT... args);
  std::string* mutable_scale();
  PROTOBUF_NODISCARD std::string* release_scale();
  void set_allocated_scale(std::string* scale);
  private:
  const std::string& _internal_scale() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_scale(const std::string& value);
  std::string* _internal_mutable_scale();
  public:

  // @@protoc_insertion_point(class_scope:service.EmotionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr emotion_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scale_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class Viseme final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.Viseme) */ {
 public:
  inline Viseme() : Viseme(nullptr) {}
  ~Viseme() override;
  explicit PROTOBUF_CONSTEXPR Viseme(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Viseme(const Viseme& from);
  Viseme(Viseme&& from) noexcept
    : Viseme() {
    *this = ::std::move(from);
  }

  inline Viseme& operator=(const Viseme& from) {
    CopyFrom(from);
    return *this;
  }
  inline Viseme& operator=(Viseme&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Viseme& default_instance() {
    return *internal_default_instance();
  }
  static inline const Viseme* internal_default_instance() {
    return reinterpret_cast<const Viseme*>(
               &_Viseme_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Viseme& a, Viseme& b) {
    a.Swap(&b);
  }
  inline void Swap(Viseme* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Viseme* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Viseme* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Viseme>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Viseme& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Viseme& from) {
    Viseme::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Viseme* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.Viseme";
  }
  protected:
  explicit Viseme(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSilFieldNumber = 1,
    kPpFieldNumber = 2,
    kFfFieldNumber = 3,
    kThFieldNumber = 4,
    kDdFieldNumber = 5,
    kKkFieldNumber = 6,
    kChFieldNumber = 7,
    kSsFieldNumber = 8,
    kNnFieldNumber = 9,
    kRrFieldNumber = 10,
    kAaFieldNumber = 11,
    kEFieldNumber = 12,
    kIhFieldNumber = 13,
    kOhFieldNumber = 14,
    kOuFieldNumber = 15,
  };
  // float sil = 1;
  void clear_sil();
  float sil() const;
  void set_sil(float value);
  private:
  float _internal_sil() const;
  void _internal_set_sil(float value);
  public:

  // float pp = 2;
  void clear_pp();
  float pp() const;
  void set_pp(float value);
  private:
  float _internal_pp() const;
  void _internal_set_pp(float value);
  public:

  // float ff = 3;
  void clear_ff();
  float ff() const;
  void set_ff(float value);
  private:
  float _internal_ff() const;
  void _internal_set_ff(float value);
  public:

  // float th = 4;
  void clear_th();
  float th() const;
  void set_th(float value);
  private:
  float _internal_th() const;
  void _internal_set_th(float value);
  public:

  // float dd = 5;
  void clear_dd();
  float dd() const;
  void set_dd(float value);
  private:
  float _internal_dd() const;
  void _internal_set_dd(float value);
  public:

  // float kk = 6;
  void clear_kk();
  float kk() const;
  void set_kk(float value);
  private:
  float _internal_kk() const;
  void _internal_set_kk(float value);
  public:

  // float ch = 7;
  void clear_ch();
  float ch() const;
  void set_ch(float value);
  private:
  float _internal_ch() const;
  void _internal_set_ch(float value);
  public:

  // float ss = 8;
  void clear_ss();
  float ss() const;
  void set_ss(float value);
  private:
  float _internal_ss() const;
  void _internal_set_ss(float value);
  public:

  // float nn = 9;
  void clear_nn();
  float nn() const;
  void set_nn(float value);
  private:
  float _internal_nn() const;
  void _internal_set_nn(float value);
  public:

  // float rr = 10;
  void clear_rr();
  float rr() const;
  void set_rr(float value);
  private:
  float _internal_rr() const;
  void _internal_set_rr(float value);
  public:

  // float aa = 11;
  void clear_aa();
  float aa() const;
  void set_aa(float value);
  private:
  float _internal_aa() const;
  void _internal_set_aa(float value);
  public:

  // float e = 12;
  void clear_e();
  float e() const;
  void set_e(float value);
  private:
  float _internal_e() const;
  void _internal_set_e(float value);
  public:

  // float ih = 13;
  void clear_ih();
  float ih() const;
  void set_ih(float value);
  private:
  float _internal_ih() const;
  void _internal_set_ih(float value);
  public:

  // float oh = 14;
  void clear_oh();
  float oh() const;
  void set_oh(float value);
  private:
  float _internal_oh() const;
  void _internal_set_oh(float value);
  public:

  // float ou = 15;
  void clear_ou();
  float ou() const;
  void set_ou(float value);
  private:
  float _internal_ou() const;
  void _internal_set_ou(float value);
  public:

  // @@protoc_insertion_point(class_scope:service.Viseme)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float sil_;
    float pp_;
    float ff_;
    float th_;
    float dd_;
    float kk_;
    float ch_;
    float ss_;
    float nn_;
    float rr_;
    float aa_;
    float e_;
    float ih_;
    float oh_;
    float ou_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class BlendShapesData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.BlendShapesData) */ {
 public:
  inline BlendShapesData() : BlendShapesData(nullptr) {}
  ~BlendShapesData() override;
  explicit PROTOBUF_CONSTEXPR BlendShapesData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlendShapesData(const BlendShapesData& from);
  BlendShapesData(BlendShapesData&& from) noexcept
    : BlendShapesData() {
    *this = ::std::move(from);
  }

  inline BlendShapesData& operator=(const BlendShapesData& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlendShapesData& operator=(BlendShapesData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlendShapesData& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlendShapesData* internal_default_instance() {
    return reinterpret_cast<const BlendShapesData*>(
               &_BlendShapesData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(BlendShapesData& a, BlendShapesData& b) {
    a.Swap(&b);
  }
  inline void Swap(BlendShapesData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlendShapesData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlendShapesData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlendShapesData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlendShapesData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlendShapesData& from) {
    BlendShapesData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlendShapesData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.BlendShapesData";
  }
  protected:
  explicit BlendShapesData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlendshapeDataFieldNumber = 1,
  };
  // string blendshape_data = 1;
  void clear_blendshape_data();
  const std::string& blendshape_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blendshape_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blendshape_data();
  PROTOBUF_NODISCARD std::string* release_blendshape_data();
  void set_allocated_blendshape_data(std::string* blendshape_data);
  private:
  const std::string& _internal_blendshape_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blendshape_data(const std::string& value);
  std::string* _internal_mutable_blendshape_data();
  public:

  // @@protoc_insertion_point(class_scope:service.BlendShapesData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blendshape_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class HelloRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.HelloRequest) */ {
 public:
  inline HelloRequest() : HelloRequest(nullptr) {}
  ~HelloRequest() override;
  explicit PROTOBUF_CONSTEXPR HelloRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HelloRequest(const HelloRequest& from);
  HelloRequest(HelloRequest&& from) noexcept
    : HelloRequest() {
    *this = ::std::move(from);
  }

  inline HelloRequest& operator=(const HelloRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloRequest& operator=(HelloRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HelloRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HelloRequest* internal_default_instance() {
    return reinterpret_cast<const HelloRequest*>(
               &_HelloRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(HelloRequest& a, HelloRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HelloRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HelloRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HelloRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HelloRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HelloRequest& from) {
    HelloRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.HelloRequest";
  }
  protected:
  explicit HelloRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:service.HelloRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class HelloResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.HelloResponse) */ {
 public:
  inline HelloResponse() : HelloResponse(nullptr) {}
  ~HelloResponse() override;
  explicit PROTOBUF_CONSTEXPR HelloResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HelloResponse(const HelloResponse& from);
  HelloResponse(HelloResponse&& from) noexcept
    : HelloResponse() {
    *this = ::std::move(from);
  }

  inline HelloResponse& operator=(const HelloResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloResponse& operator=(HelloResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HelloResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HelloResponse* internal_default_instance() {
    return reinterpret_cast<const HelloResponse*>(
               &_HelloResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(HelloResponse& a, HelloResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HelloResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HelloResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HelloResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HelloResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HelloResponse& from) {
    HelloResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.HelloResponse";
  }
  protected:
  explicit HelloResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:service.HelloResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class FeedbackRequest_Feedback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.FeedbackRequest.Feedback) */ {
 public:
  inline FeedbackRequest_Feedback() : FeedbackRequest_Feedback(nullptr) {}
  ~FeedbackRequest_Feedback() override;
  explicit PROTOBUF_CONSTEXPR FeedbackRequest_Feedback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeedbackRequest_Feedback(const FeedbackRequest_Feedback& from);
  FeedbackRequest_Feedback(FeedbackRequest_Feedback&& from) noexcept
    : FeedbackRequest_Feedback() {
    *this = ::std::move(from);
  }

  inline FeedbackRequest_Feedback& operator=(const FeedbackRequest_Feedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedbackRequest_Feedback& operator=(FeedbackRequest_Feedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedbackRequest_Feedback& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedbackRequest_Feedback* internal_default_instance() {
    return reinterpret_cast<const FeedbackRequest_Feedback*>(
               &_FeedbackRequest_Feedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(FeedbackRequest_Feedback& a, FeedbackRequest_Feedback& b) {
    a.Swap(&b);
  }
  inline void Swap(FeedbackRequest_Feedback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedbackRequest_Feedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedbackRequest_Feedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeedbackRequest_Feedback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeedbackRequest_Feedback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeedbackRequest_Feedback& from) {
    FeedbackRequest_Feedback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeedbackRequest_Feedback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.FeedbackRequest.Feedback";
  }
  protected:
  explicit FeedbackRequest_Feedback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 3,
    kFeedbackTextFieldNumber = 2,
    kThumbsUpFieldNumber = 1,
    kIsTestCaseFieldNumber = 4,
  };
  // repeated string tags = 3;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // string feedback_text = 2;
  void clear_feedback_text();
  const std::string& feedback_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_feedback_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_feedback_text();
  PROTOBUF_NODISCARD std::string* release_feedback_text();
  void set_allocated_feedback_text(std::string* feedback_text);
  private:
  const std::string& _internal_feedback_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feedback_text(const std::string& value);
  std::string* _internal_mutable_feedback_text();
  public:

  // bool thumbs_up = 1;
  void clear_thumbs_up();
  bool thumbs_up() const;
  void set_thumbs_up(bool value);
  private:
  bool _internal_thumbs_up() const;
  void _internal_set_thumbs_up(bool value);
  public:

  // bool is_test_case = 4;
  void clear_is_test_case();
  bool is_test_case() const;
  void set_is_test_case(bool value);
  private:
  bool _internal_is_test_case() const;
  void _internal_set_is_test_case(bool value);
  public:

  // @@protoc_insertion_point(class_scope:service.FeedbackRequest.Feedback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feedback_text_;
    bool thumbs_up_;
    bool is_test_case_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class FeedbackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.FeedbackRequest) */ {
 public:
  inline FeedbackRequest() : FeedbackRequest(nullptr) {}
  ~FeedbackRequest() override;
  explicit PROTOBUF_CONSTEXPR FeedbackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeedbackRequest(const FeedbackRequest& from);
  FeedbackRequest(FeedbackRequest&& from) noexcept
    : FeedbackRequest() {
    *this = ::std::move(from);
  }

  inline FeedbackRequest& operator=(const FeedbackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedbackRequest& operator=(FeedbackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedbackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedbackRequest* internal_default_instance() {
    return reinterpret_cast<const FeedbackRequest*>(
               &_FeedbackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(FeedbackRequest& a, FeedbackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FeedbackRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedbackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedbackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeedbackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeedbackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeedbackRequest& from) {
    FeedbackRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeedbackRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.FeedbackRequest";
  }
  protected:
  explicit FeedbackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FeedbackRequest_Feedback Feedback;

  // accessors -------------------------------------------------------

  enum : int {
    kInteractionIdFieldNumber = 1,
    kCharacterIdFieldNumber = 2,
    kSessionIdFieldNumber = 3,
    kUserQueryFieldNumber = 6,
    kResponseFieldNumber = 7,
    kTextFeedbackFieldNumber = 5,
  };
  // string interaction_id = 1;
  void clear_interaction_id();
  const std::string& interaction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_interaction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_interaction_id();
  PROTOBUF_NODISCARD std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* interaction_id);
  private:
  const std::string& _internal_interaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interaction_id(const std::string& value);
  std::string* _internal_mutable_interaction_id();
  public:

  // string character_id = 2;
  void clear_character_id();
  const std::string& character_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_character_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_character_id();
  PROTOBUF_NODISCARD std::string* release_character_id();
  void set_allocated_character_id(std::string* character_id);
  private:
  const std::string& _internal_character_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_character_id(const std::string& value);
  std::string* _internal_mutable_character_id();
  public:

  // string session_id = 3;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // string user_query = 6;
  void clear_user_query();
  const std::string& user_query() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_query(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_query();
  PROTOBUF_NODISCARD std::string* release_user_query();
  void set_allocated_user_query(std::string* user_query);
  private:
  const std::string& _internal_user_query() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_query(const std::string& value);
  std::string* _internal_mutable_user_query();
  public:

  // string response = 7;
  void clear_response();
  const std::string& response() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_response(ArgT0&& arg0, ArgT... args);
  std::string* mutable_response();
  PROTOBUF_NODISCARD std::string* release_response();
  void set_allocated_response(std::string* response);
  private:
  const std::string& _internal_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response(const std::string& value);
  std::string* _internal_mutable_response();
  public:

  // .service.FeedbackRequest.Feedback text_feedback = 5;
  bool has_text_feedback() const;
  private:
  bool _internal_has_text_feedback() const;
  public:
  void clear_text_feedback();
  const ::service::FeedbackRequest_Feedback& text_feedback() const;
  PROTOBUF_NODISCARD ::service::FeedbackRequest_Feedback* release_text_feedback();
  ::service::FeedbackRequest_Feedback* mutable_text_feedback();
  void set_allocated_text_feedback(::service::FeedbackRequest_Feedback* text_feedback);
  private:
  const ::service::FeedbackRequest_Feedback& _internal_text_feedback() const;
  ::service::FeedbackRequest_Feedback* _internal_mutable_text_feedback();
  public:
  void unsafe_arena_set_allocated_text_feedback(
      ::service::FeedbackRequest_Feedback* text_feedback);
  ::service::FeedbackRequest_Feedback* unsafe_arena_release_text_feedback();

  // @@protoc_insertion_point(class_scope:service.FeedbackRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interaction_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr character_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_query_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr response_;
    ::service::FeedbackRequest_Feedback* text_feedback_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class FeedbackResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.FeedbackResponse) */ {
 public:
  inline FeedbackResponse() : FeedbackResponse(nullptr) {}
  ~FeedbackResponse() override;
  explicit PROTOBUF_CONSTEXPR FeedbackResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeedbackResponse(const FeedbackResponse& from);
  FeedbackResponse(FeedbackResponse&& from) noexcept
    : FeedbackResponse() {
    *this = ::std::move(from);
  }

  inline FeedbackResponse& operator=(const FeedbackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedbackResponse& operator=(FeedbackResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedbackResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedbackResponse* internal_default_instance() {
    return reinterpret_cast<const FeedbackResponse*>(
               &_FeedbackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(FeedbackResponse& a, FeedbackResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FeedbackResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedbackResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedbackResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeedbackResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeedbackResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeedbackResponse& from) {
    FeedbackResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeedbackResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.FeedbackResponse";
  }
  protected:
  explicit FeedbackResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeedbackResponseFieldNumber = 1,
  };
  // string feedback_response = 1;
  void clear_feedback_response();
  const std::string& feedback_response() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_feedback_response(ArgT0&& arg0, ArgT... args);
  std::string* mutable_feedback_response();
  PROTOBUF_NODISCARD std::string* release_feedback_response();
  void set_allocated_feedback_response(std::string* feedback_response);
  private:
  const std::string& _internal_feedback_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feedback_response(const std::string& value);
  std::string* _internal_mutable_feedback_response();
  public:

  // @@protoc_insertion_point(class_scope:service.FeedbackResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feedback_response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AudioConfig

// int32 sample_rate_hertz = 1;
inline void AudioConfig::clear_sample_rate_hertz() {
  _impl_.sample_rate_hertz_ = 0;
}
inline int32_t AudioConfig::_internal_sample_rate_hertz() const {
  return _impl_.sample_rate_hertz_;
}
inline int32_t AudioConfig::sample_rate_hertz() const {
  // @@protoc_insertion_point(field_get:service.AudioConfig.sample_rate_hertz)
  return _internal_sample_rate_hertz();
}
inline void AudioConfig::_internal_set_sample_rate_hertz(int32_t value) {
  
  _impl_.sample_rate_hertz_ = value;
}
inline void AudioConfig::set_sample_rate_hertz(int32_t value) {
  _internal_set_sample_rate_hertz(value);
  // @@protoc_insertion_point(field_set:service.AudioConfig.sample_rate_hertz)
}

// bool disable_audio = 2;
inline void AudioConfig::clear_disable_audio() {
  _impl_.disable_audio_ = false;
}
inline bool AudioConfig::_internal_disable_audio() const {
  return _impl_.disable_audio_;
}
inline bool AudioConfig::disable_audio() const {
  // @@protoc_insertion_point(field_get:service.AudioConfig.disable_audio)
  return _internal_disable_audio();
}
inline void AudioConfig::_internal_set_disable_audio(bool value) {
  
  _impl_.disable_audio_ = value;
}
inline void AudioConfig::set_disable_audio(bool value) {
  _internal_set_disable_audio(value);
  // @@protoc_insertion_point(field_set:service.AudioConfig.disable_audio)
}

// bool enable_facial_data = 3;
inline void AudioConfig::clear_enable_facial_data() {
  _impl_.enable_facial_data_ = false;
}
inline bool AudioConfig::_internal_enable_facial_data() const {
  return _impl_.enable_facial_data_;
}
inline bool AudioConfig::enable_facial_data() const {
  // @@protoc_insertion_point(field_get:service.AudioConfig.enable_facial_data)
  return _internal_enable_facial_data();
}
inline void AudioConfig::_internal_set_enable_facial_data(bool value) {
  
  _impl_.enable_facial_data_ = value;
}
inline void AudioConfig::set_enable_facial_data(bool value) {
  _internal_set_enable_facial_data(value);
  // @@protoc_insertion_point(field_set:service.AudioConfig.enable_facial_data)
}

// .service.FaceModel face_model = 4;
inline void AudioConfig::clear_face_model() {
  _impl_.face_model_ = 0;
}
inline ::service::FaceModel AudioConfig::_internal_face_model() const {
  return static_cast< ::service::FaceModel >(_impl_.face_model_);
}
inline ::service::FaceModel AudioConfig::face_model() const {
  // @@protoc_insertion_point(field_get:service.AudioConfig.face_model)
  return _internal_face_model();
}
inline void AudioConfig::_internal_set_face_model(::service::FaceModel value) {
  
  _impl_.face_model_ = value;
}
inline void AudioConfig::set_face_model(::service::FaceModel value) {
  _internal_set_face_model(value);
  // @@protoc_insertion_point(field_set:service.AudioConfig.face_model)
}

// bool enable_facial_emotion_data = 5;
inline void AudioConfig::clear_enable_facial_emotion_data() {
  _impl_.enable_facial_emotion_data_ = false;
}
inline bool AudioConfig::_internal_enable_facial_emotion_data() const {
  return _impl_.enable_facial_emotion_data_;
}
inline bool AudioConfig::enable_facial_emotion_data() const {
  // @@protoc_insertion_point(field_get:service.AudioConfig.enable_facial_emotion_data)
  return _internal_enable_facial_emotion_data();
}
inline void AudioConfig::_internal_set_enable_facial_emotion_data(bool value) {
  
  _impl_.enable_facial_emotion_data_ = value;
}
inline void AudioConfig::set_enable_facial_emotion_data(bool value) {
  _internal_set_enable_facial_emotion_data(value);
  // @@protoc_insertion_point(field_set:service.AudioConfig.enable_facial_emotion_data)
}

// -------------------------------------------------------------------

// TriggerConfig

// string trigger_name = 1;
inline void TriggerConfig::clear_trigger_name() {
  _impl_.trigger_name_.ClearToEmpty();
}
inline const std::string& TriggerConfig::trigger_name() const {
  // @@protoc_insertion_point(field_get:service.TriggerConfig.trigger_name)
  return _internal_trigger_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TriggerConfig::set_trigger_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.trigger_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.TriggerConfig.trigger_name)
}
inline std::string* TriggerConfig::mutable_trigger_name() {
  std::string* _s = _internal_mutable_trigger_name();
  // @@protoc_insertion_point(field_mutable:service.TriggerConfig.trigger_name)
  return _s;
}
inline const std::string& TriggerConfig::_internal_trigger_name() const {
  return _impl_.trigger_name_.Get();
}
inline void TriggerConfig::_internal_set_trigger_name(const std::string& value) {
  
  _impl_.trigger_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TriggerConfig::_internal_mutable_trigger_name() {
  
  return _impl_.trigger_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TriggerConfig::release_trigger_name() {
  // @@protoc_insertion_point(field_release:service.TriggerConfig.trigger_name)
  return _impl_.trigger_name_.Release();
}
inline void TriggerConfig::set_allocated_trigger_name(std::string* trigger_name) {
  if (trigger_name != nullptr) {
    
  } else {
    
  }
  _impl_.trigger_name_.SetAllocated(trigger_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trigger_name_.IsDefault()) {
    _impl_.trigger_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.TriggerConfig.trigger_name)
}

// string trigger_message = 2;
inline void TriggerConfig::clear_trigger_message() {
  _impl_.trigger_message_.ClearToEmpty();
}
inline const std::string& TriggerConfig::trigger_message() const {
  // @@protoc_insertion_point(field_get:service.TriggerConfig.trigger_message)
  return _internal_trigger_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TriggerConfig::set_trigger_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.trigger_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.TriggerConfig.trigger_message)
}
inline std::string* TriggerConfig::mutable_trigger_message() {
  std::string* _s = _internal_mutable_trigger_message();
  // @@protoc_insertion_point(field_mutable:service.TriggerConfig.trigger_message)
  return _s;
}
inline const std::string& TriggerConfig::_internal_trigger_message() const {
  return _impl_.trigger_message_.Get();
}
inline void TriggerConfig::_internal_set_trigger_message(const std::string& value) {
  
  _impl_.trigger_message_.Set(value, GetArenaForAllocation());
}
inline std::string* TriggerConfig::_internal_mutable_trigger_message() {
  
  return _impl_.trigger_message_.Mutable(GetArenaForAllocation());
}
inline std::string* TriggerConfig::release_trigger_message() {
  // @@protoc_insertion_point(field_release:service.TriggerConfig.trigger_message)
  return _impl_.trigger_message_.Release();
}
inline void TriggerConfig::set_allocated_trigger_message(std::string* trigger_message) {
  if (trigger_message != nullptr) {
    
  } else {
    
  }
  _impl_.trigger_message_.SetAllocated(trigger_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trigger_message_.IsDefault()) {
    _impl_.trigger_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.TriggerConfig.trigger_message)
}

// -------------------------------------------------------------------

// ActionConfig_Character

// string name = 1;
inline void ActionConfig_Character::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ActionConfig_Character::name() const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.Character.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionConfig_Character::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.ActionConfig.Character.name)
}
inline std::string* ActionConfig_Character::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.Character.name)
  return _s;
}
inline const std::string& ActionConfig_Character::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ActionConfig_Character::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ActionConfig_Character::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ActionConfig_Character::release_name() {
  // @@protoc_insertion_point(field_release:service.ActionConfig.Character.name)
  return _impl_.name_.Release();
}
inline void ActionConfig_Character::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.ActionConfig.Character.name)
}

// string bio = 2;
inline void ActionConfig_Character::clear_bio() {
  _impl_.bio_.ClearToEmpty();
}
inline const std::string& ActionConfig_Character::bio() const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.Character.bio)
  return _internal_bio();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionConfig_Character::set_bio(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bio_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.ActionConfig.Character.bio)
}
inline std::string* ActionConfig_Character::mutable_bio() {
  std::string* _s = _internal_mutable_bio();
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.Character.bio)
  return _s;
}
inline const std::string& ActionConfig_Character::_internal_bio() const {
  return _impl_.bio_.Get();
}
inline void ActionConfig_Character::_internal_set_bio(const std::string& value) {
  
  _impl_.bio_.Set(value, GetArenaForAllocation());
}
inline std::string* ActionConfig_Character::_internal_mutable_bio() {
  
  return _impl_.bio_.Mutable(GetArenaForAllocation());
}
inline std::string* ActionConfig_Character::release_bio() {
  // @@protoc_insertion_point(field_release:service.ActionConfig.Character.bio)
  return _impl_.bio_.Release();
}
inline void ActionConfig_Character::set_allocated_bio(std::string* bio) {
  if (bio != nullptr) {
    
  } else {
    
  }
  _impl_.bio_.SetAllocated(bio, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bio_.IsDefault()) {
    _impl_.bio_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.ActionConfig.Character.bio)
}

// -------------------------------------------------------------------

// ActionConfig_Object

// string name = 1;
inline void ActionConfig_Object::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ActionConfig_Object::name() const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.Object.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionConfig_Object::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.ActionConfig.Object.name)
}
inline std::string* ActionConfig_Object::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.Object.name)
  return _s;
}
inline const std::string& ActionConfig_Object::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ActionConfig_Object::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ActionConfig_Object::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ActionConfig_Object::release_name() {
  // @@protoc_insertion_point(field_release:service.ActionConfig.Object.name)
  return _impl_.name_.Release();
}
inline void ActionConfig_Object::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.ActionConfig.Object.name)
}

// string description = 2;
inline void ActionConfig_Object::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ActionConfig_Object::description() const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.Object.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionConfig_Object::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.ActionConfig.Object.description)
}
inline std::string* ActionConfig_Object::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.Object.description)
  return _s;
}
inline const std::string& ActionConfig_Object::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ActionConfig_Object::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ActionConfig_Object::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ActionConfig_Object::release_description() {
  // @@protoc_insertion_point(field_release:service.ActionConfig.Object.description)
  return _impl_.description_.Release();
}
inline void ActionConfig_Object::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.ActionConfig.Object.description)
}

// -------------------------------------------------------------------

// ActionConfig

// repeated string actions = 1;
inline int ActionConfig::_internal_actions_size() const {
  return _impl_.actions_.size();
}
inline int ActionConfig::actions_size() const {
  return _internal_actions_size();
}
inline void ActionConfig::clear_actions() {
  _impl_.actions_.Clear();
}
inline std::string* ActionConfig::add_actions() {
  std::string* _s = _internal_add_actions();
  // @@protoc_insertion_point(field_add_mutable:service.ActionConfig.actions)
  return _s;
}
inline const std::string& ActionConfig::_internal_actions(int index) const {
  return _impl_.actions_.Get(index);
}
inline const std::string& ActionConfig::actions(int index) const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.actions)
  return _internal_actions(index);
}
inline std::string* ActionConfig::mutable_actions(int index) {
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.actions)
  return _impl_.actions_.Mutable(index);
}
inline void ActionConfig::set_actions(int index, const std::string& value) {
  _impl_.actions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:service.ActionConfig.actions)
}
inline void ActionConfig::set_actions(int index, std::string&& value) {
  _impl_.actions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:service.ActionConfig.actions)
}
inline void ActionConfig::set_actions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.actions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:service.ActionConfig.actions)
}
inline void ActionConfig::set_actions(int index, const char* value, size_t size) {
  _impl_.actions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:service.ActionConfig.actions)
}
inline std::string* ActionConfig::_internal_add_actions() {
  return _impl_.actions_.Add();
}
inline void ActionConfig::add_actions(const std::string& value) {
  _impl_.actions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:service.ActionConfig.actions)
}
inline void ActionConfig::add_actions(std::string&& value) {
  _impl_.actions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:service.ActionConfig.actions)
}
inline void ActionConfig::add_actions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.actions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:service.ActionConfig.actions)
}
inline void ActionConfig::add_actions(const char* value, size_t size) {
  _impl_.actions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:service.ActionConfig.actions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ActionConfig::actions() const {
  // @@protoc_insertion_point(field_list:service.ActionConfig.actions)
  return _impl_.actions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ActionConfig::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:service.ActionConfig.actions)
  return &_impl_.actions_;
}

// repeated .service.ActionConfig.Character characters = 2;
inline int ActionConfig::_internal_characters_size() const {
  return _impl_.characters_.size();
}
inline int ActionConfig::characters_size() const {
  return _internal_characters_size();
}
inline void ActionConfig::clear_characters() {
  _impl_.characters_.Clear();
}
inline ::service::ActionConfig_Character* ActionConfig::mutable_characters(int index) {
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.characters)
  return _impl_.characters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Character >*
ActionConfig::mutable_characters() {
  // @@protoc_insertion_point(field_mutable_list:service.ActionConfig.characters)
  return &_impl_.characters_;
}
inline const ::service::ActionConfig_Character& ActionConfig::_internal_characters(int index) const {
  return _impl_.characters_.Get(index);
}
inline const ::service::ActionConfig_Character& ActionConfig::characters(int index) const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.characters)
  return _internal_characters(index);
}
inline ::service::ActionConfig_Character* ActionConfig::_internal_add_characters() {
  return _impl_.characters_.Add();
}
inline ::service::ActionConfig_Character* ActionConfig::add_characters() {
  ::service::ActionConfig_Character* _add = _internal_add_characters();
  // @@protoc_insertion_point(field_add:service.ActionConfig.characters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Character >&
ActionConfig::characters() const {
  // @@protoc_insertion_point(field_list:service.ActionConfig.characters)
  return _impl_.characters_;
}

// repeated .service.ActionConfig.Object objects = 3;
inline int ActionConfig::_internal_objects_size() const {
  return _impl_.objects_.size();
}
inline int ActionConfig::objects_size() const {
  return _internal_objects_size();
}
inline void ActionConfig::clear_objects() {
  _impl_.objects_.Clear();
}
inline ::service::ActionConfig_Object* ActionConfig::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.objects)
  return _impl_.objects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Object >*
ActionConfig::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:service.ActionConfig.objects)
  return &_impl_.objects_;
}
inline const ::service::ActionConfig_Object& ActionConfig::_internal_objects(int index) const {
  return _impl_.objects_.Get(index);
}
inline const ::service::ActionConfig_Object& ActionConfig::objects(int index) const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.objects)
  return _internal_objects(index);
}
inline ::service::ActionConfig_Object* ActionConfig::_internal_add_objects() {
  return _impl_.objects_.Add();
}
inline ::service::ActionConfig_Object* ActionConfig::add_objects() {
  ::service::ActionConfig_Object* _add = _internal_add_objects();
  // @@protoc_insertion_point(field_add:service.ActionConfig.objects)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Object >&
ActionConfig::objects() const {
  // @@protoc_insertion_point(field_list:service.ActionConfig.objects)
  return _impl_.objects_;
}

// string classification = 4;
inline void ActionConfig::clear_classification() {
  _impl_.classification_.ClearToEmpty();
}
inline const std::string& ActionConfig::classification() const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.classification)
  return _internal_classification();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionConfig::set_classification(ArgT0&& arg0, ArgT... args) {
 
 _impl_.classification_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.ActionConfig.classification)
}
inline std::string* ActionConfig::mutable_classification() {
  std::string* _s = _internal_mutable_classification();
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.classification)
  return _s;
}
inline const std::string& ActionConfig::_internal_classification() const {
  return _impl_.classification_.Get();
}
inline void ActionConfig::_internal_set_classification(const std::string& value) {
  
  _impl_.classification_.Set(value, GetArenaForAllocation());
}
inline std::string* ActionConfig::_internal_mutable_classification() {
  
  return _impl_.classification_.Mutable(GetArenaForAllocation());
}
inline std::string* ActionConfig::release_classification() {
  // @@protoc_insertion_point(field_release:service.ActionConfig.classification)
  return _impl_.classification_.Release();
}
inline void ActionConfig::set_allocated_classification(std::string* classification) {
  if (classification != nullptr) {
    
  } else {
    
  }
  _impl_.classification_.SetAllocated(classification, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.classification_.IsDefault()) {
    _impl_.classification_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.ActionConfig.classification)
}

// int32 context_level = 5;
inline void ActionConfig::clear_context_level() {
  _impl_.context_level_ = 0;
}
inline int32_t ActionConfig::_internal_context_level() const {
  return _impl_.context_level_;
}
inline int32_t ActionConfig::context_level() const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.context_level)
  return _internal_context_level();
}
inline void ActionConfig::_internal_set_context_level(int32_t value) {
  
  _impl_.context_level_ = value;
}
inline void ActionConfig::set_context_level(int32_t value) {
  _internal_set_context_level(value);
  // @@protoc_insertion_point(field_set:service.ActionConfig.context_level)
}

// string current_attention_object = 6;
inline void ActionConfig::clear_current_attention_object() {
  _impl_.current_attention_object_.ClearToEmpty();
}
inline const std::string& ActionConfig::current_attention_object() const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.current_attention_object)
  return _internal_current_attention_object();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionConfig::set_current_attention_object(ArgT0&& arg0, ArgT... args) {
 
 _impl_.current_attention_object_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.ActionConfig.current_attention_object)
}
inline std::string* ActionConfig::mutable_current_attention_object() {
  std::string* _s = _internal_mutable_current_attention_object();
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.current_attention_object)
  return _s;
}
inline const std::string& ActionConfig::_internal_current_attention_object() const {
  return _impl_.current_attention_object_.Get();
}
inline void ActionConfig::_internal_set_current_attention_object(const std::string& value) {
  
  _impl_.current_attention_object_.Set(value, GetArenaForAllocation());
}
inline std::string* ActionConfig::_internal_mutable_current_attention_object() {
  
  return _impl_.current_attention_object_.Mutable(GetArenaForAllocation());
}
inline std::string* ActionConfig::release_current_attention_object() {
  // @@protoc_insertion_point(field_release:service.ActionConfig.current_attention_object)
  return _impl_.current_attention_object_.Release();
}
inline void ActionConfig::set_allocated_current_attention_object(std::string* current_attention_object) {
  if (current_attention_object != nullptr) {
    
  } else {
    
  }
  _impl_.current_attention_object_.SetAllocated(current_attention_object, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.current_attention_object_.IsDefault()) {
    _impl_.current_attention_object_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.ActionConfig.current_attention_object)
}

// -------------------------------------------------------------------

// STTRequest

// .service.AudioConfig audio_config = 1;
inline bool STTRequest::_internal_has_audio_config() const {
  return request_type_case() == kAudioConfig;
}
inline bool STTRequest::has_audio_config() const {
  return _internal_has_audio_config();
}
inline void STTRequest::set_has_audio_config() {
  _impl_._oneof_case_[0] = kAudioConfig;
}
inline void STTRequest::clear_audio_config() {
  if (_internal_has_audio_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_type_.audio_config_;
    }
    clear_has_request_type();
  }
}
inline ::service::AudioConfig* STTRequest::release_audio_config() {
  // @@protoc_insertion_point(field_release:service.STTRequest.audio_config)
  if (_internal_has_audio_config()) {
    clear_has_request_type();
    ::service::AudioConfig* temp = _impl_.request_type_.audio_config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.audio_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::AudioConfig& STTRequest::_internal_audio_config() const {
  return _internal_has_audio_config()
      ? *_impl_.request_type_.audio_config_
      : reinterpret_cast< ::service::AudioConfig&>(::service::_AudioConfig_default_instance_);
}
inline const ::service::AudioConfig& STTRequest::audio_config() const {
  // @@protoc_insertion_point(field_get:service.STTRequest.audio_config)
  return _internal_audio_config();
}
inline ::service::AudioConfig* STTRequest::unsafe_arena_release_audio_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.STTRequest.audio_config)
  if (_internal_has_audio_config()) {
    clear_has_request_type();
    ::service::AudioConfig* temp = _impl_.request_type_.audio_config_;
    _impl_.request_type_.audio_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void STTRequest::unsafe_arena_set_allocated_audio_config(::service::AudioConfig* audio_config) {
  clear_request_type();
  if (audio_config) {
    set_has_audio_config();
    _impl_.request_type_.audio_config_ = audio_config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.STTRequest.audio_config)
}
inline ::service::AudioConfig* STTRequest::_internal_mutable_audio_config() {
  if (!_internal_has_audio_config()) {
    clear_request_type();
    set_has_audio_config();
    _impl_.request_type_.audio_config_ = CreateMaybeMessage< ::service::AudioConfig >(GetArenaForAllocation());
  }
  return _impl_.request_type_.audio_config_;
}
inline ::service::AudioConfig* STTRequest::mutable_audio_config() {
  ::service::AudioConfig* _msg = _internal_mutable_audio_config();
  // @@protoc_insertion_point(field_mutable:service.STTRequest.audio_config)
  return _msg;
}

// bytes audio_chunk = 2;
inline bool STTRequest::_internal_has_audio_chunk() const {
  return request_type_case() == kAudioChunk;
}
inline bool STTRequest::has_audio_chunk() const {
  return _internal_has_audio_chunk();
}
inline void STTRequest::set_has_audio_chunk() {
  _impl_._oneof_case_[0] = kAudioChunk;
}
inline void STTRequest::clear_audio_chunk() {
  if (_internal_has_audio_chunk()) {
    _impl_.request_type_.audio_chunk_.Destroy();
    clear_has_request_type();
  }
}
inline const std::string& STTRequest::audio_chunk() const {
  // @@protoc_insertion_point(field_get:service.STTRequest.audio_chunk)
  return _internal_audio_chunk();
}
template <typename ArgT0, typename... ArgT>
inline void STTRequest::set_audio_chunk(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_audio_chunk()) {
    clear_request_type();
    set_has_audio_chunk();
    _impl_.request_type_.audio_chunk_.InitDefault();
  }
  _impl_.request_type_.audio_chunk_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.STTRequest.audio_chunk)
}
inline std::string* STTRequest::mutable_audio_chunk() {
  std::string* _s = _internal_mutable_audio_chunk();
  // @@protoc_insertion_point(field_mutable:service.STTRequest.audio_chunk)
  return _s;
}
inline const std::string& STTRequest::_internal_audio_chunk() const {
  if (_internal_has_audio_chunk()) {
    return _impl_.request_type_.audio_chunk_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void STTRequest::_internal_set_audio_chunk(const std::string& value) {
  if (!_internal_has_audio_chunk()) {
    clear_request_type();
    set_has_audio_chunk();
    _impl_.request_type_.audio_chunk_.InitDefault();
  }
  _impl_.request_type_.audio_chunk_.Set(value, GetArenaForAllocation());
}
inline std::string* STTRequest::_internal_mutable_audio_chunk() {
  if (!_internal_has_audio_chunk()) {
    clear_request_type();
    set_has_audio_chunk();
    _impl_.request_type_.audio_chunk_.InitDefault();
  }
  return _impl_.request_type_.audio_chunk_.Mutable(      GetArenaForAllocation());
}
inline std::string* STTRequest::release_audio_chunk() {
  // @@protoc_insertion_point(field_release:service.STTRequest.audio_chunk)
  if (_internal_has_audio_chunk()) {
    clear_has_request_type();
    return _impl_.request_type_.audio_chunk_.Release();
  } else {
    return nullptr;
  }
}
inline void STTRequest::set_allocated_audio_chunk(std::string* audio_chunk) {
  if (has_request_type()) {
    clear_request_type();
  }
  if (audio_chunk != nullptr) {
    set_has_audio_chunk();
    _impl_.request_type_.audio_chunk_.InitAllocated(audio_chunk, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:service.STTRequest.audio_chunk)
}

inline bool STTRequest::has_request_type() const {
  return request_type_case() != REQUEST_TYPE_NOT_SET;
}
inline void STTRequest::clear_has_request_type() {
  _impl_._oneof_case_[0] = REQUEST_TYPE_NOT_SET;
}
inline STTRequest::RequestTypeCase STTRequest::request_type_case() const {
  return STTRequest::RequestTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// STTResponse

// string text = 1;
inline void STTResponse::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& STTResponse::text() const {
  // @@protoc_insertion_point(field_get:service.STTResponse.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void STTResponse::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.STTResponse.text)
}
inline std::string* STTResponse::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:service.STTResponse.text)
  return _s;
}
inline const std::string& STTResponse::_internal_text() const {
  return _impl_.text_.Get();
}
inline void STTResponse::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* STTResponse::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* STTResponse::release_text() {
  // @@protoc_insertion_point(field_release:service.STTResponse.text)
  return _impl_.text_.Release();
}
inline void STTResponse::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.STTResponse.text)
}

// -------------------------------------------------------------------

// DynamicInfoConfig

// string text = 1;
inline void DynamicInfoConfig::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& DynamicInfoConfig::text() const {
  // @@protoc_insertion_point(field_get:service.DynamicInfoConfig.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DynamicInfoConfig::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.DynamicInfoConfig.text)
}
inline std::string* DynamicInfoConfig::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:service.DynamicInfoConfig.text)
  return _s;
}
inline const std::string& DynamicInfoConfig::_internal_text() const {
  return _impl_.text_.Get();
}
inline void DynamicInfoConfig::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* DynamicInfoConfig::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* DynamicInfoConfig::release_text() {
  // @@protoc_insertion_point(field_release:service.DynamicInfoConfig.text)
  return _impl_.text_.Release();
}
inline void DynamicInfoConfig::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.DynamicInfoConfig.text)
}

// -------------------------------------------------------------------

// VisionInput_ImageData

// int32 width = 1;
inline void VisionInput_ImageData::clear_width() {
  _impl_.width_ = 0;
}
inline int32_t VisionInput_ImageData::_internal_width() const {
  return _impl_.width_;
}
inline int32_t VisionInput_ImageData::width() const {
  // @@protoc_insertion_point(field_get:service.VisionInput.ImageData.width)
  return _internal_width();
}
inline void VisionInput_ImageData::_internal_set_width(int32_t value) {
  
  _impl_.width_ = value;
}
inline void VisionInput_ImageData::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:service.VisionInput.ImageData.width)
}

// int32 height = 2;
inline void VisionInput_ImageData::clear_height() {
  _impl_.height_ = 0;
}
inline int32_t VisionInput_ImageData::_internal_height() const {
  return _impl_.height_;
}
inline int32_t VisionInput_ImageData::height() const {
  // @@protoc_insertion_point(field_get:service.VisionInput.ImageData.height)
  return _internal_height();
}
inline void VisionInput_ImageData::_internal_set_height(int32_t value) {
  
  _impl_.height_ = value;
}
inline void VisionInput_ImageData::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:service.VisionInput.ImageData.height)
}

// bytes data = 3;
inline void VisionInput_ImageData::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& VisionInput_ImageData::data() const {
  // @@protoc_insertion_point(field_get:service.VisionInput.ImageData.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VisionInput_ImageData::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.VisionInput.ImageData.data)
}
inline std::string* VisionInput_ImageData::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:service.VisionInput.ImageData.data)
  return _s;
}
inline const std::string& VisionInput_ImageData::_internal_data() const {
  return _impl_.data_.Get();
}
inline void VisionInput_ImageData::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* VisionInput_ImageData::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* VisionInput_ImageData::release_data() {
  // @@protoc_insertion_point(field_release:service.VisionInput.ImageData.data)
  return _impl_.data_.Release();
}
inline void VisionInput_ImageData::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.VisionInput.ImageData.data)
}

// -------------------------------------------------------------------

// VisionInput_VideoData

// int32 fps = 1;
inline void VisionInput_VideoData::clear_fps() {
  _impl_.fps_ = 0;
}
inline int32_t VisionInput_VideoData::_internal_fps() const {
  return _impl_.fps_;
}
inline int32_t VisionInput_VideoData::fps() const {
  // @@protoc_insertion_point(field_get:service.VisionInput.VideoData.fps)
  return _internal_fps();
}
inline void VisionInput_VideoData::_internal_set_fps(int32_t value) {
  
  _impl_.fps_ = value;
}
inline void VisionInput_VideoData::set_fps(int32_t value) {
  _internal_set_fps(value);
  // @@protoc_insertion_point(field_set:service.VisionInput.VideoData.fps)
}

// int32 width = 2;
inline void VisionInput_VideoData::clear_width() {
  _impl_.width_ = 0;
}
inline int32_t VisionInput_VideoData::_internal_width() const {
  return _impl_.width_;
}
inline int32_t VisionInput_VideoData::width() const {
  // @@protoc_insertion_point(field_get:service.VisionInput.VideoData.width)
  return _internal_width();
}
inline void VisionInput_VideoData::_internal_set_width(int32_t value) {
  
  _impl_.width_ = value;
}
inline void VisionInput_VideoData::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:service.VisionInput.VideoData.width)
}

// int32 height = 3;
inline void VisionInput_VideoData::clear_height() {
  _impl_.height_ = 0;
}
inline int32_t VisionInput_VideoData::_internal_height() const {
  return _impl_.height_;
}
inline int32_t VisionInput_VideoData::height() const {
  // @@protoc_insertion_point(field_get:service.VisionInput.VideoData.height)
  return _internal_height();
}
inline void VisionInput_VideoData::_internal_set_height(int32_t value) {
  
  _impl_.height_ = value;
}
inline void VisionInput_VideoData::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:service.VisionInput.VideoData.height)
}

// bytes data = 4;
inline void VisionInput_VideoData::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& VisionInput_VideoData::data() const {
  // @@protoc_insertion_point(field_get:service.VisionInput.VideoData.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VisionInput_VideoData::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.VisionInput.VideoData.data)
}
inline std::string* VisionInput_VideoData::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:service.VisionInput.VideoData.data)
  return _s;
}
inline const std::string& VisionInput_VideoData::_internal_data() const {
  return _impl_.data_.Get();
}
inline void VisionInput_VideoData::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* VisionInput_VideoData::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* VisionInput_VideoData::release_data() {
  // @@protoc_insertion_point(field_release:service.VisionInput.VideoData.data)
  return _impl_.data_.Release();
}
inline void VisionInput_VideoData::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.VisionInput.VideoData.data)
}

// -------------------------------------------------------------------

// VisionInput

// .service.VisionInput.ImageData image_data = 1;
inline bool VisionInput::_internal_has_image_data() const {
  return vision_data_case() == kImageData;
}
inline bool VisionInput::has_image_data() const {
  return _internal_has_image_data();
}
inline void VisionInput::set_has_image_data() {
  _impl_._oneof_case_[0] = kImageData;
}
inline void VisionInput::clear_image_data() {
  if (_internal_has_image_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.vision_data_.image_data_;
    }
    clear_has_vision_data();
  }
}
inline ::service::VisionInput_ImageData* VisionInput::release_image_data() {
  // @@protoc_insertion_point(field_release:service.VisionInput.image_data)
  if (_internal_has_image_data()) {
    clear_has_vision_data();
    ::service::VisionInput_ImageData* temp = _impl_.vision_data_.image_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.vision_data_.image_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::VisionInput_ImageData& VisionInput::_internal_image_data() const {
  return _internal_has_image_data()
      ? *_impl_.vision_data_.image_data_
      : reinterpret_cast< ::service::VisionInput_ImageData&>(::service::_VisionInput_ImageData_default_instance_);
}
inline const ::service::VisionInput_ImageData& VisionInput::image_data() const {
  // @@protoc_insertion_point(field_get:service.VisionInput.image_data)
  return _internal_image_data();
}
inline ::service::VisionInput_ImageData* VisionInput::unsafe_arena_release_image_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.VisionInput.image_data)
  if (_internal_has_image_data()) {
    clear_has_vision_data();
    ::service::VisionInput_ImageData* temp = _impl_.vision_data_.image_data_;
    _impl_.vision_data_.image_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VisionInput::unsafe_arena_set_allocated_image_data(::service::VisionInput_ImageData* image_data) {
  clear_vision_data();
  if (image_data) {
    set_has_image_data();
    _impl_.vision_data_.image_data_ = image_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.VisionInput.image_data)
}
inline ::service::VisionInput_ImageData* VisionInput::_internal_mutable_image_data() {
  if (!_internal_has_image_data()) {
    clear_vision_data();
    set_has_image_data();
    _impl_.vision_data_.image_data_ = CreateMaybeMessage< ::service::VisionInput_ImageData >(GetArenaForAllocation());
  }
  return _impl_.vision_data_.image_data_;
}
inline ::service::VisionInput_ImageData* VisionInput::mutable_image_data() {
  ::service::VisionInput_ImageData* _msg = _internal_mutable_image_data();
  // @@protoc_insertion_point(field_mutable:service.VisionInput.image_data)
  return _msg;
}

// .service.VisionInput.VideoData video_data = 2;
inline bool VisionInput::_internal_has_video_data() const {
  return vision_data_case() == kVideoData;
}
inline bool VisionInput::has_video_data() const {
  return _internal_has_video_data();
}
inline void VisionInput::set_has_video_data() {
  _impl_._oneof_case_[0] = kVideoData;
}
inline void VisionInput::clear_video_data() {
  if (_internal_has_video_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.vision_data_.video_data_;
    }
    clear_has_vision_data();
  }
}
inline ::service::VisionInput_VideoData* VisionInput::release_video_data() {
  // @@protoc_insertion_point(field_release:service.VisionInput.video_data)
  if (_internal_has_video_data()) {
    clear_has_vision_data();
    ::service::VisionInput_VideoData* temp = _impl_.vision_data_.video_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.vision_data_.video_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::VisionInput_VideoData& VisionInput::_internal_video_data() const {
  return _internal_has_video_data()
      ? *_impl_.vision_data_.video_data_
      : reinterpret_cast< ::service::VisionInput_VideoData&>(::service::_VisionInput_VideoData_default_instance_);
}
inline const ::service::VisionInput_VideoData& VisionInput::video_data() const {
  // @@protoc_insertion_point(field_get:service.VisionInput.video_data)
  return _internal_video_data();
}
inline ::service::VisionInput_VideoData* VisionInput::unsafe_arena_release_video_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.VisionInput.video_data)
  if (_internal_has_video_data()) {
    clear_has_vision_data();
    ::service::VisionInput_VideoData* temp = _impl_.vision_data_.video_data_;
    _impl_.vision_data_.video_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VisionInput::unsafe_arena_set_allocated_video_data(::service::VisionInput_VideoData* video_data) {
  clear_vision_data();
  if (video_data) {
    set_has_video_data();
    _impl_.vision_data_.video_data_ = video_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.VisionInput.video_data)
}
inline ::service::VisionInput_VideoData* VisionInput::_internal_mutable_video_data() {
  if (!_internal_has_video_data()) {
    clear_vision_data();
    set_has_video_data();
    _impl_.vision_data_.video_data_ = CreateMaybeMessage< ::service::VisionInput_VideoData >(GetArenaForAllocation());
  }
  return _impl_.vision_data_.video_data_;
}
inline ::service::VisionInput_VideoData* VisionInput::mutable_video_data() {
  ::service::VisionInput_VideoData* _msg = _internal_mutable_video_data();
  // @@protoc_insertion_point(field_mutable:service.VisionInput.video_data)
  return _msg;
}

inline bool VisionInput::has_vision_data() const {
  return vision_data_case() != VISION_DATA_NOT_SET;
}
inline void VisionInput::clear_has_vision_data() {
  _impl_._oneof_case_[0] = VISION_DATA_NOT_SET;
}
inline VisionInput::VisionDataCase VisionInput::vision_data_case() const {
  return VisionInput::VisionDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetResponseRequest_GetResponseConfig

// string character_id = 2;
inline void GetResponseRequest_GetResponseConfig::clear_character_id() {
  _impl_.character_id_.ClearToEmpty();
}
inline const std::string& GetResponseRequest_GetResponseConfig::character_id() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.character_id)
  return _internal_character_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseRequest_GetResponseConfig::set_character_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.character_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseConfig.character_id)
}
inline std::string* GetResponseRequest_GetResponseConfig::mutable_character_id() {
  std::string* _s = _internal_mutable_character_id();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.character_id)
  return _s;
}
inline const std::string& GetResponseRequest_GetResponseConfig::_internal_character_id() const {
  return _impl_.character_id_.Get();
}
inline void GetResponseRequest_GetResponseConfig::_internal_set_character_id(const std::string& value) {
  
  _impl_.character_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseConfig::_internal_mutable_character_id() {
  
  return _impl_.character_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseConfig::release_character_id() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.character_id)
  return _impl_.character_id_.Release();
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_character_id(std::string* character_id) {
  if (character_id != nullptr) {
    
  } else {
    
  }
  _impl_.character_id_.SetAllocated(character_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.character_id_.IsDefault()) {
    _impl_.character_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.character_id)
}

// string api_key = 3;
inline void GetResponseRequest_GetResponseConfig::clear_api_key() {
  _impl_.api_key_.ClearToEmpty();
}
inline const std::string& GetResponseRequest_GetResponseConfig::api_key() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.api_key)
  return _internal_api_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseRequest_GetResponseConfig::set_api_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.api_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseConfig.api_key)
}
inline std::string* GetResponseRequest_GetResponseConfig::mutable_api_key() {
  std::string* _s = _internal_mutable_api_key();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.api_key)
  return _s;
}
inline const std::string& GetResponseRequest_GetResponseConfig::_internal_api_key() const {
  return _impl_.api_key_.Get();
}
inline void GetResponseRequest_GetResponseConfig::_internal_set_api_key(const std::string& value) {
  
  _impl_.api_key_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseConfig::_internal_mutable_api_key() {
  
  return _impl_.api_key_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseConfig::release_api_key() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.api_key)
  return _impl_.api_key_.Release();
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_api_key(std::string* api_key) {
  if (api_key != nullptr) {
    
  } else {
    
  }
  _impl_.api_key_.SetAllocated(api_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.api_key_.IsDefault()) {
    _impl_.api_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.api_key)
}

// string session_id = 4;
inline void GetResponseRequest_GetResponseConfig::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& GetResponseRequest_GetResponseConfig::session_id() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseRequest_GetResponseConfig::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseConfig.session_id)
}
inline std::string* GetResponseRequest_GetResponseConfig::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.session_id)
  return _s;
}
inline const std::string& GetResponseRequest_GetResponseConfig::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void GetResponseRequest_GetResponseConfig::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseConfig::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseConfig::release_session_id() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.session_id)
  return _impl_.session_id_.Release();
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.session_id)
}

// .service.AudioConfig audio_config = 5;
inline bool GetResponseRequest_GetResponseConfig::_internal_has_audio_config() const {
  return this != internal_default_instance() && _impl_.audio_config_ != nullptr;
}
inline bool GetResponseRequest_GetResponseConfig::has_audio_config() const {
  return _internal_has_audio_config();
}
inline void GetResponseRequest_GetResponseConfig::clear_audio_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.audio_config_ != nullptr) {
    delete _impl_.audio_config_;
  }
  _impl_.audio_config_ = nullptr;
}
inline const ::service::AudioConfig& GetResponseRequest_GetResponseConfig::_internal_audio_config() const {
  const ::service::AudioConfig* p = _impl_.audio_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::AudioConfig&>(
      ::service::_AudioConfig_default_instance_);
}
inline const ::service::AudioConfig& GetResponseRequest_GetResponseConfig::audio_config() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.audio_config)
  return _internal_audio_config();
}
inline void GetResponseRequest_GetResponseConfig::unsafe_arena_set_allocated_audio_config(
    ::service::AudioConfig* audio_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audio_config_);
  }
  _impl_.audio_config_ = audio_config;
  if (audio_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequest.GetResponseConfig.audio_config)
}
inline ::service::AudioConfig* GetResponseRequest_GetResponseConfig::release_audio_config() {
  
  ::service::AudioConfig* temp = _impl_.audio_config_;
  _impl_.audio_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service::AudioConfig* GetResponseRequest_GetResponseConfig::unsafe_arena_release_audio_config() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.audio_config)
  
  ::service::AudioConfig* temp = _impl_.audio_config_;
  _impl_.audio_config_ = nullptr;
  return temp;
}
inline ::service::AudioConfig* GetResponseRequest_GetResponseConfig::_internal_mutable_audio_config() {
  
  if (_impl_.audio_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::service::AudioConfig>(GetArenaForAllocation());
    _impl_.audio_config_ = p;
  }
  return _impl_.audio_config_;
}
inline ::service::AudioConfig* GetResponseRequest_GetResponseConfig::mutable_audio_config() {
  ::service::AudioConfig* _msg = _internal_mutable_audio_config();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.audio_config)
  return _msg;
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_audio_config(::service::AudioConfig* audio_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.audio_config_;
  }
  if (audio_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(audio_config);
    if (message_arena != submessage_arena) {
      audio_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.audio_config_ = audio_config;
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.audio_config)
}

// .service.ActionConfig action_config = 6;
inline bool GetResponseRequest_GetResponseConfig::_internal_has_action_config() const {
  return this != internal_default_instance() && _impl_.action_config_ != nullptr;
}
inline bool GetResponseRequest_GetResponseConfig::has_action_config() const {
  return _internal_has_action_config();
}
inline void GetResponseRequest_GetResponseConfig::clear_action_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.action_config_ != nullptr) {
    delete _impl_.action_config_;
  }
  _impl_.action_config_ = nullptr;
}
inline const ::service::ActionConfig& GetResponseRequest_GetResponseConfig::_internal_action_config() const {
  const ::service::ActionConfig* p = _impl_.action_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::ActionConfig&>(
      ::service::_ActionConfig_default_instance_);
}
inline const ::service::ActionConfig& GetResponseRequest_GetResponseConfig::action_config() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.action_config)
  return _internal_action_config();
}
inline void GetResponseRequest_GetResponseConfig::unsafe_arena_set_allocated_action_config(
    ::service::ActionConfig* action_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.action_config_);
  }
  _impl_.action_config_ = action_config;
  if (action_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequest.GetResponseConfig.action_config)
}
inline ::service::ActionConfig* GetResponseRequest_GetResponseConfig::release_action_config() {
  
  ::service::ActionConfig* temp = _impl_.action_config_;
  _impl_.action_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service::ActionConfig* GetResponseRequest_GetResponseConfig::unsafe_arena_release_action_config() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.action_config)
  
  ::service::ActionConfig* temp = _impl_.action_config_;
  _impl_.action_config_ = nullptr;
  return temp;
}
inline ::service::ActionConfig* GetResponseRequest_GetResponseConfig::_internal_mutable_action_config() {
  
  if (_impl_.action_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::service::ActionConfig>(GetArenaForAllocation());
    _impl_.action_config_ = p;
  }
  return _impl_.action_config_;
}
inline ::service::ActionConfig* GetResponseRequest_GetResponseConfig::mutable_action_config() {
  ::service::ActionConfig* _msg = _internal_mutable_action_config();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.action_config)
  return _msg;
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_action_config(::service::ActionConfig* action_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.action_config_;
  }
  if (action_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(action_config);
    if (message_arena != submessage_arena) {
      action_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.action_config_ = action_config;
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.action_config)
}

// string speaker = 7;
inline void GetResponseRequest_GetResponseConfig::clear_speaker() {
  _impl_.speaker_.ClearToEmpty();
}
inline const std::string& GetResponseRequest_GetResponseConfig::speaker() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.speaker)
  return _internal_speaker();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseRequest_GetResponseConfig::set_speaker(ArgT0&& arg0, ArgT... args) {
 
 _impl_.speaker_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseConfig.speaker)
}
inline std::string* GetResponseRequest_GetResponseConfig::mutable_speaker() {
  std::string* _s = _internal_mutable_speaker();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.speaker)
  return _s;
}
inline const std::string& GetResponseRequest_GetResponseConfig::_internal_speaker() const {
  return _impl_.speaker_.Get();
}
inline void GetResponseRequest_GetResponseConfig::_internal_set_speaker(const std::string& value) {
  
  _impl_.speaker_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseConfig::_internal_mutable_speaker() {
  
  return _impl_.speaker_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseConfig::release_speaker() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.speaker)
  return _impl_.speaker_.Release();
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_speaker(std::string* speaker) {
  if (speaker != nullptr) {
    
  } else {
    
  }
  _impl_.speaker_.SetAllocated(speaker, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.speaker_.IsDefault()) {
    _impl_.speaker_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.speaker)
}

// string language_code = 8;
inline void GetResponseRequest_GetResponseConfig::clear_language_code() {
  _impl_.language_code_.ClearToEmpty();
}
inline const std::string& GetResponseRequest_GetResponseConfig::language_code() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.language_code)
  return _internal_language_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseRequest_GetResponseConfig::set_language_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.language_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseConfig.language_code)
}
inline std::string* GetResponseRequest_GetResponseConfig::mutable_language_code() {
  std::string* _s = _internal_mutable_language_code();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.language_code)
  return _s;
}
inline const std::string& GetResponseRequest_GetResponseConfig::_internal_language_code() const {
  return _impl_.language_code_.Get();
}
inline void GetResponseRequest_GetResponseConfig::_internal_set_language_code(const std::string& value) {
  
  _impl_.language_code_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseConfig::_internal_mutable_language_code() {
  
  return _impl_.language_code_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseConfig::release_language_code() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.language_code)
  return _impl_.language_code_.Release();
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_language_code(std::string* language_code) {
  if (language_code != nullptr) {
    
  } else {
    
  }
  _impl_.language_code_.SetAllocated(language_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_code_.IsDefault()) {
    _impl_.language_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.language_code)
}

// string speaker_id = 9;
inline void GetResponseRequest_GetResponseConfig::clear_speaker_id() {
  _impl_.speaker_id_.ClearToEmpty();
}
inline const std::string& GetResponseRequest_GetResponseConfig::speaker_id() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.speaker_id)
  return _internal_speaker_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseRequest_GetResponseConfig::set_speaker_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.speaker_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseConfig.speaker_id)
}
inline std::string* GetResponseRequest_GetResponseConfig::mutable_speaker_id() {
  std::string* _s = _internal_mutable_speaker_id();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.speaker_id)
  return _s;
}
inline const std::string& GetResponseRequest_GetResponseConfig::_internal_speaker_id() const {
  return _impl_.speaker_id_.Get();
}
inline void GetResponseRequest_GetResponseConfig::_internal_set_speaker_id(const std::string& value) {
  
  _impl_.speaker_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseConfig::_internal_mutable_speaker_id() {
  
  return _impl_.speaker_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseConfig::release_speaker_id() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.speaker_id)
  return _impl_.speaker_id_.Release();
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_speaker_id(std::string* speaker_id) {
  if (speaker_id != nullptr) {
    
  } else {
    
  }
  _impl_.speaker_id_.SetAllocated(speaker_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.speaker_id_.IsDefault()) {
    _impl_.speaker_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.speaker_id)
}

// string api_auth_token = 10;
inline void GetResponseRequest_GetResponseConfig::clear_api_auth_token() {
  _impl_.api_auth_token_.ClearToEmpty();
}
inline const std::string& GetResponseRequest_GetResponseConfig::api_auth_token() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.api_auth_token)
  return _internal_api_auth_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseRequest_GetResponseConfig::set_api_auth_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.api_auth_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseConfig.api_auth_token)
}
inline std::string* GetResponseRequest_GetResponseConfig::mutable_api_auth_token() {
  std::string* _s = _internal_mutable_api_auth_token();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.api_auth_token)
  return _s;
}
inline const std::string& GetResponseRequest_GetResponseConfig::_internal_api_auth_token() const {
  return _impl_.api_auth_token_.Get();
}
inline void GetResponseRequest_GetResponseConfig::_internal_set_api_auth_token(const std::string& value) {
  
  _impl_.api_auth_token_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseConfig::_internal_mutable_api_auth_token() {
  
  return _impl_.api_auth_token_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseConfig::release_api_auth_token() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.api_auth_token)
  return _impl_.api_auth_token_.Release();
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_api_auth_token(std::string* api_auth_token) {
  if (api_auth_token != nullptr) {
    
  } else {
    
  }
  _impl_.api_auth_token_.SetAllocated(api_auth_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.api_auth_token_.IsDefault()) {
    _impl_.api_auth_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.api_auth_token)
}

// map<string, string> narrative_template_keys = 11;
inline int GetResponseRequest_GetResponseConfig::_internal_narrative_template_keys_size() const {
  return _impl_.narrative_template_keys_.size();
}
inline int GetResponseRequest_GetResponseConfig::narrative_template_keys_size() const {
  return _internal_narrative_template_keys_size();
}
inline void GetResponseRequest_GetResponseConfig::clear_narrative_template_keys() {
  _impl_.narrative_template_keys_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetResponseRequest_GetResponseConfig::_internal_narrative_template_keys() const {
  return _impl_.narrative_template_keys_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetResponseRequest_GetResponseConfig::narrative_template_keys() const {
  // @@protoc_insertion_point(field_map:service.GetResponseRequest.GetResponseConfig.narrative_template_keys)
  return _internal_narrative_template_keys();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetResponseRequest_GetResponseConfig::_internal_mutable_narrative_template_keys() {
  return _impl_.narrative_template_keys_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetResponseRequest_GetResponseConfig::mutable_narrative_template_keys() {
  // @@protoc_insertion_point(field_mutable_map:service.GetResponseRequest.GetResponseConfig.narrative_template_keys)
  return _internal_mutable_narrative_template_keys();
}

// .service.DynamicInfoConfig dynamic_info_config = 12;
inline bool GetResponseRequest_GetResponseConfig::_internal_has_dynamic_info_config() const {
  return this != internal_default_instance() && _impl_.dynamic_info_config_ != nullptr;
}
inline bool GetResponseRequest_GetResponseConfig::has_dynamic_info_config() const {
  return _internal_has_dynamic_info_config();
}
inline void GetResponseRequest_GetResponseConfig::clear_dynamic_info_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.dynamic_info_config_ != nullptr) {
    delete _impl_.dynamic_info_config_;
  }
  _impl_.dynamic_info_config_ = nullptr;
}
inline const ::service::DynamicInfoConfig& GetResponseRequest_GetResponseConfig::_internal_dynamic_info_config() const {
  const ::service::DynamicInfoConfig* p = _impl_.dynamic_info_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::DynamicInfoConfig&>(
      ::service::_DynamicInfoConfig_default_instance_);
}
inline const ::service::DynamicInfoConfig& GetResponseRequest_GetResponseConfig::dynamic_info_config() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.dynamic_info_config)
  return _internal_dynamic_info_config();
}
inline void GetResponseRequest_GetResponseConfig::unsafe_arena_set_allocated_dynamic_info_config(
    ::service::DynamicInfoConfig* dynamic_info_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dynamic_info_config_);
  }
  _impl_.dynamic_info_config_ = dynamic_info_config;
  if (dynamic_info_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequest.GetResponseConfig.dynamic_info_config)
}
inline ::service::DynamicInfoConfig* GetResponseRequest_GetResponseConfig::release_dynamic_info_config() {
  
  ::service::DynamicInfoConfig* temp = _impl_.dynamic_info_config_;
  _impl_.dynamic_info_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service::DynamicInfoConfig* GetResponseRequest_GetResponseConfig::unsafe_arena_release_dynamic_info_config() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.dynamic_info_config)
  
  ::service::DynamicInfoConfig* temp = _impl_.dynamic_info_config_;
  _impl_.dynamic_info_config_ = nullptr;
  return temp;
}
inline ::service::DynamicInfoConfig* GetResponseRequest_GetResponseConfig::_internal_mutable_dynamic_info_config() {
  
  if (_impl_.dynamic_info_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::service::DynamicInfoConfig>(GetArenaForAllocation());
    _impl_.dynamic_info_config_ = p;
  }
  return _impl_.dynamic_info_config_;
}
inline ::service::DynamicInfoConfig* GetResponseRequest_GetResponseConfig::mutable_dynamic_info_config() {
  ::service::DynamicInfoConfig* _msg = _internal_mutable_dynamic_info_config();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.dynamic_info_config)
  return _msg;
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_dynamic_info_config(::service::DynamicInfoConfig* dynamic_info_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dynamic_info_config_;
  }
  if (dynamic_info_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dynamic_info_config);
    if (message_arena != submessage_arena) {
      dynamic_info_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dynamic_info_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.dynamic_info_config_ = dynamic_info_config;
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.dynamic_info_config)
}

// .service.VisionInput vision_input = 13;
inline bool GetResponseRequest_GetResponseConfig::_internal_has_vision_input() const {
  return this != internal_default_instance() && _impl_.vision_input_ != nullptr;
}
inline bool GetResponseRequest_GetResponseConfig::has_vision_input() const {
  return _internal_has_vision_input();
}
inline void GetResponseRequest_GetResponseConfig::clear_vision_input() {
  if (GetArenaForAllocation() == nullptr && _impl_.vision_input_ != nullptr) {
    delete _impl_.vision_input_;
  }
  _impl_.vision_input_ = nullptr;
}
inline const ::service::VisionInput& GetResponseRequest_GetResponseConfig::_internal_vision_input() const {
  const ::service::VisionInput* p = _impl_.vision_input_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::VisionInput&>(
      ::service::_VisionInput_default_instance_);
}
inline const ::service::VisionInput& GetResponseRequest_GetResponseConfig::vision_input() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.vision_input)
  return _internal_vision_input();
}
inline void GetResponseRequest_GetResponseConfig::unsafe_arena_set_allocated_vision_input(
    ::service::VisionInput* vision_input) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vision_input_);
  }
  _impl_.vision_input_ = vision_input;
  if (vision_input) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequest.GetResponseConfig.vision_input)
}
inline ::service::VisionInput* GetResponseRequest_GetResponseConfig::release_vision_input() {
  
  ::service::VisionInput* temp = _impl_.vision_input_;
  _impl_.vision_input_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service::VisionInput* GetResponseRequest_GetResponseConfig::unsafe_arena_release_vision_input() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.vision_input)
  
  ::service::VisionInput* temp = _impl_.vision_input_;
  _impl_.vision_input_ = nullptr;
  return temp;
}
inline ::service::VisionInput* GetResponseRequest_GetResponseConfig::_internal_mutable_vision_input() {
  
  if (_impl_.vision_input_ == nullptr) {
    auto* p = CreateMaybeMessage<::service::VisionInput>(GetArenaForAllocation());
    _impl_.vision_input_ = p;
  }
  return _impl_.vision_input_;
}
inline ::service::VisionInput* GetResponseRequest_GetResponseConfig::mutable_vision_input() {
  ::service::VisionInput* _msg = _internal_mutable_vision_input();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.vision_input)
  return _msg;
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_vision_input(::service::VisionInput* vision_input) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vision_input_;
  }
  if (vision_input) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vision_input);
    if (message_arena != submessage_arena) {
      vision_input = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vision_input, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.vision_input_ = vision_input;
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.vision_input)
}

// -------------------------------------------------------------------

// GetResponseRequest_GetResponseData

// bytes audio_data = 1;
inline bool GetResponseRequest_GetResponseData::_internal_has_audio_data() const {
  return input_type_case() == kAudioData;
}
inline bool GetResponseRequest_GetResponseData::has_audio_data() const {
  return _internal_has_audio_data();
}
inline void GetResponseRequest_GetResponseData::set_has_audio_data() {
  _impl_._oneof_case_[0] = kAudioData;
}
inline void GetResponseRequest_GetResponseData::clear_audio_data() {
  if (_internal_has_audio_data()) {
    _impl_.input_type_.audio_data_.Destroy();
    clear_has_input_type();
  }
}
inline const std::string& GetResponseRequest_GetResponseData::audio_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseData.audio_data)
  return _internal_audio_data();
}
template <typename ArgT0, typename... ArgT>
inline void GetResponseRequest_GetResponseData::set_audio_data(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_audio_data()) {
    clear_input_type();
    set_has_audio_data();
    _impl_.input_type_.audio_data_.InitDefault();
  }
  _impl_.input_type_.audio_data_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseData.audio_data)
}
inline std::string* GetResponseRequest_GetResponseData::mutable_audio_data() {
  std::string* _s = _internal_mutable_audio_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseData.audio_data)
  return _s;
}
inline const std::string& GetResponseRequest_GetResponseData::_internal_audio_data() const {
  if (_internal_has_audio_data()) {
    return _impl_.input_type_.audio_data_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void GetResponseRequest_GetResponseData::_internal_set_audio_data(const std::string& value) {
  if (!_internal_has_audio_data()) {
    clear_input_type();
    set_has_audio_data();
    _impl_.input_type_.audio_data_.InitDefault();
  }
  _impl_.input_type_.audio_data_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseData::_internal_mutable_audio_data() {
  if (!_internal_has_audio_data()) {
    clear_input_type();
    set_has_audio_data();
    _impl_.input_type_.audio_data_.InitDefault();
  }
  return _impl_.input_type_.audio_data_.Mutable(      GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseData::release_audio_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseData.audio_data)
  if (_internal_has_audio_data()) {
    clear_has_input_type();
    return _impl_.input_type_.audio_data_.Release();
  } else {
    return nullptr;
  }
}
inline void GetResponseRequest_GetResponseData::set_allocated_audio_data(std::string* audio_data) {
  if (has_input_type()) {
    clear_input_type();
  }
  if (audio_data != nullptr) {
    set_has_audio_data();
    _impl_.input_type_.audio_data_.InitAllocated(audio_data, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseData.audio_data)
}

// string text_data = 2;
inline bool GetResponseRequest_GetResponseData::_internal_has_text_data() const {
  return input_type_case() == kTextData;
}
inline bool GetResponseRequest_GetResponseData::has_text_data() const {
  return _internal_has_text_data();
}
inline void GetResponseRequest_GetResponseData::set_has_text_data() {
  _impl_._oneof_case_[0] = kTextData;
}
inline void GetResponseRequest_GetResponseData::clear_text_data() {
  if (_internal_has_text_data()) {
    _impl_.input_type_.text_data_.Destroy();
    clear_has_input_type();
  }
}
inline const std::string& GetResponseRequest_GetResponseData::text_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseData.text_data)
  return _internal_text_data();
}
template <typename ArgT0, typename... ArgT>
inline void GetResponseRequest_GetResponseData::set_text_data(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_text_data()) {
    clear_input_type();
    set_has_text_data();
    _impl_.input_type_.text_data_.InitDefault();
  }
  _impl_.input_type_.text_data_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseData.text_data)
}
inline std::string* GetResponseRequest_GetResponseData::mutable_text_data() {
  std::string* _s = _internal_mutable_text_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseData.text_data)
  return _s;
}
inline const std::string& GetResponseRequest_GetResponseData::_internal_text_data() const {
  if (_internal_has_text_data()) {
    return _impl_.input_type_.text_data_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void GetResponseRequest_GetResponseData::_internal_set_text_data(const std::string& value) {
  if (!_internal_has_text_data()) {
    clear_input_type();
    set_has_text_data();
    _impl_.input_type_.text_data_.InitDefault();
  }
  _impl_.input_type_.text_data_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseData::_internal_mutable_text_data() {
  if (!_internal_has_text_data()) {
    clear_input_type();
    set_has_text_data();
    _impl_.input_type_.text_data_.InitDefault();
  }
  return _impl_.input_type_.text_data_.Mutable(      GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseData::release_text_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseData.text_data)
  if (_internal_has_text_data()) {
    clear_has_input_type();
    return _impl_.input_type_.text_data_.Release();
  } else {
    return nullptr;
  }
}
inline void GetResponseRequest_GetResponseData::set_allocated_text_data(std::string* text_data) {
  if (has_input_type()) {
    clear_input_type();
  }
  if (text_data != nullptr) {
    set_has_text_data();
    _impl_.input_type_.text_data_.InitAllocated(text_data, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseData.text_data)
}

// .service.TriggerConfig trigger_data = 3;
inline bool GetResponseRequest_GetResponseData::_internal_has_trigger_data() const {
  return input_type_case() == kTriggerData;
}
inline bool GetResponseRequest_GetResponseData::has_trigger_data() const {
  return _internal_has_trigger_data();
}
inline void GetResponseRequest_GetResponseData::set_has_trigger_data() {
  _impl_._oneof_case_[0] = kTriggerData;
}
inline void GetResponseRequest_GetResponseData::clear_trigger_data() {
  if (_internal_has_trigger_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.input_type_.trigger_data_;
    }
    clear_has_input_type();
  }
}
inline ::service::TriggerConfig* GetResponseRequest_GetResponseData::release_trigger_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseData.trigger_data)
  if (_internal_has_trigger_data()) {
    clear_has_input_type();
    ::service::TriggerConfig* temp = _impl_.input_type_.trigger_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.input_type_.trigger_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::TriggerConfig& GetResponseRequest_GetResponseData::_internal_trigger_data() const {
  return _internal_has_trigger_data()
      ? *_impl_.input_type_.trigger_data_
      : reinterpret_cast< ::service::TriggerConfig&>(::service::_TriggerConfig_default_instance_);
}
inline const ::service::TriggerConfig& GetResponseRequest_GetResponseData::trigger_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseData.trigger_data)
  return _internal_trigger_data();
}
inline ::service::TriggerConfig* GetResponseRequest_GetResponseData::unsafe_arena_release_trigger_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseRequest.GetResponseData.trigger_data)
  if (_internal_has_trigger_data()) {
    clear_has_input_type();
    ::service::TriggerConfig* temp = _impl_.input_type_.trigger_data_;
    _impl_.input_type_.trigger_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseRequest_GetResponseData::unsafe_arena_set_allocated_trigger_data(::service::TriggerConfig* trigger_data) {
  clear_input_type();
  if (trigger_data) {
    set_has_trigger_data();
    _impl_.input_type_.trigger_data_ = trigger_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequest.GetResponseData.trigger_data)
}
inline ::service::TriggerConfig* GetResponseRequest_GetResponseData::_internal_mutable_trigger_data() {
  if (!_internal_has_trigger_data()) {
    clear_input_type();
    set_has_trigger_data();
    _impl_.input_type_.trigger_data_ = CreateMaybeMessage< ::service::TriggerConfig >(GetArenaForAllocation());
  }
  return _impl_.input_type_.trigger_data_;
}
inline ::service::TriggerConfig* GetResponseRequest_GetResponseData::mutable_trigger_data() {
  ::service::TriggerConfig* _msg = _internal_mutable_trigger_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseData.trigger_data)
  return _msg;
}

inline bool GetResponseRequest_GetResponseData::has_input_type() const {
  return input_type_case() != INPUT_TYPE_NOT_SET;
}
inline void GetResponseRequest_GetResponseData::clear_has_input_type() {
  _impl_._oneof_case_[0] = INPUT_TYPE_NOT_SET;
}
inline GetResponseRequest_GetResponseData::InputTypeCase GetResponseRequest_GetResponseData::input_type_case() const {
  return GetResponseRequest_GetResponseData::InputTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetResponseRequest

// .service.GetResponseRequest.GetResponseConfig get_response_config = 1;
inline bool GetResponseRequest::_internal_has_get_response_config() const {
  return request_type_case() == kGetResponseConfig;
}
inline bool GetResponseRequest::has_get_response_config() const {
  return _internal_has_get_response_config();
}
inline void GetResponseRequest::set_has_get_response_config() {
  _impl_._oneof_case_[0] = kGetResponseConfig;
}
inline void GetResponseRequest::clear_get_response_config() {
  if (_internal_has_get_response_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_type_.get_response_config_;
    }
    clear_has_request_type();
  }
}
inline ::service::GetResponseRequest_GetResponseConfig* GetResponseRequest::release_get_response_config() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.get_response_config)
  if (_internal_has_get_response_config()) {
    clear_has_request_type();
    ::service::GetResponseRequest_GetResponseConfig* temp = _impl_.request_type_.get_response_config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.get_response_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::GetResponseRequest_GetResponseConfig& GetResponseRequest::_internal_get_response_config() const {
  return _internal_has_get_response_config()
      ? *_impl_.request_type_.get_response_config_
      : reinterpret_cast< ::service::GetResponseRequest_GetResponseConfig&>(::service::_GetResponseRequest_GetResponseConfig_default_instance_);
}
inline const ::service::GetResponseRequest_GetResponseConfig& GetResponseRequest::get_response_config() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.get_response_config)
  return _internal_get_response_config();
}
inline ::service::GetResponseRequest_GetResponseConfig* GetResponseRequest::unsafe_arena_release_get_response_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseRequest.get_response_config)
  if (_internal_has_get_response_config()) {
    clear_has_request_type();
    ::service::GetResponseRequest_GetResponseConfig* temp = _impl_.request_type_.get_response_config_;
    _impl_.request_type_.get_response_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseRequest::unsafe_arena_set_allocated_get_response_config(::service::GetResponseRequest_GetResponseConfig* get_response_config) {
  clear_request_type();
  if (get_response_config) {
    set_has_get_response_config();
    _impl_.request_type_.get_response_config_ = get_response_config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequest.get_response_config)
}
inline ::service::GetResponseRequest_GetResponseConfig* GetResponseRequest::_internal_mutable_get_response_config() {
  if (!_internal_has_get_response_config()) {
    clear_request_type();
    set_has_get_response_config();
    _impl_.request_type_.get_response_config_ = CreateMaybeMessage< ::service::GetResponseRequest_GetResponseConfig >(GetArenaForAllocation());
  }
  return _impl_.request_type_.get_response_config_;
}
inline ::service::GetResponseRequest_GetResponseConfig* GetResponseRequest::mutable_get_response_config() {
  ::service::GetResponseRequest_GetResponseConfig* _msg = _internal_mutable_get_response_config();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.get_response_config)
  return _msg;
}

// .service.GetResponseRequest.GetResponseData get_response_data = 2;
inline bool GetResponseRequest::_internal_has_get_response_data() const {
  return request_type_case() == kGetResponseData;
}
inline bool GetResponseRequest::has_get_response_data() const {
  return _internal_has_get_response_data();
}
inline void GetResponseRequest::set_has_get_response_data() {
  _impl_._oneof_case_[0] = kGetResponseData;
}
inline void GetResponseRequest::clear_get_response_data() {
  if (_internal_has_get_response_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_type_.get_response_data_;
    }
    clear_has_request_type();
  }
}
inline ::service::GetResponseRequest_GetResponseData* GetResponseRequest::release_get_response_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.get_response_data)
  if (_internal_has_get_response_data()) {
    clear_has_request_type();
    ::service::GetResponseRequest_GetResponseData* temp = _impl_.request_type_.get_response_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.get_response_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::GetResponseRequest_GetResponseData& GetResponseRequest::_internal_get_response_data() const {
  return _internal_has_get_response_data()
      ? *_impl_.request_type_.get_response_data_
      : reinterpret_cast< ::service::GetResponseRequest_GetResponseData&>(::service::_GetResponseRequest_GetResponseData_default_instance_);
}
inline const ::service::GetResponseRequest_GetResponseData& GetResponseRequest::get_response_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.get_response_data)
  return _internal_get_response_data();
}
inline ::service::GetResponseRequest_GetResponseData* GetResponseRequest::unsafe_arena_release_get_response_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseRequest.get_response_data)
  if (_internal_has_get_response_data()) {
    clear_has_request_type();
    ::service::GetResponseRequest_GetResponseData* temp = _impl_.request_type_.get_response_data_;
    _impl_.request_type_.get_response_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseRequest::unsafe_arena_set_allocated_get_response_data(::service::GetResponseRequest_GetResponseData* get_response_data) {
  clear_request_type();
  if (get_response_data) {
    set_has_get_response_data();
    _impl_.request_type_.get_response_data_ = get_response_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequest.get_response_data)
}
inline ::service::GetResponseRequest_GetResponseData* GetResponseRequest::_internal_mutable_get_response_data() {
  if (!_internal_has_get_response_data()) {
    clear_request_type();
    set_has_get_response_data();
    _impl_.request_type_.get_response_data_ = CreateMaybeMessage< ::service::GetResponseRequest_GetResponseData >(GetArenaForAllocation());
  }
  return _impl_.request_type_.get_response_data_;
}
inline ::service::GetResponseRequest_GetResponseData* GetResponseRequest::mutable_get_response_data() {
  ::service::GetResponseRequest_GetResponseData* _msg = _internal_mutable_get_response_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.get_response_data)
  return _msg;
}

inline bool GetResponseRequest::has_request_type() const {
  return request_type_case() != REQUEST_TYPE_NOT_SET;
}
inline void GetResponseRequest::clear_has_request_type() {
  _impl_._oneof_case_[0] = REQUEST_TYPE_NOT_SET;
}
inline GetResponseRequest::RequestTypeCase GetResponseRequest::request_type_case() const {
  return GetResponseRequest::RequestTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetResponseRequestSingle

// .service.GetResponseRequest response_config = 1;
inline bool GetResponseRequestSingle::_internal_has_response_config() const {
  return this != internal_default_instance() && _impl_.response_config_ != nullptr;
}
inline bool GetResponseRequestSingle::has_response_config() const {
  return _internal_has_response_config();
}
inline void GetResponseRequestSingle::clear_response_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_config_ != nullptr) {
    delete _impl_.response_config_;
  }
  _impl_.response_config_ = nullptr;
}
inline const ::service::GetResponseRequest& GetResponseRequestSingle::_internal_response_config() const {
  const ::service::GetResponseRequest* p = _impl_.response_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::GetResponseRequest&>(
      ::service::_GetResponseRequest_default_instance_);
}
inline const ::service::GetResponseRequest& GetResponseRequestSingle::response_config() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequestSingle.response_config)
  return _internal_response_config();
}
inline void GetResponseRequestSingle::unsafe_arena_set_allocated_response_config(
    ::service::GetResponseRequest* response_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_config_);
  }
  _impl_.response_config_ = response_config;
  if (response_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequestSingle.response_config)
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::release_response_config() {
  
  ::service::GetResponseRequest* temp = _impl_.response_config_;
  _impl_.response_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::unsafe_arena_release_response_config() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequestSingle.response_config)
  
  ::service::GetResponseRequest* temp = _impl_.response_config_;
  _impl_.response_config_ = nullptr;
  return temp;
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::_internal_mutable_response_config() {
  
  if (_impl_.response_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::service::GetResponseRequest>(GetArenaForAllocation());
    _impl_.response_config_ = p;
  }
  return _impl_.response_config_;
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::mutable_response_config() {
  ::service::GetResponseRequest* _msg = _internal_mutable_response_config();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequestSingle.response_config)
  return _msg;
}
inline void GetResponseRequestSingle::set_allocated_response_config(::service::GetResponseRequest* response_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_config_;
  }
  if (response_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_config);
    if (message_arena != submessage_arena) {
      response_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_config_ = response_config;
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequestSingle.response_config)
}

// .service.GetResponseRequest response_data = 2;
inline bool GetResponseRequestSingle::_internal_has_response_data() const {
  return this != internal_default_instance() && _impl_.response_data_ != nullptr;
}
inline bool GetResponseRequestSingle::has_response_data() const {
  return _internal_has_response_data();
}
inline void GetResponseRequestSingle::clear_response_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_data_ != nullptr) {
    delete _impl_.response_data_;
  }
  _impl_.response_data_ = nullptr;
}
inline const ::service::GetResponseRequest& GetResponseRequestSingle::_internal_response_data() const {
  const ::service::GetResponseRequest* p = _impl_.response_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::GetResponseRequest&>(
      ::service::_GetResponseRequest_default_instance_);
}
inline const ::service::GetResponseRequest& GetResponseRequestSingle::response_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequestSingle.response_data)
  return _internal_response_data();
}
inline void GetResponseRequestSingle::unsafe_arena_set_allocated_response_data(
    ::service::GetResponseRequest* response_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_data_);
  }
  _impl_.response_data_ = response_data;
  if (response_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequestSingle.response_data)
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::release_response_data() {
  
  ::service::GetResponseRequest* temp = _impl_.response_data_;
  _impl_.response_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::unsafe_arena_release_response_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequestSingle.response_data)
  
  ::service::GetResponseRequest* temp = _impl_.response_data_;
  _impl_.response_data_ = nullptr;
  return temp;
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::_internal_mutable_response_data() {
  
  if (_impl_.response_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::service::GetResponseRequest>(GetArenaForAllocation());
    _impl_.response_data_ = p;
  }
  return _impl_.response_data_;
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::mutable_response_data() {
  ::service::GetResponseRequest* _msg = _internal_mutable_response_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequestSingle.response_data)
  return _msg;
}
inline void GetResponseRequestSingle::set_allocated_response_data(::service::GetResponseRequest* response_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_data_;
  }
  if (response_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_data);
    if (message_arena != submessage_arena) {
      response_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_data_ = response_data;
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequestSingle.response_data)
}

// -------------------------------------------------------------------

// GetResponseResponse_AudioResponse

// bytes audio_data = 1;
inline void GetResponseResponse_AudioResponse::clear_audio_data() {
  _impl_.audio_data_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_AudioResponse::audio_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.audio_data)
  return _internal_audio_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseResponse_AudioResponse::set_audio_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.audio_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.AudioResponse.audio_data)
}
inline std::string* GetResponseResponse_AudioResponse::mutable_audio_data() {
  std::string* _s = _internal_mutable_audio_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.AudioResponse.audio_data)
  return _s;
}
inline const std::string& GetResponseResponse_AudioResponse::_internal_audio_data() const {
  return _impl_.audio_data_.Get();
}
inline void GetResponseResponse_AudioResponse::_internal_set_audio_data(const std::string& value) {
  
  _impl_.audio_data_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseResponse_AudioResponse::_internal_mutable_audio_data() {
  
  return _impl_.audio_data_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseResponse_AudioResponse::release_audio_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.AudioResponse.audio_data)
  return _impl_.audio_data_.Release();
}
inline void GetResponseResponse_AudioResponse::set_allocated_audio_data(std::string* audio_data) {
  if (audio_data != nullptr) {
    
  } else {
    
  }
  _impl_.audio_data_.SetAllocated(audio_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.audio_data_.IsDefault()) {
    _impl_.audio_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.AudioResponse.audio_data)
}

// .service.AudioConfig audio_config = 2;
inline bool GetResponseResponse_AudioResponse::_internal_has_audio_config() const {
  return this != internal_default_instance() && _impl_.audio_config_ != nullptr;
}
inline bool GetResponseResponse_AudioResponse::has_audio_config() const {
  return _internal_has_audio_config();
}
inline void GetResponseResponse_AudioResponse::clear_audio_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.audio_config_ != nullptr) {
    delete _impl_.audio_config_;
  }
  _impl_.audio_config_ = nullptr;
}
inline const ::service::AudioConfig& GetResponseResponse_AudioResponse::_internal_audio_config() const {
  const ::service::AudioConfig* p = _impl_.audio_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::AudioConfig&>(
      ::service::_AudioConfig_default_instance_);
}
inline const ::service::AudioConfig& GetResponseResponse_AudioResponse::audio_config() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.audio_config)
  return _internal_audio_config();
}
inline void GetResponseResponse_AudioResponse::unsafe_arena_set_allocated_audio_config(
    ::service::AudioConfig* audio_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audio_config_);
  }
  _impl_.audio_config_ = audio_config;
  if (audio_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.AudioResponse.audio_config)
}
inline ::service::AudioConfig* GetResponseResponse_AudioResponse::release_audio_config() {
  
  ::service::AudioConfig* temp = _impl_.audio_config_;
  _impl_.audio_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service::AudioConfig* GetResponseResponse_AudioResponse::unsafe_arena_release_audio_config() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.AudioResponse.audio_config)
  
  ::service::AudioConfig* temp = _impl_.audio_config_;
  _impl_.audio_config_ = nullptr;
  return temp;
}
inline ::service::AudioConfig* GetResponseResponse_AudioResponse::_internal_mutable_audio_config() {
  
  if (_impl_.audio_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::service::AudioConfig>(GetArenaForAllocation());
    _impl_.audio_config_ = p;
  }
  return _impl_.audio_config_;
}
inline ::service::AudioConfig* GetResponseResponse_AudioResponse::mutable_audio_config() {
  ::service::AudioConfig* _msg = _internal_mutable_audio_config();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.AudioResponse.audio_config)
  return _msg;
}
inline void GetResponseResponse_AudioResponse::set_allocated_audio_config(::service::AudioConfig* audio_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.audio_config_;
  }
  if (audio_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(audio_config);
    if (message_arena != submessage_arena) {
      audio_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.audio_config_ = audio_config;
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.AudioResponse.audio_config)
}

// string text_data = 3;
inline void GetResponseResponse_AudioResponse::clear_text_data() {
  _impl_.text_data_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_AudioResponse::text_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.text_data)
  return _internal_text_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseResponse_AudioResponse::set_text_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.AudioResponse.text_data)
}
inline std::string* GetResponseResponse_AudioResponse::mutable_text_data() {
  std::string* _s = _internal_mutable_text_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.AudioResponse.text_data)
  return _s;
}
inline const std::string& GetResponseResponse_AudioResponse::_internal_text_data() const {
  return _impl_.text_data_.Get();
}
inline void GetResponseResponse_AudioResponse::_internal_set_text_data(const std::string& value) {
  
  _impl_.text_data_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseResponse_AudioResponse::_internal_mutable_text_data() {
  
  return _impl_.text_data_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseResponse_AudioResponse::release_text_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.AudioResponse.text_data)
  return _impl_.text_data_.Release();
}
inline void GetResponseResponse_AudioResponse::set_allocated_text_data(std::string* text_data) {
  if (text_data != nullptr) {
    
  } else {
    
  }
  _impl_.text_data_.SetAllocated(text_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_data_.IsDefault()) {
    _impl_.text_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.AudioResponse.text_data)
}

// bool end_of_response = 4;
inline void GetResponseResponse_AudioResponse::clear_end_of_response() {
  _impl_.end_of_response_ = false;
}
inline bool GetResponseResponse_AudioResponse::_internal_end_of_response() const {
  return _impl_.end_of_response_;
}
inline bool GetResponseResponse_AudioResponse::end_of_response() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.end_of_response)
  return _internal_end_of_response();
}
inline void GetResponseResponse_AudioResponse::_internal_set_end_of_response(bool value) {
  
  _impl_.end_of_response_ = value;
}
inline void GetResponseResponse_AudioResponse::set_end_of_response(bool value) {
  _internal_set_end_of_response(value);
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.AudioResponse.end_of_response)
}

// string face_data = 5;
inline void GetResponseResponse_AudioResponse::clear_face_data() {
  _impl_.face_data_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_AudioResponse::face_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.face_data)
  return _internal_face_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseResponse_AudioResponse::set_face_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.face_data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.AudioResponse.face_data)
}
inline std::string* GetResponseResponse_AudioResponse::mutable_face_data() {
  std::string* _s = _internal_mutable_face_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.AudioResponse.face_data)
  return _s;
}
inline const std::string& GetResponseResponse_AudioResponse::_internal_face_data() const {
  return _impl_.face_data_.Get();
}
inline void GetResponseResponse_AudioResponse::_internal_set_face_data(const std::string& value) {
  
  _impl_.face_data_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseResponse_AudioResponse::_internal_mutable_face_data() {
  
  return _impl_.face_data_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseResponse_AudioResponse::release_face_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.AudioResponse.face_data)
  return _impl_.face_data_.Release();
}
inline void GetResponseResponse_AudioResponse::set_allocated_face_data(std::string* face_data) {
  if (face_data != nullptr) {
    
  } else {
    
  }
  _impl_.face_data_.SetAllocated(face_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.face_data_.IsDefault()) {
    _impl_.face_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.AudioResponse.face_data)
}

// .service.VisemesData visemes_data = 6;
inline bool GetResponseResponse_AudioResponse::_internal_has_visemes_data() const {
  return face_data_type_case() == kVisemesData;
}
inline bool GetResponseResponse_AudioResponse::has_visemes_data() const {
  return _internal_has_visemes_data();
}
inline void GetResponseResponse_AudioResponse::set_has_visemes_data() {
  _impl_._oneof_case_[0] = kVisemesData;
}
inline void GetResponseResponse_AudioResponse::clear_visemes_data() {
  if (_internal_has_visemes_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.face_data_type_.visemes_data_;
    }
    clear_has_face_data_type();
  }
}
inline ::service::VisemesData* GetResponseResponse_AudioResponse::release_visemes_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.AudioResponse.visemes_data)
  if (_internal_has_visemes_data()) {
    clear_has_face_data_type();
    ::service::VisemesData* temp = _impl_.face_data_type_.visemes_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.face_data_type_.visemes_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::VisemesData& GetResponseResponse_AudioResponse::_internal_visemes_data() const {
  return _internal_has_visemes_data()
      ? *_impl_.face_data_type_.visemes_data_
      : reinterpret_cast< ::service::VisemesData&>(::service::_VisemesData_default_instance_);
}
inline const ::service::VisemesData& GetResponseResponse_AudioResponse::visemes_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.visemes_data)
  return _internal_visemes_data();
}
inline ::service::VisemesData* GetResponseResponse_AudioResponse::unsafe_arena_release_visemes_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseResponse.AudioResponse.visemes_data)
  if (_internal_has_visemes_data()) {
    clear_has_face_data_type();
    ::service::VisemesData* temp = _impl_.face_data_type_.visemes_data_;
    _impl_.face_data_type_.visemes_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse_AudioResponse::unsafe_arena_set_allocated_visemes_data(::service::VisemesData* visemes_data) {
  clear_face_data_type();
  if (visemes_data) {
    set_has_visemes_data();
    _impl_.face_data_type_.visemes_data_ = visemes_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.AudioResponse.visemes_data)
}
inline ::service::VisemesData* GetResponseResponse_AudioResponse::_internal_mutable_visemes_data() {
  if (!_internal_has_visemes_data()) {
    clear_face_data_type();
    set_has_visemes_data();
    _impl_.face_data_type_.visemes_data_ = CreateMaybeMessage< ::service::VisemesData >(GetArenaForAllocation());
  }
  return _impl_.face_data_type_.visemes_data_;
}
inline ::service::VisemesData* GetResponseResponse_AudioResponse::mutable_visemes_data() {
  ::service::VisemesData* _msg = _internal_mutable_visemes_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.AudioResponse.visemes_data)
  return _msg;
}

// .service.BlendShapesData blendshapes_data = 7;
inline bool GetResponseResponse_AudioResponse::_internal_has_blendshapes_data() const {
  return face_data_type_case() == kBlendshapesData;
}
inline bool GetResponseResponse_AudioResponse::has_blendshapes_data() const {
  return _internal_has_blendshapes_data();
}
inline void GetResponseResponse_AudioResponse::set_has_blendshapes_data() {
  _impl_._oneof_case_[0] = kBlendshapesData;
}
inline void GetResponseResponse_AudioResponse::clear_blendshapes_data() {
  if (_internal_has_blendshapes_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.face_data_type_.blendshapes_data_;
    }
    clear_has_face_data_type();
  }
}
inline ::service::BlendShapesData* GetResponseResponse_AudioResponse::release_blendshapes_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.AudioResponse.blendshapes_data)
  if (_internal_has_blendshapes_data()) {
    clear_has_face_data_type();
    ::service::BlendShapesData* temp = _impl_.face_data_type_.blendshapes_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.face_data_type_.blendshapes_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::BlendShapesData& GetResponseResponse_AudioResponse::_internal_blendshapes_data() const {
  return _internal_has_blendshapes_data()
      ? *_impl_.face_data_type_.blendshapes_data_
      : reinterpret_cast< ::service::BlendShapesData&>(::service::_BlendShapesData_default_instance_);
}
inline const ::service::BlendShapesData& GetResponseResponse_AudioResponse::blendshapes_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.blendshapes_data)
  return _internal_blendshapes_data();
}
inline ::service::BlendShapesData* GetResponseResponse_AudioResponse::unsafe_arena_release_blendshapes_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseResponse.AudioResponse.blendshapes_data)
  if (_internal_has_blendshapes_data()) {
    clear_has_face_data_type();
    ::service::BlendShapesData* temp = _impl_.face_data_type_.blendshapes_data_;
    _impl_.face_data_type_.blendshapes_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse_AudioResponse::unsafe_arena_set_allocated_blendshapes_data(::service::BlendShapesData* blendshapes_data) {
  clear_face_data_type();
  if (blendshapes_data) {
    set_has_blendshapes_data();
    _impl_.face_data_type_.blendshapes_data_ = blendshapes_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.AudioResponse.blendshapes_data)
}
inline ::service::BlendShapesData* GetResponseResponse_AudioResponse::_internal_mutable_blendshapes_data() {
  if (!_internal_has_blendshapes_data()) {
    clear_face_data_type();
    set_has_blendshapes_data();
    _impl_.face_data_type_.blendshapes_data_ = CreateMaybeMessage< ::service::BlendShapesData >(GetArenaForAllocation());
  }
  return _impl_.face_data_type_.blendshapes_data_;
}
inline ::service::BlendShapesData* GetResponseResponse_AudioResponse::mutable_blendshapes_data() {
  ::service::BlendShapesData* _msg = _internal_mutable_blendshapes_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.AudioResponse.blendshapes_data)
  return _msg;
}

// .service.ARKitBlendShapesData face_emotion = 8;
inline bool GetResponseResponse_AudioResponse::_internal_has_face_emotion() const {
  return this != internal_default_instance() && _impl_.face_emotion_ != nullptr;
}
inline bool GetResponseResponse_AudioResponse::has_face_emotion() const {
  return _internal_has_face_emotion();
}
inline const ::service::ARKitBlendShapesData& GetResponseResponse_AudioResponse::_internal_face_emotion() const {
  const ::service::ARKitBlendShapesData* p = _impl_.face_emotion_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::ARKitBlendShapesData&>(
      ::service::_ARKitBlendShapesData_default_instance_);
}
inline const ::service::ARKitBlendShapesData& GetResponseResponse_AudioResponse::face_emotion() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.face_emotion)
  return _internal_face_emotion();
}
inline void GetResponseResponse_AudioResponse::unsafe_arena_set_allocated_face_emotion(
    ::service::ARKitBlendShapesData* face_emotion) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.face_emotion_);
  }
  _impl_.face_emotion_ = face_emotion;
  if (face_emotion) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.AudioResponse.face_emotion)
}
inline ::service::ARKitBlendShapesData* GetResponseResponse_AudioResponse::release_face_emotion() {
  
  ::service::ARKitBlendShapesData* temp = _impl_.face_emotion_;
  _impl_.face_emotion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service::ARKitBlendShapesData* GetResponseResponse_AudioResponse::unsafe_arena_release_face_emotion() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.AudioResponse.face_emotion)
  
  ::service::ARKitBlendShapesData* temp = _impl_.face_emotion_;
  _impl_.face_emotion_ = nullptr;
  return temp;
}
inline ::service::ARKitBlendShapesData* GetResponseResponse_AudioResponse::_internal_mutable_face_emotion() {
  
  if (_impl_.face_emotion_ == nullptr) {
    auto* p = CreateMaybeMessage<::service::ARKitBlendShapesData>(GetArenaForAllocation());
    _impl_.face_emotion_ = p;
  }
  return _impl_.face_emotion_;
}
inline ::service::ARKitBlendShapesData* GetResponseResponse_AudioResponse::mutable_face_emotion() {
  ::service::ARKitBlendShapesData* _msg = _internal_mutable_face_emotion();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.AudioResponse.face_emotion)
  return _msg;
}
inline void GetResponseResponse_AudioResponse::set_allocated_face_emotion(::service::ARKitBlendShapesData* face_emotion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.face_emotion_);
  }
  if (face_emotion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(face_emotion));
    if (message_arena != submessage_arena) {
      face_emotion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, face_emotion, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.face_emotion_ = face_emotion;
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.AudioResponse.face_emotion)
}

// .service.EmotionResponse emotion_response = 9;
inline bool GetResponseResponse_AudioResponse::_internal_has_emotion_response() const {
  return this != internal_default_instance() && _impl_.emotion_response_ != nullptr;
}
inline bool GetResponseResponse_AudioResponse::has_emotion_response() const {
  return _internal_has_emotion_response();
}
inline void GetResponseResponse_AudioResponse::clear_emotion_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.emotion_response_ != nullptr) {
    delete _impl_.emotion_response_;
  }
  _impl_.emotion_response_ = nullptr;
}
inline const ::service::EmotionResponse& GetResponseResponse_AudioResponse::_internal_emotion_response() const {
  const ::service::EmotionResponse* p = _impl_.emotion_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::EmotionResponse&>(
      ::service::_EmotionResponse_default_instance_);
}
inline const ::service::EmotionResponse& GetResponseResponse_AudioResponse::emotion_response() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.emotion_response)
  return _internal_emotion_response();
}
inline void GetResponseResponse_AudioResponse::unsafe_arena_set_allocated_emotion_response(
    ::service::EmotionResponse* emotion_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.emotion_response_);
  }
  _impl_.emotion_response_ = emotion_response;
  if (emotion_response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.AudioResponse.emotion_response)
}
inline ::service::EmotionResponse* GetResponseResponse_AudioResponse::release_emotion_response() {
  
  ::service::EmotionResponse* temp = _impl_.emotion_response_;
  _impl_.emotion_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service::EmotionResponse* GetResponseResponse_AudioResponse::unsafe_arena_release_emotion_response() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.AudioResponse.emotion_response)
  
  ::service::EmotionResponse* temp = _impl_.emotion_response_;
  _impl_.emotion_response_ = nullptr;
  return temp;
}
inline ::service::EmotionResponse* GetResponseResponse_AudioResponse::_internal_mutable_emotion_response() {
  
  if (_impl_.emotion_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::service::EmotionResponse>(GetArenaForAllocation());
    _impl_.emotion_response_ = p;
  }
  return _impl_.emotion_response_;
}
inline ::service::EmotionResponse* GetResponseResponse_AudioResponse::mutable_emotion_response() {
  ::service::EmotionResponse* _msg = _internal_mutable_emotion_response();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.AudioResponse.emotion_response)
  return _msg;
}
inline void GetResponseResponse_AudioResponse::set_allocated_emotion_response(::service::EmotionResponse* emotion_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.emotion_response_;
  }
  if (emotion_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(emotion_response);
    if (message_arena != submessage_arena) {
      emotion_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, emotion_response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.emotion_response_ = emotion_response;
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.AudioResponse.emotion_response)
}

inline bool GetResponseResponse_AudioResponse::has_face_data_type() const {
  return face_data_type_case() != FACE_DATA_TYPE_NOT_SET;
}
inline void GetResponseResponse_AudioResponse::clear_has_face_data_type() {
  _impl_._oneof_case_[0] = FACE_DATA_TYPE_NOT_SET;
}
inline GetResponseResponse_AudioResponse::FaceDataTypeCase GetResponseResponse_AudioResponse::face_data_type_case() const {
  return GetResponseResponse_AudioResponse::FaceDataTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetResponseResponse_ActionResponse

// string action = 1;
inline void GetResponseResponse_ActionResponse::clear_action() {
  _impl_.action_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_ActionResponse::action() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.ActionResponse.action)
  return _internal_action();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseResponse_ActionResponse::set_action(ArgT0&& arg0, ArgT... args) {
 
 _impl_.action_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.ActionResponse.action)
}
inline std::string* GetResponseResponse_ActionResponse::mutable_action() {
  std::string* _s = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.ActionResponse.action)
  return _s;
}
inline const std::string& GetResponseResponse_ActionResponse::_internal_action() const {
  return _impl_.action_.Get();
}
inline void GetResponseResponse_ActionResponse::_internal_set_action(const std::string& value) {
  
  _impl_.action_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseResponse_ActionResponse::_internal_mutable_action() {
  
  return _impl_.action_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseResponse_ActionResponse::release_action() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.ActionResponse.action)
  return _impl_.action_.Release();
}
inline void GetResponseResponse_ActionResponse::set_allocated_action(std::string* action) {
  if (action != nullptr) {
    
  } else {
    
  }
  _impl_.action_.SetAllocated(action, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.action_.IsDefault()) {
    _impl_.action_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.ActionResponse.action)
}

// -------------------------------------------------------------------

// GetResponseResponse_BehaviorTreeResponse

// string bt_code = 1;
inline void GetResponseResponse_BehaviorTreeResponse::clear_bt_code() {
  _impl_.bt_code_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_BehaviorTreeResponse::bt_code() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.BehaviorTreeResponse.bt_code)
  return _internal_bt_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseResponse_BehaviorTreeResponse::set_bt_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bt_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.BehaviorTreeResponse.bt_code)
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::mutable_bt_code() {
  std::string* _s = _internal_mutable_bt_code();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.BehaviorTreeResponse.bt_code)
  return _s;
}
inline const std::string& GetResponseResponse_BehaviorTreeResponse::_internal_bt_code() const {
  return _impl_.bt_code_.Get();
}
inline void GetResponseResponse_BehaviorTreeResponse::_internal_set_bt_code(const std::string& value) {
  
  _impl_.bt_code_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::_internal_mutable_bt_code() {
  
  return _impl_.bt_code_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::release_bt_code() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.BehaviorTreeResponse.bt_code)
  return _impl_.bt_code_.Release();
}
inline void GetResponseResponse_BehaviorTreeResponse::set_allocated_bt_code(std::string* bt_code) {
  if (bt_code != nullptr) {
    
  } else {
    
  }
  _impl_.bt_code_.SetAllocated(bt_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bt_code_.IsDefault()) {
    _impl_.bt_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.BehaviorTreeResponse.bt_code)
}

// string bt_constants = 2;
inline void GetResponseResponse_BehaviorTreeResponse::clear_bt_constants() {
  _impl_.bt_constants_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_BehaviorTreeResponse::bt_constants() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.BehaviorTreeResponse.bt_constants)
  return _internal_bt_constants();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseResponse_BehaviorTreeResponse::set_bt_constants(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bt_constants_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.BehaviorTreeResponse.bt_constants)
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::mutable_bt_constants() {
  std::string* _s = _internal_mutable_bt_constants();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.BehaviorTreeResponse.bt_constants)
  return _s;
}
inline const std::string& GetResponseResponse_BehaviorTreeResponse::_internal_bt_constants() const {
  return _impl_.bt_constants_.Get();
}
inline void GetResponseResponse_BehaviorTreeResponse::_internal_set_bt_constants(const std::string& value) {
  
  _impl_.bt_constants_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::_internal_mutable_bt_constants() {
  
  return _impl_.bt_constants_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::release_bt_constants() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.BehaviorTreeResponse.bt_constants)
  return _impl_.bt_constants_.Release();
}
inline void GetResponseResponse_BehaviorTreeResponse::set_allocated_bt_constants(std::string* bt_constants) {
  if (bt_constants != nullptr) {
    
  } else {
    
  }
  _impl_.bt_constants_.SetAllocated(bt_constants, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bt_constants_.IsDefault()) {
    _impl_.bt_constants_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.BehaviorTreeResponse.bt_constants)
}

// string narrative_section_id = 3;
inline void GetResponseResponse_BehaviorTreeResponse::clear_narrative_section_id() {
  _impl_.narrative_section_id_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_BehaviorTreeResponse::narrative_section_id() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.BehaviorTreeResponse.narrative_section_id)
  return _internal_narrative_section_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseResponse_BehaviorTreeResponse::set_narrative_section_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.narrative_section_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.BehaviorTreeResponse.narrative_section_id)
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::mutable_narrative_section_id() {
  std::string* _s = _internal_mutable_narrative_section_id();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.BehaviorTreeResponse.narrative_section_id)
  return _s;
}
inline const std::string& GetResponseResponse_BehaviorTreeResponse::_internal_narrative_section_id() const {
  return _impl_.narrative_section_id_.Get();
}
inline void GetResponseResponse_BehaviorTreeResponse::_internal_set_narrative_section_id(const std::string& value) {
  
  _impl_.narrative_section_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::_internal_mutable_narrative_section_id() {
  
  return _impl_.narrative_section_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::release_narrative_section_id() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.BehaviorTreeResponse.narrative_section_id)
  return _impl_.narrative_section_id_.Release();
}
inline void GetResponseResponse_BehaviorTreeResponse::set_allocated_narrative_section_id(std::string* narrative_section_id) {
  if (narrative_section_id != nullptr) {
    
  } else {
    
  }
  _impl_.narrative_section_id_.SetAllocated(narrative_section_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.narrative_section_id_.IsDefault()) {
    _impl_.narrative_section_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.BehaviorTreeResponse.narrative_section_id)
}

// -------------------------------------------------------------------

// GetResponseResponse_UserTranscript

// string text_data = 1;
inline void GetResponseResponse_UserTranscript::clear_text_data() {
  _impl_.text_data_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_UserTranscript::text_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.UserTranscript.text_data)
  return _internal_text_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseResponse_UserTranscript::set_text_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.UserTranscript.text_data)
}
inline std::string* GetResponseResponse_UserTranscript::mutable_text_data() {
  std::string* _s = _internal_mutable_text_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.UserTranscript.text_data)
  return _s;
}
inline const std::string& GetResponseResponse_UserTranscript::_internal_text_data() const {
  return _impl_.text_data_.Get();
}
inline void GetResponseResponse_UserTranscript::_internal_set_text_data(const std::string& value) {
  
  _impl_.text_data_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseResponse_UserTranscript::_internal_mutable_text_data() {
  
  return _impl_.text_data_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseResponse_UserTranscript::release_text_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.UserTranscript.text_data)
  return _impl_.text_data_.Release();
}
inline void GetResponseResponse_UserTranscript::set_allocated_text_data(std::string* text_data) {
  if (text_data != nullptr) {
    
  } else {
    
  }
  _impl_.text_data_.SetAllocated(text_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_data_.IsDefault()) {
    _impl_.text_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.UserTranscript.text_data)
}

// bool is_final = 2;
inline void GetResponseResponse_UserTranscript::clear_is_final() {
  _impl_.is_final_ = false;
}
inline bool GetResponseResponse_UserTranscript::_internal_is_final() const {
  return _impl_.is_final_;
}
inline bool GetResponseResponse_UserTranscript::is_final() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.UserTranscript.is_final)
  return _internal_is_final();
}
inline void GetResponseResponse_UserTranscript::_internal_set_is_final(bool value) {
  
  _impl_.is_final_ = value;
}
inline void GetResponseResponse_UserTranscript::set_is_final(bool value) {
  _internal_set_is_final(value);
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.UserTranscript.is_final)
}

// bool end_of_response = 3;
inline void GetResponseResponse_UserTranscript::clear_end_of_response() {
  _impl_.end_of_response_ = false;
}
inline bool GetResponseResponse_UserTranscript::_internal_end_of_response() const {
  return _impl_.end_of_response_;
}
inline bool GetResponseResponse_UserTranscript::end_of_response() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.UserTranscript.end_of_response)
  return _internal_end_of_response();
}
inline void GetResponseResponse_UserTranscript::_internal_set_end_of_response(bool value) {
  
  _impl_.end_of_response_ = value;
}
inline void GetResponseResponse_UserTranscript::set_end_of_response(bool value) {
  _internal_set_end_of_response(value);
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.UserTranscript.end_of_response)
}

// -------------------------------------------------------------------

// GetResponseResponse

// string session_id = 1;
inline void GetResponseResponse::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& GetResponseResponse::session_id() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseResponse::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.session_id)
}
inline std::string* GetResponseResponse::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.session_id)
  return _s;
}
inline const std::string& GetResponseResponse::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void GetResponseResponse::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseResponse::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseResponse::release_session_id() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.session_id)
  return _impl_.session_id_.Release();
}
inline void GetResponseResponse::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.session_id)
}

// .service.GetResponseResponse.ActionResponse action_response = 2;
inline bool GetResponseResponse::_internal_has_action_response() const {
  return response_type_case() == kActionResponse;
}
inline bool GetResponseResponse::has_action_response() const {
  return _internal_has_action_response();
}
inline void GetResponseResponse::set_has_action_response() {
  _impl_._oneof_case_[0] = kActionResponse;
}
inline void GetResponseResponse::clear_action_response() {
  if (_internal_has_action_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_type_.action_response_;
    }
    clear_has_response_type();
  }
}
inline ::service::GetResponseResponse_ActionResponse* GetResponseResponse::release_action_response() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.action_response)
  if (_internal_has_action_response()) {
    clear_has_response_type();
    ::service::GetResponseResponse_ActionResponse* temp = _impl_.response_type_.action_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.action_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::GetResponseResponse_ActionResponse& GetResponseResponse::_internal_action_response() const {
  return _internal_has_action_response()
      ? *_impl_.response_type_.action_response_
      : reinterpret_cast< ::service::GetResponseResponse_ActionResponse&>(::service::_GetResponseResponse_ActionResponse_default_instance_);
}
inline const ::service::GetResponseResponse_ActionResponse& GetResponseResponse::action_response() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.action_response)
  return _internal_action_response();
}
inline ::service::GetResponseResponse_ActionResponse* GetResponseResponse::unsafe_arena_release_action_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseResponse.action_response)
  if (_internal_has_action_response()) {
    clear_has_response_type();
    ::service::GetResponseResponse_ActionResponse* temp = _impl_.response_type_.action_response_;
    _impl_.response_type_.action_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse::unsafe_arena_set_allocated_action_response(::service::GetResponseResponse_ActionResponse* action_response) {
  clear_response_type();
  if (action_response) {
    set_has_action_response();
    _impl_.response_type_.action_response_ = action_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.action_response)
}
inline ::service::GetResponseResponse_ActionResponse* GetResponseResponse::_internal_mutable_action_response() {
  if (!_internal_has_action_response()) {
    clear_response_type();
    set_has_action_response();
    _impl_.response_type_.action_response_ = CreateMaybeMessage< ::service::GetResponseResponse_ActionResponse >(GetArenaForAllocation());
  }
  return _impl_.response_type_.action_response_;
}
inline ::service::GetResponseResponse_ActionResponse* GetResponseResponse::mutable_action_response() {
  ::service::GetResponseResponse_ActionResponse* _msg = _internal_mutable_action_response();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.action_response)
  return _msg;
}

// .service.GetResponseResponse.AudioResponse audio_response = 3;
inline bool GetResponseResponse::_internal_has_audio_response() const {
  return response_type_case() == kAudioResponse;
}
inline bool GetResponseResponse::has_audio_response() const {
  return _internal_has_audio_response();
}
inline void GetResponseResponse::set_has_audio_response() {
  _impl_._oneof_case_[0] = kAudioResponse;
}
inline void GetResponseResponse::clear_audio_response() {
  if (_internal_has_audio_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_type_.audio_response_;
    }
    clear_has_response_type();
  }
}
inline ::service::GetResponseResponse_AudioResponse* GetResponseResponse::release_audio_response() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.audio_response)
  if (_internal_has_audio_response()) {
    clear_has_response_type();
    ::service::GetResponseResponse_AudioResponse* temp = _impl_.response_type_.audio_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.audio_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::GetResponseResponse_AudioResponse& GetResponseResponse::_internal_audio_response() const {
  return _internal_has_audio_response()
      ? *_impl_.response_type_.audio_response_
      : reinterpret_cast< ::service::GetResponseResponse_AudioResponse&>(::service::_GetResponseResponse_AudioResponse_default_instance_);
}
inline const ::service::GetResponseResponse_AudioResponse& GetResponseResponse::audio_response() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.audio_response)
  return _internal_audio_response();
}
inline ::service::GetResponseResponse_AudioResponse* GetResponseResponse::unsafe_arena_release_audio_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseResponse.audio_response)
  if (_internal_has_audio_response()) {
    clear_has_response_type();
    ::service::GetResponseResponse_AudioResponse* temp = _impl_.response_type_.audio_response_;
    _impl_.response_type_.audio_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse::unsafe_arena_set_allocated_audio_response(::service::GetResponseResponse_AudioResponse* audio_response) {
  clear_response_type();
  if (audio_response) {
    set_has_audio_response();
    _impl_.response_type_.audio_response_ = audio_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.audio_response)
}
inline ::service::GetResponseResponse_AudioResponse* GetResponseResponse::_internal_mutable_audio_response() {
  if (!_internal_has_audio_response()) {
    clear_response_type();
    set_has_audio_response();
    _impl_.response_type_.audio_response_ = CreateMaybeMessage< ::service::GetResponseResponse_AudioResponse >(GetArenaForAllocation());
  }
  return _impl_.response_type_.audio_response_;
}
inline ::service::GetResponseResponse_AudioResponse* GetResponseResponse::mutable_audio_response() {
  ::service::GetResponseResponse_AudioResponse* _msg = _internal_mutable_audio_response();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.audio_response)
  return _msg;
}

// string debug_log = 4;
inline bool GetResponseResponse::_internal_has_debug_log() const {
  return response_type_case() == kDebugLog;
}
inline bool GetResponseResponse::has_debug_log() const {
  return _internal_has_debug_log();
}
inline void GetResponseResponse::set_has_debug_log() {
  _impl_._oneof_case_[0] = kDebugLog;
}
inline void GetResponseResponse::clear_debug_log() {
  if (_internal_has_debug_log()) {
    _impl_.response_type_.debug_log_.Destroy();
    clear_has_response_type();
  }
}
inline const std::string& GetResponseResponse::debug_log() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.debug_log)
  return _internal_debug_log();
}
template <typename ArgT0, typename... ArgT>
inline void GetResponseResponse::set_debug_log(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_debug_log()) {
    clear_response_type();
    set_has_debug_log();
    _impl_.response_type_.debug_log_.InitDefault();
  }
  _impl_.response_type_.debug_log_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.debug_log)
}
inline std::string* GetResponseResponse::mutable_debug_log() {
  std::string* _s = _internal_mutable_debug_log();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.debug_log)
  return _s;
}
inline const std::string& GetResponseResponse::_internal_debug_log() const {
  if (_internal_has_debug_log()) {
    return _impl_.response_type_.debug_log_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void GetResponseResponse::_internal_set_debug_log(const std::string& value) {
  if (!_internal_has_debug_log()) {
    clear_response_type();
    set_has_debug_log();
    _impl_.response_type_.debug_log_.InitDefault();
  }
  _impl_.response_type_.debug_log_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseResponse::_internal_mutable_debug_log() {
  if (!_internal_has_debug_log()) {
    clear_response_type();
    set_has_debug_log();
    _impl_.response_type_.debug_log_.InitDefault();
  }
  return _impl_.response_type_.debug_log_.Mutable(      GetArenaForAllocation());
}
inline std::string* GetResponseResponse::release_debug_log() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.debug_log)
  if (_internal_has_debug_log()) {
    clear_has_response_type();
    return _impl_.response_type_.debug_log_.Release();
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse::set_allocated_debug_log(std::string* debug_log) {
  if (has_response_type()) {
    clear_response_type();
  }
  if (debug_log != nullptr) {
    set_has_debug_log();
    _impl_.response_type_.debug_log_.InitAllocated(debug_log, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.debug_log)
}

// .service.GetResponseResponse.UserTranscript user_query = 5;
inline bool GetResponseResponse::_internal_has_user_query() const {
  return response_type_case() == kUserQuery;
}
inline bool GetResponseResponse::has_user_query() const {
  return _internal_has_user_query();
}
inline void GetResponseResponse::set_has_user_query() {
  _impl_._oneof_case_[0] = kUserQuery;
}
inline void GetResponseResponse::clear_user_query() {
  if (_internal_has_user_query()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_type_.user_query_;
    }
    clear_has_response_type();
  }
}
inline ::service::GetResponseResponse_UserTranscript* GetResponseResponse::release_user_query() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.user_query)
  if (_internal_has_user_query()) {
    clear_has_response_type();
    ::service::GetResponseResponse_UserTranscript* temp = _impl_.response_type_.user_query_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.user_query_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::GetResponseResponse_UserTranscript& GetResponseResponse::_internal_user_query() const {
  return _internal_has_user_query()
      ? *_impl_.response_type_.user_query_
      : reinterpret_cast< ::service::GetResponseResponse_UserTranscript&>(::service::_GetResponseResponse_UserTranscript_default_instance_);
}
inline const ::service::GetResponseResponse_UserTranscript& GetResponseResponse::user_query() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.user_query)
  return _internal_user_query();
}
inline ::service::GetResponseResponse_UserTranscript* GetResponseResponse::unsafe_arena_release_user_query() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseResponse.user_query)
  if (_internal_has_user_query()) {
    clear_has_response_type();
    ::service::GetResponseResponse_UserTranscript* temp = _impl_.response_type_.user_query_;
    _impl_.response_type_.user_query_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse::unsafe_arena_set_allocated_user_query(::service::GetResponseResponse_UserTranscript* user_query) {
  clear_response_type();
  if (user_query) {
    set_has_user_query();
    _impl_.response_type_.user_query_ = user_query;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.user_query)
}
inline ::service::GetResponseResponse_UserTranscript* GetResponseResponse::_internal_mutable_user_query() {
  if (!_internal_has_user_query()) {
    clear_response_type();
    set_has_user_query();
    _impl_.response_type_.user_query_ = CreateMaybeMessage< ::service::GetResponseResponse_UserTranscript >(GetArenaForAllocation());
  }
  return _impl_.response_type_.user_query_;
}
inline ::service::GetResponseResponse_UserTranscript* GetResponseResponse::mutable_user_query() {
  ::service::GetResponseResponse_UserTranscript* _msg = _internal_mutable_user_query();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.user_query)
  return _msg;
}

// .service.GetResponseResponse.BehaviorTreeResponse bt_response = 6;
inline bool GetResponseResponse::_internal_has_bt_response() const {
  return response_type_case() == kBtResponse;
}
inline bool GetResponseResponse::has_bt_response() const {
  return _internal_has_bt_response();
}
inline void GetResponseResponse::set_has_bt_response() {
  _impl_._oneof_case_[0] = kBtResponse;
}
inline void GetResponseResponse::clear_bt_response() {
  if (_internal_has_bt_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_type_.bt_response_;
    }
    clear_has_response_type();
  }
}
inline ::service::GetResponseResponse_BehaviorTreeResponse* GetResponseResponse::release_bt_response() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.bt_response)
  if (_internal_has_bt_response()) {
    clear_has_response_type();
    ::service::GetResponseResponse_BehaviorTreeResponse* temp = _impl_.response_type_.bt_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.bt_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::GetResponseResponse_BehaviorTreeResponse& GetResponseResponse::_internal_bt_response() const {
  return _internal_has_bt_response()
      ? *_impl_.response_type_.bt_response_
      : reinterpret_cast< ::service::GetResponseResponse_BehaviorTreeResponse&>(::service::_GetResponseResponse_BehaviorTreeResponse_default_instance_);
}
inline const ::service::GetResponseResponse_BehaviorTreeResponse& GetResponseResponse::bt_response() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.bt_response)
  return _internal_bt_response();
}
inline ::service::GetResponseResponse_BehaviorTreeResponse* GetResponseResponse::unsafe_arena_release_bt_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseResponse.bt_response)
  if (_internal_has_bt_response()) {
    clear_has_response_type();
    ::service::GetResponseResponse_BehaviorTreeResponse* temp = _impl_.response_type_.bt_response_;
    _impl_.response_type_.bt_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse::unsafe_arena_set_allocated_bt_response(::service::GetResponseResponse_BehaviorTreeResponse* bt_response) {
  clear_response_type();
  if (bt_response) {
    set_has_bt_response();
    _impl_.response_type_.bt_response_ = bt_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.bt_response)
}
inline ::service::GetResponseResponse_BehaviorTreeResponse* GetResponseResponse::_internal_mutable_bt_response() {
  if (!_internal_has_bt_response()) {
    clear_response_type();
    set_has_bt_response();
    _impl_.response_type_.bt_response_ = CreateMaybeMessage< ::service::GetResponseResponse_BehaviorTreeResponse >(GetArenaForAllocation());
  }
  return _impl_.response_type_.bt_response_;
}
inline ::service::GetResponseResponse_BehaviorTreeResponse* GetResponseResponse::mutable_bt_response() {
  ::service::GetResponseResponse_BehaviorTreeResponse* _msg = _internal_mutable_bt_response();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.bt_response)
  return _msg;
}

// string emotion_response = 7;
inline bool GetResponseResponse::_internal_has_emotion_response() const {
  return response_type_case() == kEmotionResponse;
}
inline bool GetResponseResponse::has_emotion_response() const {
  return _internal_has_emotion_response();
}
inline void GetResponseResponse::set_has_emotion_response() {
  _impl_._oneof_case_[0] = kEmotionResponse;
}
inline void GetResponseResponse::clear_emotion_response() {
  if (_internal_has_emotion_response()) {
    _impl_.response_type_.emotion_response_.Destroy();
    clear_has_response_type();
  }
}
inline const std::string& GetResponseResponse::emotion_response() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.emotion_response)
  return _internal_emotion_response();
}
template <typename ArgT0, typename... ArgT>
inline void GetResponseResponse::set_emotion_response(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_emotion_response()) {
    clear_response_type();
    set_has_emotion_response();
    _impl_.response_type_.emotion_response_.InitDefault();
  }
  _impl_.response_type_.emotion_response_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.emotion_response)
}
inline std::string* GetResponseResponse::mutable_emotion_response() {
  std::string* _s = _internal_mutable_emotion_response();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.emotion_response)
  return _s;
}
inline const std::string& GetResponseResponse::_internal_emotion_response() const {
  if (_internal_has_emotion_response()) {
    return _impl_.response_type_.emotion_response_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void GetResponseResponse::_internal_set_emotion_response(const std::string& value) {
  if (!_internal_has_emotion_response()) {
    clear_response_type();
    set_has_emotion_response();
    _impl_.response_type_.emotion_response_.InitDefault();
  }
  _impl_.response_type_.emotion_response_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseResponse::_internal_mutable_emotion_response() {
  if (!_internal_has_emotion_response()) {
    clear_response_type();
    set_has_emotion_response();
    _impl_.response_type_.emotion_response_.InitDefault();
  }
  return _impl_.response_type_.emotion_response_.Mutable(      GetArenaForAllocation());
}
inline std::string* GetResponseResponse::release_emotion_response() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.emotion_response)
  if (_internal_has_emotion_response()) {
    clear_has_response_type();
    return _impl_.response_type_.emotion_response_.Release();
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse::set_allocated_emotion_response(std::string* emotion_response) {
  if (has_response_type()) {
    clear_response_type();
  }
  if (emotion_response != nullptr) {
    set_has_emotion_response();
    _impl_.response_type_.emotion_response_.InitAllocated(emotion_response, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.emotion_response)
}

// string interaction_id = 8;
inline bool GetResponseResponse::_internal_has_interaction_id() const {
  return response_type_case() == kInteractionId;
}
inline bool GetResponseResponse::has_interaction_id() const {
  return _internal_has_interaction_id();
}
inline void GetResponseResponse::set_has_interaction_id() {
  _impl_._oneof_case_[0] = kInteractionId;
}
inline void GetResponseResponse::clear_interaction_id() {
  if (_internal_has_interaction_id()) {
    _impl_.response_type_.interaction_id_.Destroy();
    clear_has_response_type();
  }
}
inline const std::string& GetResponseResponse::interaction_id() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.interaction_id)
  return _internal_interaction_id();
}
template <typename ArgT0, typename... ArgT>
inline void GetResponseResponse::set_interaction_id(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_interaction_id()) {
    clear_response_type();
    set_has_interaction_id();
    _impl_.response_type_.interaction_id_.InitDefault();
  }
  _impl_.response_type_.interaction_id_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.interaction_id)
}
inline std::string* GetResponseResponse::mutable_interaction_id() {
  std::string* _s = _internal_mutable_interaction_id();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.interaction_id)
  return _s;
}
inline const std::string& GetResponseResponse::_internal_interaction_id() const {
  if (_internal_has_interaction_id()) {
    return _impl_.response_type_.interaction_id_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void GetResponseResponse::_internal_set_interaction_id(const std::string& value) {
  if (!_internal_has_interaction_id()) {
    clear_response_type();
    set_has_interaction_id();
    _impl_.response_type_.interaction_id_.InitDefault();
  }
  _impl_.response_type_.interaction_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseResponse::_internal_mutable_interaction_id() {
  if (!_internal_has_interaction_id()) {
    clear_response_type();
    set_has_interaction_id();
    _impl_.response_type_.interaction_id_.InitDefault();
  }
  return _impl_.response_type_.interaction_id_.Mutable(      GetArenaForAllocation());
}
inline std::string* GetResponseResponse::release_interaction_id() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.interaction_id)
  if (_internal_has_interaction_id()) {
    clear_has_response_type();
    return _impl_.response_type_.interaction_id_.Release();
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse::set_allocated_interaction_id(std::string* interaction_id) {
  if (has_response_type()) {
    clear_response_type();
  }
  if (interaction_id != nullptr) {
    set_has_interaction_id();
    _impl_.response_type_.interaction_id_.InitAllocated(interaction_id, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.interaction_id)
}

inline bool GetResponseResponse::has_response_type() const {
  return response_type_case() != RESPONSE_TYPE_NOT_SET;
}
inline void GetResponseResponse::clear_has_response_type() {
  _impl_._oneof_case_[0] = RESPONSE_TYPE_NOT_SET;
}
inline GetResponseResponse::ResponseTypeCase GetResponseResponse::response_type_case() const {
  return GetResponseResponse::ResponseTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// VisemesData

// .service.Viseme visemes = 1;
inline bool VisemesData::_internal_has_visemes() const {
  return this != internal_default_instance() && _impl_.visemes_ != nullptr;
}
inline bool VisemesData::has_visemes() const {
  return _internal_has_visemes();
}
inline void VisemesData::clear_visemes() {
  if (GetArenaForAllocation() == nullptr && _impl_.visemes_ != nullptr) {
    delete _impl_.visemes_;
  }
  _impl_.visemes_ = nullptr;
}
inline const ::service::Viseme& VisemesData::_internal_visemes() const {
  const ::service::Viseme* p = _impl_.visemes_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::Viseme&>(
      ::service::_Viseme_default_instance_);
}
inline const ::service::Viseme& VisemesData::visemes() const {
  // @@protoc_insertion_point(field_get:service.VisemesData.visemes)
  return _internal_visemes();
}
inline void VisemesData::unsafe_arena_set_allocated_visemes(
    ::service::Viseme* visemes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visemes_);
  }
  _impl_.visemes_ = visemes;
  if (visemes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.VisemesData.visemes)
}
inline ::service::Viseme* VisemesData::release_visemes() {
  
  ::service::Viseme* temp = _impl_.visemes_;
  _impl_.visemes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service::Viseme* VisemesData::unsafe_arena_release_visemes() {
  // @@protoc_insertion_point(field_release:service.VisemesData.visemes)
  
  ::service::Viseme* temp = _impl_.visemes_;
  _impl_.visemes_ = nullptr;
  return temp;
}
inline ::service::Viseme* VisemesData::_internal_mutable_visemes() {
  
  if (_impl_.visemes_ == nullptr) {
    auto* p = CreateMaybeMessage<::service::Viseme>(GetArenaForAllocation());
    _impl_.visemes_ = p;
  }
  return _impl_.visemes_;
}
inline ::service::Viseme* VisemesData::mutable_visemes() {
  ::service::Viseme* _msg = _internal_mutable_visemes();
  // @@protoc_insertion_point(field_mutable:service.VisemesData.visemes)
  return _msg;
}
inline void VisemesData::set_allocated_visemes(::service::Viseme* visemes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.visemes_;
  }
  if (visemes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(visemes);
    if (message_arena != submessage_arena) {
      visemes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visemes, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.visemes_ = visemes;
  // @@protoc_insertion_point(field_set_allocated:service.VisemesData.visemes)
}

// -------------------------------------------------------------------

// EmotionResponse

// string emotion = 1;
inline void EmotionResponse::clear_emotion() {
  _impl_.emotion_.ClearToEmpty();
}
inline const std::string& EmotionResponse::emotion() const {
  // @@protoc_insertion_point(field_get:service.EmotionResponse.emotion)
  return _internal_emotion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EmotionResponse::set_emotion(ArgT0&& arg0, ArgT... args) {
 
 _impl_.emotion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.EmotionResponse.emotion)
}
inline std::string* EmotionResponse::mutable_emotion() {
  std::string* _s = _internal_mutable_emotion();
  // @@protoc_insertion_point(field_mutable:service.EmotionResponse.emotion)
  return _s;
}
inline const std::string& EmotionResponse::_internal_emotion() const {
  return _impl_.emotion_.Get();
}
inline void EmotionResponse::_internal_set_emotion(const std::string& value) {
  
  _impl_.emotion_.Set(value, GetArenaForAllocation());
}
inline std::string* EmotionResponse::_internal_mutable_emotion() {
  
  return _impl_.emotion_.Mutable(GetArenaForAllocation());
}
inline std::string* EmotionResponse::release_emotion() {
  // @@protoc_insertion_point(field_release:service.EmotionResponse.emotion)
  return _impl_.emotion_.Release();
}
inline void EmotionResponse::set_allocated_emotion(std::string* emotion) {
  if (emotion != nullptr) {
    
  } else {
    
  }
  _impl_.emotion_.SetAllocated(emotion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.emotion_.IsDefault()) {
    _impl_.emotion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.EmotionResponse.emotion)
}

// string scale = 2;
inline void EmotionResponse::clear_scale() {
  _impl_.scale_.ClearToEmpty();
}
inline const std::string& EmotionResponse::scale() const {
  // @@protoc_insertion_point(field_get:service.EmotionResponse.scale)
  return _internal_scale();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EmotionResponse::set_scale(ArgT0&& arg0, ArgT... args) {
 
 _impl_.scale_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.EmotionResponse.scale)
}
inline std::string* EmotionResponse::mutable_scale() {
  std::string* _s = _internal_mutable_scale();
  // @@protoc_insertion_point(field_mutable:service.EmotionResponse.scale)
  return _s;
}
inline const std::string& EmotionResponse::_internal_scale() const {
  return _impl_.scale_.Get();
}
inline void EmotionResponse::_internal_set_scale(const std::string& value) {
  
  _impl_.scale_.Set(value, GetArenaForAllocation());
}
inline std::string* EmotionResponse::_internal_mutable_scale() {
  
  return _impl_.scale_.Mutable(GetArenaForAllocation());
}
inline std::string* EmotionResponse::release_scale() {
  // @@protoc_insertion_point(field_release:service.EmotionResponse.scale)
  return _impl_.scale_.Release();
}
inline void EmotionResponse::set_allocated_scale(std::string* scale) {
  if (scale != nullptr) {
    
  } else {
    
  }
  _impl_.scale_.SetAllocated(scale, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.scale_.IsDefault()) {
    _impl_.scale_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.EmotionResponse.scale)
}

// -------------------------------------------------------------------

// Viseme

// float sil = 1;
inline void Viseme::clear_sil() {
  _impl_.sil_ = 0;
}
inline float Viseme::_internal_sil() const {
  return _impl_.sil_;
}
inline float Viseme::sil() const {
  // @@protoc_insertion_point(field_get:service.Viseme.sil)
  return _internal_sil();
}
inline void Viseme::_internal_set_sil(float value) {
  
  _impl_.sil_ = value;
}
inline void Viseme::set_sil(float value) {
  _internal_set_sil(value);
  // @@protoc_insertion_point(field_set:service.Viseme.sil)
}

// float pp = 2;
inline void Viseme::clear_pp() {
  _impl_.pp_ = 0;
}
inline float Viseme::_internal_pp() const {
  return _impl_.pp_;
}
inline float Viseme::pp() const {
  // @@protoc_insertion_point(field_get:service.Viseme.pp)
  return _internal_pp();
}
inline void Viseme::_internal_set_pp(float value) {
  
  _impl_.pp_ = value;
}
inline void Viseme::set_pp(float value) {
  _internal_set_pp(value);
  // @@protoc_insertion_point(field_set:service.Viseme.pp)
}

// float ff = 3;
inline void Viseme::clear_ff() {
  _impl_.ff_ = 0;
}
inline float Viseme::_internal_ff() const {
  return _impl_.ff_;
}
inline float Viseme::ff() const {
  // @@protoc_insertion_point(field_get:service.Viseme.ff)
  return _internal_ff();
}
inline void Viseme::_internal_set_ff(float value) {
  
  _impl_.ff_ = value;
}
inline void Viseme::set_ff(float value) {
  _internal_set_ff(value);
  // @@protoc_insertion_point(field_set:service.Viseme.ff)
}

// float th = 4;
inline void Viseme::clear_th() {
  _impl_.th_ = 0;
}
inline float Viseme::_internal_th() const {
  return _impl_.th_;
}
inline float Viseme::th() const {
  // @@protoc_insertion_point(field_get:service.Viseme.th)
  return _internal_th();
}
inline void Viseme::_internal_set_th(float value) {
  
  _impl_.th_ = value;
}
inline void Viseme::set_th(float value) {
  _internal_set_th(value);
  // @@protoc_insertion_point(field_set:service.Viseme.th)
}

// float dd = 5;
inline void Viseme::clear_dd() {
  _impl_.dd_ = 0;
}
inline float Viseme::_internal_dd() const {
  return _impl_.dd_;
}
inline float Viseme::dd() const {
  // @@protoc_insertion_point(field_get:service.Viseme.dd)
  return _internal_dd();
}
inline void Viseme::_internal_set_dd(float value) {
  
  _impl_.dd_ = value;
}
inline void Viseme::set_dd(float value) {
  _internal_set_dd(value);
  // @@protoc_insertion_point(field_set:service.Viseme.dd)
}

// float kk = 6;
inline void Viseme::clear_kk() {
  _impl_.kk_ = 0;
}
inline float Viseme::_internal_kk() const {
  return _impl_.kk_;
}
inline float Viseme::kk() const {
  // @@protoc_insertion_point(field_get:service.Viseme.kk)
  return _internal_kk();
}
inline void Viseme::_internal_set_kk(float value) {
  
  _impl_.kk_ = value;
}
inline void Viseme::set_kk(float value) {
  _internal_set_kk(value);
  // @@protoc_insertion_point(field_set:service.Viseme.kk)
}

// float ch = 7;
inline void Viseme::clear_ch() {
  _impl_.ch_ = 0;
}
inline float Viseme::_internal_ch() const {
  return _impl_.ch_;
}
inline float Viseme::ch() const {
  // @@protoc_insertion_point(field_get:service.Viseme.ch)
  return _internal_ch();
}
inline void Viseme::_internal_set_ch(float value) {
  
  _impl_.ch_ = value;
}
inline void Viseme::set_ch(float value) {
  _internal_set_ch(value);
  // @@protoc_insertion_point(field_set:service.Viseme.ch)
}

// float ss = 8;
inline void Viseme::clear_ss() {
  _impl_.ss_ = 0;
}
inline float Viseme::_internal_ss() const {
  return _impl_.ss_;
}
inline float Viseme::ss() const {
  // @@protoc_insertion_point(field_get:service.Viseme.ss)
  return _internal_ss();
}
inline void Viseme::_internal_set_ss(float value) {
  
  _impl_.ss_ = value;
}
inline void Viseme::set_ss(float value) {
  _internal_set_ss(value);
  // @@protoc_insertion_point(field_set:service.Viseme.ss)
}

// float nn = 9;
inline void Viseme::clear_nn() {
  _impl_.nn_ = 0;
}
inline float Viseme::_internal_nn() const {
  return _impl_.nn_;
}
inline float Viseme::nn() const {
  // @@protoc_insertion_point(field_get:service.Viseme.nn)
  return _internal_nn();
}
inline void Viseme::_internal_set_nn(float value) {
  
  _impl_.nn_ = value;
}
inline void Viseme::set_nn(float value) {
  _internal_set_nn(value);
  // @@protoc_insertion_point(field_set:service.Viseme.nn)
}

// float rr = 10;
inline void Viseme::clear_rr() {
  _impl_.rr_ = 0;
}
inline float Viseme::_internal_rr() const {
  return _impl_.rr_;
}
inline float Viseme::rr() const {
  // @@protoc_insertion_point(field_get:service.Viseme.rr)
  return _internal_rr();
}
inline void Viseme::_internal_set_rr(float value) {
  
  _impl_.rr_ = value;
}
inline void Viseme::set_rr(float value) {
  _internal_set_rr(value);
  // @@protoc_insertion_point(field_set:service.Viseme.rr)
}

// float aa = 11;
inline void Viseme::clear_aa() {
  _impl_.aa_ = 0;
}
inline float Viseme::_internal_aa() const {
  return _impl_.aa_;
}
inline float Viseme::aa() const {
  // @@protoc_insertion_point(field_get:service.Viseme.aa)
  return _internal_aa();
}
inline void Viseme::_internal_set_aa(float value) {
  
  _impl_.aa_ = value;
}
inline void Viseme::set_aa(float value) {
  _internal_set_aa(value);
  // @@protoc_insertion_point(field_set:service.Viseme.aa)
}

// float e = 12;
inline void Viseme::clear_e() {
  _impl_.e_ = 0;
}
inline float Viseme::_internal_e() const {
  return _impl_.e_;
}
inline float Viseme::e() const {
  // @@protoc_insertion_point(field_get:service.Viseme.e)
  return _internal_e();
}
inline void Viseme::_internal_set_e(float value) {
  
  _impl_.e_ = value;
}
inline void Viseme::set_e(float value) {
  _internal_set_e(value);
  // @@protoc_insertion_point(field_set:service.Viseme.e)
}

// float ih = 13;
inline void Viseme::clear_ih() {
  _impl_.ih_ = 0;
}
inline float Viseme::_internal_ih() const {
  return _impl_.ih_;
}
inline float Viseme::ih() const {
  // @@protoc_insertion_point(field_get:service.Viseme.ih)
  return _internal_ih();
}
inline void Viseme::_internal_set_ih(float value) {
  
  _impl_.ih_ = value;
}
inline void Viseme::set_ih(float value) {
  _internal_set_ih(value);
  // @@protoc_insertion_point(field_set:service.Viseme.ih)
}

// float oh = 14;
inline void Viseme::clear_oh() {
  _impl_.oh_ = 0;
}
inline float Viseme::_internal_oh() const {
  return _impl_.oh_;
}
inline float Viseme::oh() const {
  // @@protoc_insertion_point(field_get:service.Viseme.oh)
  return _internal_oh();
}
inline void Viseme::_internal_set_oh(float value) {
  
  _impl_.oh_ = value;
}
inline void Viseme::set_oh(float value) {
  _internal_set_oh(value);
  // @@protoc_insertion_point(field_set:service.Viseme.oh)
}

// float ou = 15;
inline void Viseme::clear_ou() {
  _impl_.ou_ = 0;
}
inline float Viseme::_internal_ou() const {
  return _impl_.ou_;
}
inline float Viseme::ou() const {
  // @@protoc_insertion_point(field_get:service.Viseme.ou)
  return _internal_ou();
}
inline void Viseme::_internal_set_ou(float value) {
  
  _impl_.ou_ = value;
}
inline void Viseme::set_ou(float value) {
  _internal_set_ou(value);
  // @@protoc_insertion_point(field_set:service.Viseme.ou)
}

// -------------------------------------------------------------------

// BlendShapesData

// string blendshape_data = 1;
inline void BlendShapesData::clear_blendshape_data() {
  _impl_.blendshape_data_.ClearToEmpty();
}
inline const std::string& BlendShapesData::blendshape_data() const {
  // @@protoc_insertion_point(field_get:service.BlendShapesData.blendshape_data)
  return _internal_blendshape_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlendShapesData::set_blendshape_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.blendshape_data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.BlendShapesData.blendshape_data)
}
inline std::string* BlendShapesData::mutable_blendshape_data() {
  std::string* _s = _internal_mutable_blendshape_data();
  // @@protoc_insertion_point(field_mutable:service.BlendShapesData.blendshape_data)
  return _s;
}
inline const std::string& BlendShapesData::_internal_blendshape_data() const {
  return _impl_.blendshape_data_.Get();
}
inline void BlendShapesData::_internal_set_blendshape_data(const std::string& value) {
  
  _impl_.blendshape_data_.Set(value, GetArenaForAllocation());
}
inline std::string* BlendShapesData::_internal_mutable_blendshape_data() {
  
  return _impl_.blendshape_data_.Mutable(GetArenaForAllocation());
}
inline std::string* BlendShapesData::release_blendshape_data() {
  // @@protoc_insertion_point(field_release:service.BlendShapesData.blendshape_data)
  return _impl_.blendshape_data_.Release();
}
inline void BlendShapesData::set_allocated_blendshape_data(std::string* blendshape_data) {
  if (blendshape_data != nullptr) {
    
  } else {
    
  }
  _impl_.blendshape_data_.SetAllocated(blendshape_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.blendshape_data_.IsDefault()) {
    _impl_.blendshape_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.BlendShapesData.blendshape_data)
}

// -------------------------------------------------------------------

// HelloRequest

// string name = 1;
inline void HelloRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& HelloRequest::name() const {
  // @@protoc_insertion_point(field_get:service.HelloRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HelloRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.HelloRequest.name)
}
inline std::string* HelloRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:service.HelloRequest.name)
  return _s;
}
inline const std::string& HelloRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void HelloRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* HelloRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* HelloRequest::release_name() {
  // @@protoc_insertion_point(field_release:service.HelloRequest.name)
  return _impl_.name_.Release();
}
inline void HelloRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.HelloRequest.name)
}

// -------------------------------------------------------------------

// HelloResponse

// string message = 1;
inline void HelloResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& HelloResponse::message() const {
  // @@protoc_insertion_point(field_get:service.HelloResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HelloResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.HelloResponse.message)
}
inline std::string* HelloResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:service.HelloResponse.message)
  return _s;
}
inline const std::string& HelloResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void HelloResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* HelloResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* HelloResponse::release_message() {
  // @@protoc_insertion_point(field_release:service.HelloResponse.message)
  return _impl_.message_.Release();
}
inline void HelloResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.HelloResponse.message)
}

// -------------------------------------------------------------------

// FeedbackRequest_Feedback

// bool thumbs_up = 1;
inline void FeedbackRequest_Feedback::clear_thumbs_up() {
  _impl_.thumbs_up_ = false;
}
inline bool FeedbackRequest_Feedback::_internal_thumbs_up() const {
  return _impl_.thumbs_up_;
}
inline bool FeedbackRequest_Feedback::thumbs_up() const {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.Feedback.thumbs_up)
  return _internal_thumbs_up();
}
inline void FeedbackRequest_Feedback::_internal_set_thumbs_up(bool value) {
  
  _impl_.thumbs_up_ = value;
}
inline void FeedbackRequest_Feedback::set_thumbs_up(bool value) {
  _internal_set_thumbs_up(value);
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.Feedback.thumbs_up)
}

// string feedback_text = 2;
inline void FeedbackRequest_Feedback::clear_feedback_text() {
  _impl_.feedback_text_.ClearToEmpty();
}
inline const std::string& FeedbackRequest_Feedback::feedback_text() const {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.Feedback.feedback_text)
  return _internal_feedback_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FeedbackRequest_Feedback::set_feedback_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.feedback_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.Feedback.feedback_text)
}
inline std::string* FeedbackRequest_Feedback::mutable_feedback_text() {
  std::string* _s = _internal_mutable_feedback_text();
  // @@protoc_insertion_point(field_mutable:service.FeedbackRequest.Feedback.feedback_text)
  return _s;
}
inline const std::string& FeedbackRequest_Feedback::_internal_feedback_text() const {
  return _impl_.feedback_text_.Get();
}
inline void FeedbackRequest_Feedback::_internal_set_feedback_text(const std::string& value) {
  
  _impl_.feedback_text_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedbackRequest_Feedback::_internal_mutable_feedback_text() {
  
  return _impl_.feedback_text_.Mutable(GetArenaForAllocation());
}
inline std::string* FeedbackRequest_Feedback::release_feedback_text() {
  // @@protoc_insertion_point(field_release:service.FeedbackRequest.Feedback.feedback_text)
  return _impl_.feedback_text_.Release();
}
inline void FeedbackRequest_Feedback::set_allocated_feedback_text(std::string* feedback_text) {
  if (feedback_text != nullptr) {
    
  } else {
    
  }
  _impl_.feedback_text_.SetAllocated(feedback_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.feedback_text_.IsDefault()) {
    _impl_.feedback_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.FeedbackRequest.Feedback.feedback_text)
}

// repeated string tags = 3;
inline int FeedbackRequest_Feedback::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int FeedbackRequest_Feedback::tags_size() const {
  return _internal_tags_size();
}
inline void FeedbackRequest_Feedback::clear_tags() {
  _impl_.tags_.Clear();
}
inline std::string* FeedbackRequest_Feedback::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:service.FeedbackRequest.Feedback.tags)
  return _s;
}
inline const std::string& FeedbackRequest_Feedback::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline const std::string& FeedbackRequest_Feedback::tags(int index) const {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.Feedback.tags)
  return _internal_tags(index);
}
inline std::string* FeedbackRequest_Feedback::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:service.FeedbackRequest.Feedback.tags)
  return _impl_.tags_.Mutable(index);
}
inline void FeedbackRequest_Feedback::set_tags(int index, const std::string& value) {
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.Feedback.tags)
}
inline void FeedbackRequest_Feedback::set_tags(int index, std::string&& value) {
  _impl_.tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.Feedback.tags)
}
inline void FeedbackRequest_Feedback::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:service.FeedbackRequest.Feedback.tags)
}
inline void FeedbackRequest_Feedback::set_tags(int index, const char* value, size_t size) {
  _impl_.tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:service.FeedbackRequest.Feedback.tags)
}
inline std::string* FeedbackRequest_Feedback::_internal_add_tags() {
  return _impl_.tags_.Add();
}
inline void FeedbackRequest_Feedback::add_tags(const std::string& value) {
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:service.FeedbackRequest.Feedback.tags)
}
inline void FeedbackRequest_Feedback::add_tags(std::string&& value) {
  _impl_.tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:service.FeedbackRequest.Feedback.tags)
}
inline void FeedbackRequest_Feedback::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:service.FeedbackRequest.Feedback.tags)
}
inline void FeedbackRequest_Feedback::add_tags(const char* value, size_t size) {
  _impl_.tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:service.FeedbackRequest.Feedback.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FeedbackRequest_Feedback::tags() const {
  // @@protoc_insertion_point(field_list:service.FeedbackRequest.Feedback.tags)
  return _impl_.tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FeedbackRequest_Feedback::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:service.FeedbackRequest.Feedback.tags)
  return &_impl_.tags_;
}

// bool is_test_case = 4;
inline void FeedbackRequest_Feedback::clear_is_test_case() {
  _impl_.is_test_case_ = false;
}
inline bool FeedbackRequest_Feedback::_internal_is_test_case() const {
  return _impl_.is_test_case_;
}
inline bool FeedbackRequest_Feedback::is_test_case() const {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.Feedback.is_test_case)
  return _internal_is_test_case();
}
inline void FeedbackRequest_Feedback::_internal_set_is_test_case(bool value) {
  
  _impl_.is_test_case_ = value;
}
inline void FeedbackRequest_Feedback::set_is_test_case(bool value) {
  _internal_set_is_test_case(value);
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.Feedback.is_test_case)
}

// -------------------------------------------------------------------

// FeedbackRequest

// string interaction_id = 1;
inline void FeedbackRequest::clear_interaction_id() {
  _impl_.interaction_id_.ClearToEmpty();
}
inline const std::string& FeedbackRequest::interaction_id() const {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.interaction_id)
  return _internal_interaction_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FeedbackRequest::set_interaction_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.interaction_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.interaction_id)
}
inline std::string* FeedbackRequest::mutable_interaction_id() {
  std::string* _s = _internal_mutable_interaction_id();
  // @@protoc_insertion_point(field_mutable:service.FeedbackRequest.interaction_id)
  return _s;
}
inline const std::string& FeedbackRequest::_internal_interaction_id() const {
  return _impl_.interaction_id_.Get();
}
inline void FeedbackRequest::_internal_set_interaction_id(const std::string& value) {
  
  _impl_.interaction_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedbackRequest::_internal_mutable_interaction_id() {
  
  return _impl_.interaction_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FeedbackRequest::release_interaction_id() {
  // @@protoc_insertion_point(field_release:service.FeedbackRequest.interaction_id)
  return _impl_.interaction_id_.Release();
}
inline void FeedbackRequest::set_allocated_interaction_id(std::string* interaction_id) {
  if (interaction_id != nullptr) {
    
  } else {
    
  }
  _impl_.interaction_id_.SetAllocated(interaction_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.interaction_id_.IsDefault()) {
    _impl_.interaction_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.FeedbackRequest.interaction_id)
}

// string character_id = 2;
inline void FeedbackRequest::clear_character_id() {
  _impl_.character_id_.ClearToEmpty();
}
inline const std::string& FeedbackRequest::character_id() const {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.character_id)
  return _internal_character_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FeedbackRequest::set_character_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.character_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.character_id)
}
inline std::string* FeedbackRequest::mutable_character_id() {
  std::string* _s = _internal_mutable_character_id();
  // @@protoc_insertion_point(field_mutable:service.FeedbackRequest.character_id)
  return _s;
}
inline const std::string& FeedbackRequest::_internal_character_id() const {
  return _impl_.character_id_.Get();
}
inline void FeedbackRequest::_internal_set_character_id(const std::string& value) {
  
  _impl_.character_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedbackRequest::_internal_mutable_character_id() {
  
  return _impl_.character_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FeedbackRequest::release_character_id() {
  // @@protoc_insertion_point(field_release:service.FeedbackRequest.character_id)
  return _impl_.character_id_.Release();
}
inline void FeedbackRequest::set_allocated_character_id(std::string* character_id) {
  if (character_id != nullptr) {
    
  } else {
    
  }
  _impl_.character_id_.SetAllocated(character_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.character_id_.IsDefault()) {
    _impl_.character_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.FeedbackRequest.character_id)
}

// string session_id = 3;
inline void FeedbackRequest::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& FeedbackRequest::session_id() const {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FeedbackRequest::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.session_id)
}
inline std::string* FeedbackRequest::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:service.FeedbackRequest.session_id)
  return _s;
}
inline const std::string& FeedbackRequest::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void FeedbackRequest::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedbackRequest::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FeedbackRequest::release_session_id() {
  // @@protoc_insertion_point(field_release:service.FeedbackRequest.session_id)
  return _impl_.session_id_.Release();
}
inline void FeedbackRequest::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.FeedbackRequest.session_id)
}

// .service.FeedbackRequest.Feedback text_feedback = 5;
inline bool FeedbackRequest::_internal_has_text_feedback() const {
  return this != internal_default_instance() && _impl_.text_feedback_ != nullptr;
}
inline bool FeedbackRequest::has_text_feedback() const {
  return _internal_has_text_feedback();
}
inline void FeedbackRequest::clear_text_feedback() {
  if (GetArenaForAllocation() == nullptr && _impl_.text_feedback_ != nullptr) {
    delete _impl_.text_feedback_;
  }
  _impl_.text_feedback_ = nullptr;
}
inline const ::service::FeedbackRequest_Feedback& FeedbackRequest::_internal_text_feedback() const {
  const ::service::FeedbackRequest_Feedback* p = _impl_.text_feedback_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::FeedbackRequest_Feedback&>(
      ::service::_FeedbackRequest_Feedback_default_instance_);
}
inline const ::service::FeedbackRequest_Feedback& FeedbackRequest::text_feedback() const {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.text_feedback)
  return _internal_text_feedback();
}
inline void FeedbackRequest::unsafe_arena_set_allocated_text_feedback(
    ::service::FeedbackRequest_Feedback* text_feedback) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.text_feedback_);
  }
  _impl_.text_feedback_ = text_feedback;
  if (text_feedback) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.FeedbackRequest.text_feedback)
}
inline ::service::FeedbackRequest_Feedback* FeedbackRequest::release_text_feedback() {
  
  ::service::FeedbackRequest_Feedback* temp = _impl_.text_feedback_;
  _impl_.text_feedback_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service::FeedbackRequest_Feedback* FeedbackRequest::unsafe_arena_release_text_feedback() {
  // @@protoc_insertion_point(field_release:service.FeedbackRequest.text_feedback)
  
  ::service::FeedbackRequest_Feedback* temp = _impl_.text_feedback_;
  _impl_.text_feedback_ = nullptr;
  return temp;
}
inline ::service::FeedbackRequest_Feedback* FeedbackRequest::_internal_mutable_text_feedback() {
  
  if (_impl_.text_feedback_ == nullptr) {
    auto* p = CreateMaybeMessage<::service::FeedbackRequest_Feedback>(GetArenaForAllocation());
    _impl_.text_feedback_ = p;
  }
  return _impl_.text_feedback_;
}
inline ::service::FeedbackRequest_Feedback* FeedbackRequest::mutable_text_feedback() {
  ::service::FeedbackRequest_Feedback* _msg = _internal_mutable_text_feedback();
  // @@protoc_insertion_point(field_mutable:service.FeedbackRequest.text_feedback)
  return _msg;
}
inline void FeedbackRequest::set_allocated_text_feedback(::service::FeedbackRequest_Feedback* text_feedback) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.text_feedback_;
  }
  if (text_feedback) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(text_feedback);
    if (message_arena != submessage_arena) {
      text_feedback = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text_feedback, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.text_feedback_ = text_feedback;
  // @@protoc_insertion_point(field_set_allocated:service.FeedbackRequest.text_feedback)
}

// string user_query = 6;
inline void FeedbackRequest::clear_user_query() {
  _impl_.user_query_.ClearToEmpty();
}
inline const std::string& FeedbackRequest::user_query() const {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.user_query)
  return _internal_user_query();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FeedbackRequest::set_user_query(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_query_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.user_query)
}
inline std::string* FeedbackRequest::mutable_user_query() {
  std::string* _s = _internal_mutable_user_query();
  // @@protoc_insertion_point(field_mutable:service.FeedbackRequest.user_query)
  return _s;
}
inline const std::string& FeedbackRequest::_internal_user_query() const {
  return _impl_.user_query_.Get();
}
inline void FeedbackRequest::_internal_set_user_query(const std::string& value) {
  
  _impl_.user_query_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedbackRequest::_internal_mutable_user_query() {
  
  return _impl_.user_query_.Mutable(GetArenaForAllocation());
}
inline std::string* FeedbackRequest::release_user_query() {
  // @@protoc_insertion_point(field_release:service.FeedbackRequest.user_query)
  return _impl_.user_query_.Release();
}
inline void FeedbackRequest::set_allocated_user_query(std::string* user_query) {
  if (user_query != nullptr) {
    
  } else {
    
  }
  _impl_.user_query_.SetAllocated(user_query, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_query_.IsDefault()) {
    _impl_.user_query_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.FeedbackRequest.user_query)
}

// string response = 7;
inline void FeedbackRequest::clear_response() {
  _impl_.response_.ClearToEmpty();
}
inline const std::string& FeedbackRequest::response() const {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.response)
  return _internal_response();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FeedbackRequest::set_response(ArgT0&& arg0, ArgT... args) {
 
 _impl_.response_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.response)
}
inline std::string* FeedbackRequest::mutable_response() {
  std::string* _s = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:service.FeedbackRequest.response)
  return _s;
}
inline const std::string& FeedbackRequest::_internal_response() const {
  return _impl_.response_.Get();
}
inline void FeedbackRequest::_internal_set_response(const std::string& value) {
  
  _impl_.response_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedbackRequest::_internal_mutable_response() {
  
  return _impl_.response_.Mutable(GetArenaForAllocation());
}
inline std::string* FeedbackRequest::release_response() {
  // @@protoc_insertion_point(field_release:service.FeedbackRequest.response)
  return _impl_.response_.Release();
}
inline void FeedbackRequest::set_allocated_response(std::string* response) {
  if (response != nullptr) {
    
  } else {
    
  }
  _impl_.response_.SetAllocated(response, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.response_.IsDefault()) {
    _impl_.response_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.FeedbackRequest.response)
}

// -------------------------------------------------------------------

// FeedbackResponse

// string feedback_response = 1;
inline void FeedbackResponse::clear_feedback_response() {
  _impl_.feedback_response_.ClearToEmpty();
}
inline const std::string& FeedbackResponse::feedback_response() const {
  // @@protoc_insertion_point(field_get:service.FeedbackResponse.feedback_response)
  return _internal_feedback_response();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FeedbackResponse::set_feedback_response(ArgT0&& arg0, ArgT... args) {
 
 _impl_.feedback_response_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.FeedbackResponse.feedback_response)
}
inline std::string* FeedbackResponse::mutable_feedback_response() {
  std::string* _s = _internal_mutable_feedback_response();
  // @@protoc_insertion_point(field_mutable:service.FeedbackResponse.feedback_response)
  return _s;
}
inline const std::string& FeedbackResponse::_internal_feedback_response() const {
  return _impl_.feedback_response_.Get();
}
inline void FeedbackResponse::_internal_set_feedback_response(const std::string& value) {
  
  _impl_.feedback_response_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedbackResponse::_internal_mutable_feedback_response() {
  
  return _impl_.feedback_response_.Mutable(GetArenaForAllocation());
}
inline std::string* FeedbackResponse::release_feedback_response() {
  // @@protoc_insertion_point(field_release:service.FeedbackResponse.feedback_response)
  return _impl_.feedback_response_.Release();
}
inline void FeedbackResponse::set_allocated_feedback_response(std::string* feedback_response) {
  if (feedback_response != nullptr) {
    
  } else {
    
  }
  _impl_.feedback_response_.SetAllocated(feedback_response, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.feedback_response_.IsDefault()) {
    _impl_.feedback_response_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.FeedbackResponse.feedback_response)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace service

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::service::FaceModel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service::FaceModel>() {
  return ::service::FaceModel_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_service_2eproto

#endif
